{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-02-29T01:12:40.759452+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hash-to-curve",
  "labels": [
    {
      "name": "bug",
      "description": null,
      "color": "ee0701"
    },
    {
      "name": "duplicate",
      "description": null,
      "color": "cccccc"
    },
    {
      "name": "enhancement",
      "description": null,
      "color": "84b6eb"
    },
    {
      "name": "good first issue",
      "description": null,
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": null,
      "color": "33aa3f"
    },
    {
      "name": "invalid",
      "description": null,
      "color": "e6e6e6"
    },
    {
      "name": "question",
      "description": null,
      "color": "cc317c"
    },
    {
      "name": "wontfix",
      "description": null,
      "color": "ffffff"
    },
    {
      "name": "WIP",
      "description": "Work in progress",
      "color": "fbca04"
    },
    {
      "name": "nice-to-have",
      "description": "Nice to have",
      "color": "b60205"
    },
    {
      "name": "editorial",
      "description": "Editorial",
      "color": "6846a8"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWUyOTMzMDA1Njg=",
      "title": "Consider SWU as well?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/1",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-01-31T20:28:53Z",
      "updatedAt": "2018-02-12T15:48:15Z",
      "closedAt": "2018-02-12T15:48:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "https://eprint.iacr.org/2009/340.pdf\r\n",
          "createdAt": "2018-01-31T20:33:44Z",
          "updatedAt": "2018-01-31T20:33:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. We are considering it.",
          "createdAt": "2018-02-12T15:48:15Z",
          "updatedAt": "2018-02-12T15:48:15Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWUzMDA2ODEyMjc=",
      "title": "Implement plain old SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/2",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See the neat and tidy version in https://eprint.iacr.org/2009/340.pdf.\r\n",
      "createdAt": "2018-02-27T15:40:41Z",
      "updatedAt": "2018-06-01T00:30:30Z",
      "closedAt": "2018-06-01T00:30:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #25.\r\n",
          "createdAt": "2018-06-01T00:30:29Z",
          "updatedAt": "2018-06-01T00:30:29Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUzMDA2ODE1NzI=",
      "title": "Write the section on curve mappings.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/3",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "grittygrease"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "It's often useful to transform a Montgomery curve to a Weierstrass curve, and vice versa. We should provide details on how to do this.",
      "createdAt": "2018-02-27T15:41:29Z",
      "updatedAt": "2018-11-05T00:05:43Z",
      "closedAt": "2018-11-05T00:05:42Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Should also include transforming to (twisted) Edwards curve as well.\r\nWe will probably also need to mention different coordinate systems.",
          "createdAt": "2018-10-05T14:06:29Z",
          "updatedAt": "2018-10-05T14:06:29Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "(Coordinate systems, related to #4 )",
          "createdAt": "2018-10-05T14:06:57Z",
          "updatedAt": "2018-10-05T14:06:57Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Ideally this should just be a reference to some other document on how to transform. Otherwise it gets quite far away from the scope of the document, and starts being a complete doc on elliptic curves... I couldn't find anything suitable however.",
          "createdAt": "2018-10-05T18:32:22Z",
          "updatedAt": "2018-10-05T18:32:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "From the meeting:\r\n - Keep it brief, if you wish to use combinations not specified in this doc, there exist transformations (+ some minimal details).\r\n - The recommendations we present should obviate the need for applying transformations/composing alogrithms, since we specify precisely those recommended algorithms.",
          "createdAt": "2018-10-08T16:19:13Z",
          "updatedAt": "2018-10-08T16:19:13Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "Please close if the section is deemed complete.",
          "createdAt": "2018-11-04T03:52:12Z",
          "updatedAt": "2018-11-04T03:52:12Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWUzMDA2ODE2NTk=",
      "title": "Include a projective coordinate version of Elligator2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "",
      "createdAt": "2018-02-27T15:41:41Z",
      "updatedAt": "2019-07-08T23:30:52Z",
      "closedAt": "2019-07-08T23:30:52Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am on it.",
          "createdAt": "2019-01-25T19:51:17Z",
          "updatedAt": "2019-01-25T19:51:17Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWUzMDA2ODE3NDU=",
      "title": "Complete algorithm cost comparison table",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/5",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T15:41:53Z",
      "updatedAt": "2019-03-01T16:31:29Z",
      "closedAt": "2019-03-01T16:31:29Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Pending some quick checks, it seems most encoding algorithms are dominated by the cost of doing a modulo inverse. And then for FFSTV the cost is doubled. So instead of a complex table, we can just add something along those lines.\r\n\r\n(I suspect this issue was more relevant when we were going to have a range of options, as opposed to fixed recommendations).",
          "createdAt": "2019-02-10T03:05:37Z",
          "updatedAt": "2019-02-10T03:05:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #77.",
          "createdAt": "2019-03-01T16:31:29Z",
          "updatedAt": "2019-03-01T16:31:29Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUzMDEyNDkzODg=",
      "title": "Investigate Jacobi symbol for non-constant-time quadratic residue computation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/6",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-01T01:47:40Z",
      "updatedAt": "2018-10-18T20:58:08Z",
      "closedAt": "2018-10-18T20:58:08Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@grittygrease @samscott89 do either of you think we should add this? (Sticking with constant time algorithms is probably best.)",
          "createdAt": "2018-06-01T00:32:18Z",
          "updatedAt": "2018-06-01T00:32:18Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Constant time seems like the safest by far (and the simplest).\r\n\r\nShould note, however, that it works for the Legendre symbol (i.e. denominator needs to be prime, but I think that's always the case?). ",
          "createdAt": "2018-06-01T18:48:42Z",
          "updatedAt": "2018-06-01T18:48:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that's always the case for us. ",
          "createdAt": "2018-06-01T18:51:42Z",
          "updatedAt": "2018-06-01T18:51:42Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #56 ",
          "createdAt": "2018-10-18T20:58:08Z",
          "updatedAt": "2018-10-18T20:58:08Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUzMDU5MDY1Mzk=",
      "title": "Clean up algorithm descriptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "t &= \\mathsf{H}(\\alpha) \\\\\r\nx &= -t^2 \\\\ \r\nx_2 &= (-b / a) \\cdot (1 + (1 / (t^2 + t))) \\\\\r\nx_3 &= t \\cdot x_2 \\\\\r\nh_2 &= f(x_2) \\\\\r\nh_3 &= f(x_3) \\\\\r\n\\mathsf{Output} & (x_2, h_2^{(q + 1)/4}) \\text{ if } h_2 \\text{ is square, else} (x_3, h_3^{(q + 1)/4}) \r\n\r\nt & = \\mathsf{H}(\\alpha) \\\\\r\nv &= ((3A - t^4) / 6t) \\\\\r\nx & = (v^2 - b - (t^6 / 27))^{1/3} + (t^2 / 3) \\\\\r\ny & = tx + v \\\\\r\n\\mathsf{Output} & (x, y)\r\n\r\nr &= \\mathsf{H}(\\alpha) \\\\\r\nd &= -A / (1 + ur^2) \\\\\r\ne &= f(d)^{(p-1)/2} \\\\ \r\nu &= ed - (1 - e)A/u \\\\\r\n\\mathsf{Output} & (u, f(u))",
      "createdAt": "2018-03-16T12:17:09Z",
      "updatedAt": "2018-06-01T00:31:18Z",
      "closedAt": "2018-06-01T00:31:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed?",
          "createdAt": "2018-06-01T00:31:18Z",
          "updatedAt": "2018-06-01T00:31:18Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUzMDY3ODg4NzI=",
      "title": "RFC 5639 Curves brainpoolP256r1 and brainpoolP512r1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/8",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These have p=2 mod 3.",
      "createdAt": "2018-03-20T09:35:37Z",
      "updatedAt": "2019-02-09T21:10:11Z",
      "closedAt": "2019-02-09T21:10:11Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. These can be defined as additional ciphersuites should they be desired.",
          "createdAt": "2019-02-09T21:10:11Z",
          "updatedAt": "2019-02-09T21:10:11Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUzMDg1NzYxMDQ=",
      "title": "Add NIST P-521, Curve1174, and Koblitz curves such as secp256k1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/9",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-26T13:38:49Z",
      "updatedAt": "2019-03-01T16:30:51Z",
      "closedAt": "2019-03-01T16:30:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by several others. Closing.",
          "createdAt": "2019-03-01T16:30:51Z",
          "updatedAt": "2019-03-01T16:30:51Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUzMDg1NzcwNzQ=",
      "title": "Simplified SWU description is wrong",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/10",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\"5. Output (-g * alpha) * (g * beta)\"\r\n\r\n- g was not defined here, except above as a function of x, but here it is being used in a multiplication.\r\n- g might be confused with the generator point for the curve\r\n- The output should be in the form of a point with coordinates x and y, should it not?",
      "createdAt": "2018-03-26T13:41:12Z",
      "updatedAt": "2018-06-01T00:30:18Z",
      "closedAt": "2018-06-01T00:30:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #25.",
          "createdAt": "2018-06-01T00:30:18Z",
          "updatedAt": "2018-06-01T00:30:18Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWUzMDg1Nzc2MTI=",
      "title": "Simplified SWU step #21 needs constant time comparison",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/11",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Step \"21\" indicates an equality comparison.  Unless implemented specially, these could lead to side-channel attacks as an equality check of equal values takes longer than one where the values are unequal. It might be more secure to separately compute both comparisons, i.e. also compute \"e_2 = (y2 ^ 2 == h3)\" as a mitigation strategy or alternative to implementing constant time equality checks, which might not be readily available in different BigInteger libraries/languages.\r\n",
      "createdAt": "2018-03-26T13:42:37Z",
      "updatedAt": "2018-10-22T20:33:48Z",
      "closedAt": "2018-10-22T20:33:48Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUzMDg1Nzg2NTA=",
      "title": "Consider variable-length hash function in HashToBase",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/12",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An example is given that this can be any cryptographic hash function, such as SHA-256.  However, I think it would be better if this is defined as a method supporting variable length outputs.  For example, HKDF (Hmac Key Derivation Function).  The justification being that some elliptic curves operate on fields that are too large, even for SHA-512 (e.g. NIST P-521), and naive attempts at extending the length of a hash may otherwise be designed insecurely.\r\n\r\nIf the function is specified as HKDF (which operates on bytes rather than bits) there should be clarification as to which bits of the output are to be used (e.g. the left-most bits output by HKDF).",
      "createdAt": "2018-03-26T13:45:19Z",
      "updatedAt": "2019-02-09T16:34:45Z",
      "closedAt": "2019-02-09T16:34:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now.",
          "createdAt": "2019-02-09T16:34:45Z",
          "updatedAt": "2019-02-09T16:34:45Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWUzMDg1Nzk2OTg=",
      "title": "Clarify failure of probability for Try-and-Increment in terms of counter size",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/13",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Current pseudocode relies on I2OSP failing to avoid looping forever when ctr > 256^4. Although this only happens with probability 2^-32, perhaps it should be an explicit condition for the loop. This should also be acknowledged in the introduction, since the size of this counter determines the probability of failure, as in the MapToGroup approach.\r\n",
      "createdAt": "2018-03-26T13:47:58Z",
      "updatedAt": "2019-02-09T16:35:54Z",
      "closedAt": "2019-02-09T16:35:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as not needed.",
          "createdAt": "2019-02-09T16:35:54Z",
          "updatedAt": "2019-02-09T16:35:54Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUzMDg1Nzk5Mzk=",
      "title": "Clarify meaning of 2n-octet string",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/14",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Clarify the meaning of \"2n-octet string\u201d when introducing RS2ECP. Also, RS2ECP is not explicitly defined in RFC8032, but in https://tools.ietf.org/id/draft-goldbe-vrf-01.html#suites. According to that, only when curve is Ed25519, RS2ECP is defined in Section 5.1.3 of [RFC8032].\r\n",
      "createdAt": "2018-03-26T13:48:32Z",
      "updatedAt": "2018-10-23T15:03:36Z",
      "closedAt": "2018-10-22T20:33:44Z",
      "comments": [
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "I think this issue should be reopened. The Try-and-Increment Method should be generic, but the RS2ECP method described in Section 5.1.3 of [RFC8032] is not; in particular, it is defined for the curve used by Ed25519 (Section 5.1 is specific to that curve). For example, it assumes 32-byte strings. Other example is that step 1 of the method won't work for all types of curves. \r\n\r\nHow about using the method described in Section 2.3.4 of [SEC standard](http://www.secg.org/sec1-v2.pdf)? ",
          "createdAt": "2018-10-23T08:12:36Z",
          "updatedAt": "2018-10-23T08:12:36Z"
        },
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "Oh disregard my comment, I was looking to the html doc, which seems outdated.",
          "createdAt": "2018-10-23T14:52:40Z",
          "updatedAt": "2018-10-23T14:52:40Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry about that. I've updated the repo files to avoid confusion (for the time being...). ",
          "createdAt": "2018-10-23T15:03:36Z",
          "updatedAt": "2018-10-23T15:03:36Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUzMDg1ODE1NzQ=",
      "title": "Consider 2y^2=x^3+x/GF(8^91+5) curve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/15",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For what little it's worth, (I think that) none of the algorithms\r\nspecified in this I-D work for 2y^2=x^3+x/GF(8^91+5), because p=1 mod 3, p=1\r\nmod 4, and j=1728.\r\n\r\nFor this special curve, I sketched a modification of Elligator 2, which I\r\ncalled Elligator i, in Sections 5.2 (math) and C.10 (pseudocode) of\r\nhttps://datatracker.ietf.org/doc/draft-brown-ec-2y2-x3-x-mod-8-to-91-plus-5/\r\nthough I am not sure which set of curves it would generalize to.  (I admit I\r\ndon't recall trying Icart or SWU on this special curve: maybe some\r\nvariations of these would have worked just as well.)",
      "createdAt": "2018-03-26T13:52:35Z",
      "updatedAt": "2019-02-09T16:42:36Z",
      "closedAt": "2019-02-09T16:42:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can probably use SWU for this case.",
          "createdAt": "2019-01-25T19:49:25Z",
          "updatedAt": "2019-01-25T19:49:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as NTBF.",
          "createdAt": "2019-02-09T16:42:35Z",
          "updatedAt": "2019-02-09T16:42:35Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWUzMDk0NTM0ODM=",
      "title": "Add algorithm for pairing-friendly curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/16",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://link.springer.com/chapter/10.1007/978-3-642-33481-8_1\r\nhttp://ieeexplore.ieee.org/abstract/document/6827966/\r\n\r\nThe technique builds on SWU and Icart's variant, with a new encoding function suitable for BN curves.",
      "createdAt": "2018-03-28T17:08:04Z",
      "updatedAt": "2019-03-01T16:25:43Z",
      "closedAt": "2019-03-01T16:25:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #86.",
          "createdAt": "2019-03-01T16:25:43Z",
          "updatedAt": "2019-03-01T16:25:43Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUzMTA1ODkyNDA=",
      "title": "Clarify and discuss encoding, serialization, and hashing differences",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/17",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-02T19:51:42Z",
      "updatedAt": "2018-05-11T13:52:46Z",
      "closedAt": "2018-05-11T13:52:46Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This was finished in the last few commits: f6fe5ded54cecffe34a555424202c64571e72bdd, d7836f3351825f4f02d150c49b9a7a5f372f80ba.",
          "createdAt": "2018-05-11T13:52:46Z",
          "updatedAt": "2018-05-11T13:52:46Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWUzMjI2NDQyMDg=",
      "title": "Include https://eprint.iacr.org/2013/373",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/22",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-14T01:09:29Z",
      "updatedAt": "2019-02-10T00:06:39Z",
      "closedAt": "2019-02-10T00:06:38Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is the precursor to the Elligator paper, so I don't think there is anything to add?",
          "createdAt": "2019-02-09T21:22:01Z",
          "updatedAt": "2019-02-09T21:22:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it? I wasn't sure. Either way, I'm not sure there's new (or superior) material here, so I'm closing.",
          "createdAt": "2019-02-10T00:06:38Z",
          "updatedAt": "2019-02-10T00:06:38Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWUzMjI2NDQyNzM=",
      "title": "Include generic hash construction H(u,v) = F(u) + F(v)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/23",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "See https://eprint.iacr.org/2010/539 for details.",
      "createdAt": "2018-05-14T01:10:05Z",
      "updatedAt": "2019-01-26T01:35:39Z",
      "closedAt": "2019-01-26T01:35:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Do you think we should have a section for this?",
          "createdAt": "2018-05-14T21:38:47Z",
          "updatedAt": "2018-05-14T21:38:47Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what you mean by H(u, v)? But the construction H(m) = f(h1(m)) + f(h2(m)) should definitely be included, as well as H(m) = f(h1(m)) + h2(m)*G. And specifically, what encoding functions `f` are appropriate for each.",
          "createdAt": "2018-05-14T22:29:21Z",
          "updatedAt": "2018-05-14T22:29:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, sorry. Here, u=H1(m) and v=H2(m). I think a new section for this type of RO construction is probably needed.",
          "createdAt": "2018-05-14T22:30:53Z",
          "updatedAt": "2018-05-14T22:30:53Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Those two (which one depending on suitability of encoding functions f) should be the default answer to \"I need to hash to the curve\". In the absence of any other info, they give you a proper RO, whereas the others generally don't.\r\n\r\nYep, I'm planning to add something along these lines when I get the chance. ",
          "createdAt": "2018-05-14T22:32:06Z",
          "updatedAt": "2018-05-14T22:32:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool, that matches my understanding. I can take a crack at this section if you don't mind, and if you weren't planning on doing it in the next couple of days?",
          "createdAt": "2018-05-14T22:33:23Z",
          "updatedAt": "2018-05-14T22:33:23Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, please do!",
          "createdAt": "2018-05-14T22:40:11Z",
          "updatedAt": "2018-05-14T22:40:11Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Want to pick up this conversation from the merged PR:\r\n\r\n>>  We should probably cite Brier et al. https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13 as the primary reference for the general construction (they proved it for Icart function only though). And also can use the other generalized construction H(m) = f(h1(m)) + h2(m)G which you can show holds for Elligator\r\n\r\n> Do we really want to specify two generic mechanisms when one would suffice?\r\n\r\nIdeally, no, but I'm not sure if the hash-encode-twice (HET) method can be applied for Elligator, whereas the hash-encode-basepoint (HEB) method has a much easier condition to prove for compatibility. The proof that Elligator holds for HEB is straightforward (needs to be checked though). Proving Elligator is compatible with HET seems to potentially require digging into the algebraic geometry. Might well be worth doing though.",
          "createdAt": "2018-05-28T15:28:16Z",
          "updatedAt": "2018-05-28T15:28:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 We should do it!",
          "createdAt": "2018-05-28T16:07:46Z",
          "updatedAt": "2018-05-28T16:07:46Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Even better if we can rope a mathematician into doing the Elligator/HET proof (or alternatively disproving it).",
          "createdAt": "2018-05-28T16:29:18Z",
          "updatedAt": "2018-05-28T16:29:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I concur. :)",
          "createdAt": "2018-05-28T16:46:48Z",
          "updatedAt": "2018-05-28T16:46:48Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We have had this for a while under the name \"FFSTV13\"",
          "createdAt": "2019-01-26T01:35:39Z",
          "updatedAt": "2019-01-26T01:35:39Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWUzMjcwNzA1NTE=",
      "title": "Add hash-encode-basepoint (HEB) method",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/26",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #23.",
      "createdAt": "2018-05-28T16:08:15Z",
      "updatedAt": "2019-03-19T02:10:48Z",
      "closedAt": "2019-03-19T02:10:48Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This is my justification for why Elligator is compatible with the HEB method:\r\n\r\nFor an encoding function f to work with the HEB method, it needs to satisfy Definition 3 of Brier et al.\r\n\r\n> Definition 3 (Weak Encoding). A function f : S \u2192 R between finite sets is said\r\nto be an \u03b1 -weak encoding if it satisfies the following properties:\r\n\r\n> 1. Computable: f is computable in deterministic polynomial time.\r\n\r\n> 2. \u03b1 -bounded: for s uniformly distributed in S , the distribution of f ( s )\r\nis \u03b1 - bounded in R , i.e. the inequality Pr s [ f ( s )= r ] \u2264 \u03b1/ # R holds\r\nfor any r \u2208 R .\r\n\r\n> 3. Samplable: there is an efficient randomized algorithm I such that I ( r )\r\ninduces the uniform distribution in f ^{\u22121} ( r ) for any r \u2208 R . Additionally\r\nI ( r ) returns N_r =# f^{\u22121} ( r ) for all r \u2208 R\r\n\r\n(1) is certainly true for Elligator.\r\n(2) holds with \u03b1=2 since every point on the curve either has precisely 0 or 2 pre-images.\r\n(3) holds since that is precisely what the Elligator mapping achieves. For any r in E(Fp), f^{-1}(r) is either the empty set, or +/- t (where f(t) = r), and can be computed efficiently using the Elligator mapping.",
          "createdAt": "2018-05-28T16:41:54Z",
          "updatedAt": "2018-05-28T16:41:54Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We are actually missing formal justification for the FFSTV(*) combinations... Some relevant discussion is here: https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/23 ",
          "createdAt": "2019-02-09T21:24:27Z",
          "updatedAt": "2019-02-09T21:24:27Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Tracking the lack of proofs in #93. If we complete that, we can close this issue.",
          "createdAt": "2019-03-15T15:58:59Z",
          "updatedAt": "2019-03-15T15:58:59Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This is unnecessary given conclusion in #93 ",
          "createdAt": "2019-03-19T02:10:47Z",
          "updatedAt": "2019-03-19T02:10:47Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWUzMjgzNDA1NzQ=",
      "title": "Add hacspec implementation of Elligator2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:00Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUzMjgzNDA2MDY=",
      "title": "Add hacspec implementation of Icart",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:10Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUzMjgzNDA2Mzg=",
      "title": "Add hacspec implementation of SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/29",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:22Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUzMjgzNDA2NTk=",
      "title": "Add hacspec implementation of simplified SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/30",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:32Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUzMzU2MTAzMzY=",
      "title": "Include SPEKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/32",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "https://eprint.iacr.org/2014/585.pdf",
      "createdAt": "2018-06-26T00:03:54Z",
      "updatedAt": "2019-02-09T16:39:03Z",
      "closedAt": "2019-02-09T16:39:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We reference it already. Closing.",
          "createdAt": "2019-02-09T16:39:03Z",
          "updatedAt": "2019-02-09T16:39:03Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUzNDExNDg1NzA=",
      "title": "Consider Elligator Squared",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/34",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://eprint.iacr.org/2014/043.pdf",
      "createdAt": "2018-07-13T20:23:22Z",
      "updatedAt": "2019-02-09T21:24:56Z",
      "closedAt": "2019-02-09T21:24:56Z",
      "comments": [
        {
          "author": "goldbe",
          "authorAssociation": "NONE",
          "body": "My g-d, elligator2 and elligator squared. And they are different. What are these insane naming conventions. that people come up with!",
          "createdAt": "2018-07-23T21:52:01Z",
          "updatedAt": "2018-07-23T21:52:01Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided this was unnecessary.",
          "createdAt": "2019-02-09T21:24:56Z",
          "updatedAt": "2019-02-09T21:24:56Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUzNDM4MDU2NDM=",
      "title": "Add \"ciphersuite\" configurations for curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/35",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "grittygrease"
      ],
      "labels": [],
      "body": "We should provide a \u201cciphersuite\u201d with test vectors for 25519 and 448, which requires us to provide explicit hash to base recommendations (minimum output size in general, algo in specific suites)\r\n",
      "createdAt": "2018-07-23T21:39:15Z",
      "updatedAt": "2019-02-09T16:07:56Z",
      "closedAt": "2019-02-09T16:07:55Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "From meeting discussion:\r\n - We should have one recommendation per curve. E.g. Ed25519 + elligator + SHA256.\r\n - This should be worded unambiguously.\r\n - This eliminates the need (in this doc) for ciphersuite options, since the curve dictates the choice?",
          "createdAt": "2018-10-08T16:16:55Z",
          "updatedAt": "2018-10-08T16:16:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 I'm closing this issue since we now have ciphersuites. Do you want to open a new issue to include the ciphersuite-per-curve recommendations? ",
          "createdAt": "2019-02-09T16:07:55Z",
          "updatedAt": "2019-02-09T16:07:55Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWUzNDM4MDU3NzA=",
      "title": "Are encodings injective or bijective?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/36",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:39:40Z",
      "updatedAt": "2019-02-09T21:05:46Z",
      "closedAt": "2019-02-09T21:05:46Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #74.",
          "createdAt": "2019-02-09T21:05:46Z",
          "updatedAt": "2019-02-09T21:05:46Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUzNDM4MDU4MzM=",
      "title": "Propose an OpenSSL API (but not in the doc)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:39:54Z",
      "updatedAt": "2019-03-01T16:28:29Z",
      "closedAt": "2019-03-01T16:28:29Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUzNDM4MDU4OTQ=",
      "title": "Fix u=2 for Elligator2 (Curve25519)?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/38",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:40:07Z",
      "updatedAt": "2018-10-22T20:33:38Z",
      "closedAt": "2018-10-22T20:33:38Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUzNDM4MDU5NTA=",
      "title": "Add bitcoin curve recommendation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/39",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:40:18Z",
      "updatedAt": "2019-03-01T16:29:18Z",
      "closedAt": "2019-03-01T16:29:18Z",
      "comments": [
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "This is covered by issue #9, which asks for secp256k1, so I guess this issue is redundant.\r\n\r\nBTW, are you going to provide a recommendation for this curve? There are lot of projects that would benefit from such recommendation.",
          "createdAt": "2019-02-12T06:36:55Z",
          "updatedAt": "2019-02-12T06:36:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. @cygnusv, please reopen if necessary.",
          "createdAt": "2019-03-01T16:29:18Z",
          "updatedAt": "2019-03-01T16:29:18Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUzNDQyNzY0NzU=",
      "title": "Specify HashToBase details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/40",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per Richard Barnes' email:\r\n\r\n1. Interpret H(x) as a big-endian integer h\r\n2. Reduce h mod 2^(log2(p) + 1)\r\n3. Reduce h mod p",
      "createdAt": "2018-07-25T03:13:27Z",
      "updatedAt": "2019-02-09T21:06:52Z",
      "closedAt": "2019-02-09T21:06:52Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This was done across #56 and #72",
          "createdAt": "2019-02-09T21:06:52Z",
          "updatedAt": "2019-02-09T21:06:52Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUzNDQyNzcyNjY=",
      "title": "Remove use of alpha variable in simple_swu algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/41",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-25T03:17:48Z",
      "updatedAt": "2019-02-09T16:00:55Z",
      "closedAt": "2019-02-09T16:00:55Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUzNDQyNzc1MjY=",
      "title": "Make clear that prepended 0/1 are bytes in FFSTV13 section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/42",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-25T03:19:16Z",
      "updatedAt": "2018-10-22T20:12:10Z",
      "closedAt": "2018-10-22T20:12:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #59.\r\n",
          "createdAt": "2018-10-22T20:12:10Z",
          "updatedAt": "2018-10-22T20:12:10Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWUzNDQ1NjgzMzg=",
      "title": "Composition of encoding + Ristretto/Decaf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/43",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "samscott89"
      ],
      "labels": [],
      "body": "The Decaf approach \r\n\r\nhttps://www.shiftleft.org/papers/decaf/\r\n\r\nhttps://ristretto.group/",
      "createdAt": "2018-07-25T19:03:28Z",
      "updatedAt": "2020-06-09T18:58:52Z",
      "closedAt": "2019-10-27T06:15:25Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "To be discussed: how to best handle this. Although these seem like \"the right choices\" for implementers choosing a curve, they aren't yet fully specified.\r\n\r\nIt would be ideal if we could (a) add them when well specified, and (b) target compatibility between the hashing approaches.",
          "createdAt": "2018-10-05T18:29:13Z",
          "updatedAt": "2018-10-05T18:29:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on the meeting, we will update the such that the curve->algorithm table maps curves->output group, where output group is one of (all)P-256, Ristretto (prime order subgroup of Curve25519), etc.",
          "createdAt": "2018-10-08T16:53:10Z",
          "updatedAt": "2018-10-08T16:53:10Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "After a deeper dive into Ristretto, I no longer think this is necessary. If the output of h2c is an Edwards point, the algorithm can treat that as the representative element of the Ristretto group. From there they can use regular Edwards arithmetic and the Ristretto comparison function. When they need to serialize a point in the group, they can use the Ristretto encoding.",
          "createdAt": "2018-11-04T03:24:26Z",
          "updatedAt": "2018-11-04T03:24:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/146#issuecomment-509231171) re: Ristretto h2c",
          "createdAt": "2019-07-08T20:15:32Z",
          "updatedAt": "2019-07-08T20:15:32Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "In fact, Ristretto has two possible implementations based on an Ed25519, depending upon the branch of the inverse square root used.  These two choices result in compatible wire formats, so any purely Ristretto tests would pass no matter which you choose, but If two implementations employ different branches then they have different map between Edwards and Ristretto.  \r\n\r\nRistretto authors have chosen never to expose the map, which prevents interoperation of protocols using Ed25519 and Ristretto keys, and prevents extending older Ed25519 protocols with Ristretto in particular, but their choice ensures Ristretto itself has less risk of non-compliant implementations. ",
          "createdAt": "2019-07-08T22:00:01Z",
          "updatedAt": "2019-07-08T22:00:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We're in the process of hashing out separation of responsibilities between h2c and the ristretto draft with the ristretto authors. The most likely path seems to be that there will not be a map specified in h2c for Ristretto. I am closing this; we will create a new issue to track action items once the path ahead is clear.\r\n\r\n(#174 is tracking the discussion with Ristretto authors for now)",
          "createdAt": "2019-10-27T06:15:25Z",
          "updatedAt": "2019-10-27T06:15:25Z"
        },
        {
          "author": "paulmillr",
          "authorAssociation": "NONE",
          "body": "What's status of this? I don't see an alternative mentioned in current draft besides h_eff.",
          "createdAt": "2020-05-22T20:12:10Z",
          "updatedAt": "2020-05-22T20:12:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The decision is that Ristretto will specify its own hash-to-group interface (FROM_UNIFORM_BYTES is what it's called in the current draft). I am not sure whether there will be a discussion of higher-level primitives, i.e., how to go from an arbitrary message to the input bytes. (In principle it's possible to do this using the expand_message variants in h2c, or with something like HKDF, a PRG, etc.)",
          "createdAt": "2020-06-09T18:58:52Z",
          "updatedAt": "2020-06-09T18:58:52Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWUzNTQ0MTA5MTM=",
      "title": "Simplified SWU sign of t^2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/45",
      "state": "CLOSED",
      "author": "reyzin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/chris-wood/draft-sullivan-cfrg-hash-to-curve/blob/fdb70a5f0c836a4ab8090c5a84952c688e5ccc35/draft-irtf-cfrg-hash-to-curve.txt#L566\r\n\r\nShould the sign in front of t^2 be minus rather than plus (see step 4 of the algorithm, which computes alpha^2 + alpha where alpha is -t^2; see also Proposition 7 of https://eprint.iacr.org/2009/340.pdf)",
      "createdAt": "2018-08-27T17:42:41Z",
      "updatedAt": "2019-02-09T16:42:05Z",
      "closedAt": "2019-02-09T16:42:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@reyzin this is now fixed, although I think we have a similar bug in the main SWU algorithm.",
          "createdAt": "2019-02-09T16:42:05Z",
          "updatedAt": "2019-02-09T16:42:05Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWUzNTQ0MTM0ODQ=",
      "title": "CMOV condition: only 0 or 1?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/46",
      "state": "CLOSED",
      "author": "reyzin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/chris-wood/draft-sullivan-cfrg-hash-to-curve/blob/fdb70a5f0c836a4ab8090c5a84952c688e5ccc35/draft-irtf-cfrg-hash-to-curve.txt#L350\r\n\r\nThe CMOV called for in the draft is quite general: it allows the condition to be not only 1 or 0, but any value. The uses of CMOV later in the draft rely on this. However, it is more complicated to implement a time-invariant CMOV for such a case. In fact, OpenSSL's CMOV assumes 0 or 1 (see https://github.com/openssl/openssl/blob/7d38ca3f8bca58bf7b69e78c1f1ab69e5f429dff/crypto/ec/curve25519.c#L1475), and thus the more general CMOV may be unavailable to a developer. Moreover, a developer may not realize that the CMOV available in code is not the same as the more powerful CMOV called for in the draft, because the name is the same.",
      "createdAt": "2018-08-27T17:50:04Z",
      "updatedAt": "2019-02-07T15:41:15Z",
      "closedAt": "2019-02-07T15:41:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #64 with the following text:\r\n\r\n```\r\n  Common software implementations of constant-time selects assume c = 1 or c = 0. CMOV\r\n\t  may be implemented by computing the desired selector (0 or 1) by ORing all bits of c\r\n\t  together. The end result will be either 0 if all bits of c are zero, or 1 if at least\r\n\t  one bit of c is 1.\r\n```\r\n\r\nPlease re-open if this does not satisfy the issue!",
          "createdAt": "2019-02-07T15:41:15Z",
          "updatedAt": "2019-02-07T15:41:15Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzNTYyMzg2NTk=",
      "title": "s/Random Oracles/Indifferentiable Hashing title name",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/47",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:00:41Z",
      "updatedAt": "2019-02-07T15:43:27Z",
      "closedAt": "2019-02-07T15:43:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now, since I can't recall why we opened this. @grittygrease @samscott89 please re-open if you can remember the rationale!",
          "createdAt": "2019-02-07T15:43:27Z",
          "updatedAt": "2019-02-07T15:43:27Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWUzNTYyMzkxNTI=",
      "title": "Add example table usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/48",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:11:24Z",
      "updatedAt": "2019-02-09T21:05:40Z",
      "closedAt": "2019-02-09T21:05:40Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #74.",
          "createdAt": "2019-02-09T21:05:40Z",
          "updatedAt": "2019-02-09T21:05:40Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWUzNTYyMzkxNjc=",
      "title": "Remove restriction to non-binary curves in section 2.2.1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/49",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:11:41Z",
      "updatedAt": "2018-10-22T19:29:48Z",
      "closedAt": "2018-10-22T19:29:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed!",
          "createdAt": "2018-10-22T19:29:48Z",
          "updatedAt": "2018-10-22T19:29:48Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWUzNTYyMzkyNTY=",
      "title": "Various edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/50",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. Section 2 states that n = qh + r, where n is order of the group of elliptic curve points, q is a prime order of a subgroup of the group of elliptic curve points, h is a cofactor and r is a remainder. Is there any sense to use value r? Every nonzero r directly violates Lagrange's theorem.\r\n\r\n2. In the sixth paragraph of Section 2 states that n can be estimated using Hasse's theorem as |n-p| < 2 * sqrt(p). This is true for the prime field case, otherwise we have to use Hasse-Weil theorem.\r\n\r\n3. The same paragraph refers that if point (x, y) belongs to some curve, then (x, -y) also does. It must be stated explicitly, that it is true for certain curve forms \u2013 because this is not true for some coordinate forms like twisted Edwards.\r\n\r\n4. The second paragraph of Section 2.1.1 states that \"In most cases, the curve E is over a finite field GF(p^k), with p > 2.\". Are you sure about it? The vast majority of standardized curves defined over extension fields seems to have p = 2.\r\n\r\n5. Some clarifications about two separate HashToBase implementations should be added into Section 5.2.2.\r\n\r\n6. Section 5.2.2, paragraph 6. Add word <<short>> before <<Weierstrass form>>.\r\n\r\n7. Section 5.2.4. Description of Elligator2 method uses f(x) function and returns its value instead of a pair of coordinates.\r\n\r\n8. Appendix B, paragraph 1. \u201cSection Section\u201d.\r\n\r\n9. Appendix B, algorithm description, step 4E. Does symbol ^ stay here for scalar point multiplication?\r\n\r\n10. I believe that the HashToBase function has to be described as explicitly as it is possible (including byte order, possible hash function sets for different curves) (the same issue with \u201cbe as explicit as possible\u201d applies to our \u201cRandomness improvements \u2026\u201d draft also J\r\n\r\n11. Appendix A.5. \u201c&#8746\u201d instead of cup symbol?\r\n\r\n12. Misprints: \u201cartbirary\u201d, \u201csimplified\u201d.",
      "createdAt": "2018-09-01T23:13:39Z",
      "updatedAt": "2018-10-22T19:29:13Z",
      "closedAt": "2018-10-22T19:29:13Z",
      "comments": [
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "- [x] 1. Definitely. I suggest we remove r and say that q is the largest prime factor.\r\n- [x] 2. Also true. Generally, we use curves over prime fields as examples in this document but I don't see why these algorithms wouldn't apply to, say extension fields. We can add the Hasse-Weil bound here as well, but maybe it's better to ask if we need to say anything about the order of the curve group vs the field. I don't think we do. Consider dropping this paragraph?\r\n- [x] 3. Yes. We should state that this is true in Weierstrass form, and that every curve is isogenous to a curve that can be expressed in Weierstrass form. (side note: \"Elliptic curves come in many variants\" should also be rephrased appropriately as \"Elliptic curves can be represented by equations of different standard forms\" or something)\r\n- [x] 4. Right. Binary curves (p=2) are a thing, and more common than the extension field curves defined for pairing-based cryptography. The good thing about elements of binary curves is you can express them as bit strings pretty easily. A line about that should resolve this.\r\n- [x] 5. #59 takes care of this\r\n- [x] 6. TODO?\r\n- [x] 7.  The first lines are still confusing here\r\n- [x] 8. Resolved?\r\n- [x] 9. Needs to be changed to scalar point multiplication\r\n- [x] 10. #59 \r\n- [x] 11. Yes\r\n- [x] 12. To be fixed?",
          "createdAt": "2018-10-19T23:05:09Z",
          "updatedAt": "2018-10-21T20:11:45Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWUzNTYyMzk2MDI=",
      "title": "Include HashToBase recommendation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/51",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:22:25Z",
      "updatedAt": "2018-10-09T05:19:51Z",
      "closedAt": "2018-10-09T05:19:51Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWUzNTYyMzk2Mzg=",
      "title": "Note u=0/1 cases for modular inverse, and possible edge cases with side channel",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/52",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:23:09Z",
      "updatedAt": "2019-06-03T22:48:04Z",
      "closedAt": "2019-06-03T22:48:04Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Many algorithms take modular inverses, where the input can be zero. Forcing this to happen requires finding inputs to HashToBase which produce 0. We could require computing inverses as `x^(p-1)` to plug this.",
          "createdAt": "2019-02-09T22:20:38Z",
          "updatedAt": "2019-02-09T22:20:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 defined `inv0`, which handles this case, so I believe this issue can be closed.",
          "createdAt": "2019-06-03T22:37:04Z",
          "updatedAt": "2019-06-03T22:37:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Closing with #104.",
          "createdAt": "2019-06-03T22:48:04Z",
          "updatedAt": "2019-06-03T22:48:04Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWUzNjcyODA1Nzg=",
      "title": "Fix Elligator2 definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/53",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the return statement of Elligator 2 is\r\n\r\n```\r\n19. Output (u, f(u))\r\n```\r\nBut this should be `sqrt(f(u))`.\r\nHowever, this requires guidance on which square root to choose.",
      "createdAt": "2018-10-05T16:22:04Z",
      "updatedAt": "2019-02-09T21:25:59Z",
      "closedAt": "2019-02-09T21:25:58Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of other bugs:\r\n```\r\n11.  e = v3 * v (mod p)\r\n...\r\n13.  e = v2 * e (mod p)\r\n```\r\nThese should both be `+`. Otherwise `e = Av^6` instead of `e = v^3 + Av^2 + v` !!\r\nAlso, it needs to be `e = v3 + B*v` for general curves.\r\n\r\n",
          "createdAt": "2018-10-05T16:40:42Z",
          "updatedAt": "2018-10-05T16:40:42Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "While we're at it. Some other improvements:\r\n - inconsistent variable naming\r\n - shadowing of parameters (`u`).\r\n\r\n(thanks to Eric Crockett for point out all of these issues)",
          "createdAt": "2018-10-05T16:58:30Z",
          "updatedAt": "2018-10-05T16:58:30Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Line 4 of the \"alternate\" Elligator2 algorithm is `u = ed - (1 - e)A/u`, but the paper uses `u = ed - (1 - e)A/2`.",
          "createdAt": "2018-10-08T20:44:58Z",
          "updatedAt": "2018-10-08T20:44:58Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Please be consistent with the output of the algorithms. The first algorithm in 5.2.4 outputs just the `y` coordinate. The second \"alternate\" algorithm outputs nothing, or just the `x` coordinate, depending on your interpretation. The implementation outputs a pair.",
          "createdAt": "2018-10-08T21:06:17Z",
          "updatedAt": "2018-10-08T21:06:17Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Here's a proposal for fixes to section 5.2.4 (alignment excepted). My changes are in bold.\r\n\r\n-----\r\n\r\nThe following map2curve_elligator2(alpha) implements the Elligator2 method from [Elligator2].  This algorithm works for any curve with a point of order 2 and j-invariant != 1728.  Given curve equation f(x) = y^2 = x(x^2 + Ax + B), i.e., a Montgomery form with the point of order 2 at (0,0), **and a fixed non-square value in Fp,** this algorithm works as shown below.  (Note that any curve with a point of order 2 is isomorphic to this representation.)\r\n\r\n   1. r = HashToBase(alpha)\r\n**2. v= -A/(1+ur^2)**\r\n**3. If f(v) is a square, then output (v, f(v)^(1/2))**\r\n**4. Else, output (-v-A, f(-v-A)^(1/2))**\r\n\r\nAnother way to express this algorithm is as follows:\r\n\r\n   1. r = HashToBase(alpha)\r\n   2. v = -A / (1 + ur^2)\r\n   3. e = f(v)^((p-1)/2)\r\n   4. x = ed - (1 - e)A/**2**\r\n   **5. Output (x,f(x)^(1/2))** \r\n\r\nHere, e is the Legendre symbol of **z = v^3 + Av^2 + Bv**, which will be 1 if z is a quadratic residue (square) mod p, and -1 otherwise. (Note that raising z to ((p -1) / 2) is a common way to compute the Legendre symbol.)\r\n\r\nThe following procedure implements this algorithm.\r\n\r\n   map2curve_elligator2(alpha)\r\n\r\n   Input:\r\n\r\n     alpha - value to be encoded, an octet string\r\n\r\n     u - fixed non-square value in Fp.\r\n     f() - Curve function\r\n\r\n   Output:\r\n\r\n     (x, y) - a point in E\r\n\r\n   Steps:\r\n\r\n1.   r = HashToBase(alpha)\r\n2.   r = r^2 (mod p)\r\n   3.   r = r * u (mod p)\r\n   4.   r = r + 1 (mod p)\r\n   5.   r = r^(-1) (mod p)\r\n   6.   v = A * r (mod p)\r\n   7.   v = v * -1 (mod p)   // -A / (1 + ur^2)\r\n   8.   v2 = v^2 (mod p)\r\n**9.   e = v2 * v (mod p)**\r\n**10. v2 = v2 * A (mod p)**\r\n**11. v = v * B (mod p)**\r\n**12.  e = v2 + e (mod p)**\r\n**13.  e = v + e (mod p)**\r\n   14.  e = e^((p - 1) / 2) **(mod p)**  // Legendre symbol\r\n   15. nv = v * -1 (mod p)\r\n   16  **x1** = CMOV(v, nv, e)   // If e = 1, choose v, else choose nv\r\n   17. **x2** = CMOV(0, A, e)    // If e = 1, choose 0, else choose A\r\n**18.  x = x1 - x2 (mod p)**\r\n   19. Output (x, f(x)^(1/2))\r\n\r\n   Elligator2 can be simplified with projective coordinates.\r\n",
          "createdAt": "2018-10-08T21:39:48Z",
          "updatedAt": "2018-10-08T21:39:48Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "These were completed in #72",
          "createdAt": "2019-02-09T21:25:58Z",
          "updatedAt": "2019-02-09T21:25:58Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWUzNjcyODI0NjM=",
      "title": "Choosing the sign of the encoded point",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/54",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As in #53, many algorithms require taking a square root and choosing one. In some cases we have an additional bit left over from HashToBase (e.g. with Curve25519 and SHA256, there is a free bit).\r\nWe can consider using this bit as a sign (as at the end of 2.6 of https://signal.org/docs/specifications/xeddsa/#hashing-to-a-point-with-elligator-2).",
      "createdAt": "2018-10-05T16:28:01Z",
      "updatedAt": "2019-06-04T15:38:45Z",
      "closedAt": "2019-06-04T15:38:45Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I think as per some of the discussion in #59, it's better to think of the bit as choosing the sign of the point, as opposed to the square root. This also helps with the ambiguity in whether it's `(x, +/-y)` or `(+/-u, v)` or something.",
          "createdAt": "2018-10-20T16:02:43Z",
          "updatedAt": "2018-10-20T16:02:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This question is worth answering in the context of other maps, too.\r\n\r\nSWU and SW (a.k.a. Fouque-Tibouchi) both rely only on hash2base(alpha)^2, so the sign of hash2base(alpha) can be used to select the sign of the output point.",
          "createdAt": "2019-04-26T23:00:43Z",
          "updatedAt": "2019-04-26T23:00:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 defined the sign for every encoding, which addresses this issue.",
          "createdAt": "2019-06-03T22:37:48Z",
          "updatedAt": "2019-06-03T22:37:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as fixed in #104.",
          "createdAt": "2019-06-04T15:38:45Z",
          "updatedAt": "2019-06-04T15:38:45Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWUzNjcyODMxNTQ=",
      "title": "Consider parity with Signal spec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/55",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per the title, as one concrete existing implementation of this functionality, plus an existing spec. We should consider whether we want to agree with the existing Signal specification https://signal.org/docs/specifications/xeddsa/.",
      "createdAt": "2018-10-05T16:30:08Z",
      "updatedAt": "2019-01-26T01:30:48Z",
      "closedAt": "2019-01-26T01:30:48Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to drop this as a goal.",
          "createdAt": "2019-01-26T01:30:48Z",
          "updatedAt": "2019-01-26T01:30:48Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUzNzI1MjExMjQ=",
      "title": "Icart Issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/61",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some issues from Greg Rubin:\r\n> Please check steps 15-17 in map2curve_icart on page 7. It doesn't make sense.\r\nAccording to the comment (and code) at the end of step 16, `t1 = (2p - 1)/3`, however in step 17 you raise _x_ (with a current value of `v^2 - b - u^6/27` from step 14) to the power of _t1_ and claim the result is `(v^2 - b - u^6/27) ^ (1/3)`.  Unless I'm missing something in the math, you actually get `(v^2 - b - u^6/27) ^ ((2p - 1)/3)`.\r\n\r\n> Thinking about it, step 15 doesn't really make sense anyway. As the whole thing is `mod p`, isn't that step just equivalent to `t1 = -1 mod p`? I'm clearly missing something.\r\n\r\nStep 15 is in the group of exponents, i.e. `mod (p-1)`. Which is what gives the equivalence required (2p-1)/3 = 1/3 `mod (p-1)`.\r\n",
      "createdAt": "2018-10-22T13:27:35Z",
      "updatedAt": "2018-10-22T20:42:34Z",
      "closedAt": "2018-10-22T20:42:34Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUzNzI1MzkzMjk=",
      "title": "Code improvements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/62",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some requested improvements to the algorithms:\r\n\r\n - > Please do *not* reuse variables across different data types. (Step 2 of Simplified SWU changes the type of _alpha_ from an octet string to an integer.)\r\n - > Please add at least one known answer test for each algorithm (you don't need it per curve)\r\n - > separate your precomputable/reusable values from those which aren't. ",
      "createdAt": "2018-10-22T14:15:02Z",
      "updatedAt": "2019-02-09T21:26:37Z",
      "closedAt": "2019-02-09T21:26:37Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #72  :)",
          "createdAt": "2019-02-09T21:26:29Z",
          "updatedAt": "2019-02-09T21:26:29Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUzNzI1Mzk1OTU=",
      "title": "Add flow-chart to determine algorithm for an arbitrary curve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/63",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-22T14:15:42Z",
      "updatedAt": "2019-11-05T07:21:08Z",
      "closedAt": "2019-11-05T07:21:08Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think #185 handles this. @samscott89 if you disagree please feel free to reopen.",
          "createdAt": "2019-11-05T07:21:08Z",
          "updatedAt": "2019-11-05T07:21:08Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWUzNzI2ODkwNDk=",
      "title": "SWU  with p = 1 (mod 4)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/66",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For SWU, we write\r\n>  This algorithm works for any curve over F_{p^n}. \r\n\r\nWhich is true, but as far as I understand, to make it work with p = 1 (mod 4), (ignoring n>1 case for now), you need to use a modified Tonelli-Shanks algorithm to keep it constant time. We should probably specify this.",
      "createdAt": "2018-10-22T20:37:05Z",
      "updatedAt": "2019-02-10T03:10:40Z",
      "closedAt": "2019-02-10T03:10:40Z",
      "comments": []
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUzNzI4Njk0MzU=",
      "title": "SWU when A=0 in curve equation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/69",
      "state": "CLOSED",
      "author": "cygnusv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Current version of the draft asserts the following with respect to the SWU method:\r\n\r\n> This algorithm works for any curve over F_{p^n}\r\n\r\n\r\n> Every elliptic curve can be converted to an equivalent curve in short Weierstrass form ([BL07] Theorem 2.1), making SWU a generic algorithm that can be used for all curves\r\n\r\nHowever, the SWU method (and its simplified version) require the computation of `-B/A`, which is undefined when `A=0`. \r\n\r\nThis is related to #9 and #39, since it's a problem for curve SECP256K1, with curve equation `y^2 = x^3 + 7` (i.e, `A=0` and `B=7`).",
      "createdAt": "2018-10-23T08:24:18Z",
      "updatedAt": "2019-02-09T22:06:20Z",
      "closedAt": "2019-02-09T22:06:20Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, good catch. We will make sure to address this in the next version.",
          "createdAt": "2018-10-23T15:00:40Z",
          "updatedAt": "2018-10-23T15:00:40Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered in #72 ",
          "createdAt": "2019-02-09T22:06:20Z",
          "updatedAt": "2019-02-09T22:06:20Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWUzNzI5NTc1MzM=",
      "title": "Safe encoding of inputs to HashToBase",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/70",
      "state": "CLOSED",
      "author": "cygnusv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The motivation of this question is that current draft doesn't state what's the intended behaviour of HashToBase if the input `x` and parameter `label` are empty bytestrings. If they are simply ignored (e.g., `\"abc\" || empty_bytestring == \"abc\"`), then there are potential collisions in HashToBase.\r\n\r\nLet's focus on the input of the hash function during the first step of HashToBase:\r\n`H(\"h2c\" || label || I2OSP(i, 4) || x)`\r\n\r\nAssume that `I2OSP(i, 4)` has some specific value (e.g., '00000000', which is the default). The hash `H(\"h2c\" || 00000000 || 00000000)` corresponds to two different configurations:\r\n\r\n- `label = 00000000` and `x` is empty\r\n- `label` is empty and `x = 00000000`\r\n\r\nA possible solution is to prepend the length of `label` and `x` to both values.",
      "createdAt": "2018-10-23T11:46:56Z",
      "updatedAt": "2019-02-09T22:06:45Z",
      "closedAt": "2019-02-09T22:06:45Z",
      "comments": [
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "A more generic example is the following. Let `j` and `k` be 4-byte strings. The hash `H(\"h2c\" || j || k)` corresponds to two different configurations:\r\n\r\n- `label=j`, `i=k`, and `x` empty\r\n- `label` is empty, ' i=j` and `x=k`\r\n\r\n",
          "createdAt": "2018-10-23T14:38:30Z",
          "updatedAt": "2018-10-23T14:38:30Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "_Theoretically_ `label` should be a fixed value, corresponding to the ciphersuite (as in [Section 8](https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-02#section-8)), which would be a fixed string in all cases.\r\nBut, this does seem like a potential footgun, and we should also consider how to protect against length extension attacks for example.",
          "createdAt": "2018-10-23T14:57:45Z",
          "updatedAt": "2018-10-23T14:57:45Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered in #72",
          "createdAt": "2019-02-09T22:06:45Z",
          "updatedAt": "2019-02-09T22:06:45Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU0MDI3NjQ0OTY=",
      "title": "Rewrite random oracle construction to work around incomplete Montgomery point addition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/71",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-24T15:36:17Z",
      "updatedAt": "2019-06-05T16:52:10Z",
      "closedAt": "2019-06-05T16:52:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as NTBF. @armfazh please re-open if needed!",
          "createdAt": "2019-06-05T16:52:10Z",
          "updatedAt": "2019-06-05T16:52:10Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU0MDUwMTQzNDI=",
      "title": "Step 8 of SWU is incorrect",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/73",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It reads:\r\n```\r\n   8. Output (X3(t, u), sqrt(g(X3)))\r\n```\r\nwhereas it should be:\r\n```\r\n   8. Output (X3, sqrt(g(X3)))\r\n```\r\n\r\n",
      "createdAt": "2019-01-30T23:36:41Z",
      "updatedAt": "2019-02-07T15:38:57Z",
      "closedAt": "2019-02-07T15:38:57Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I just patched the file directly without a PR. Closing!",
          "createdAt": "2019-02-07T15:38:57Z",
          "updatedAt": "2019-02-07T15:38:57Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU0MDg5OTI4NzU=",
      "title": "Multiplying by cofactor",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/79",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bug: points calculated by Elligator2 suite must be multiplied by the cofactor at the end (Sage script does not do that). Also I consider this task is not optional as the document says.\r\n\r\n_Originally posted by @armfazh in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/77#issuecomment-462507667_",
      "createdAt": "2019-02-11T21:50:36Z",
      "updatedAt": "2019-06-05T14:53:11Z",
      "closedAt": "2019-06-05T14:53:11Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi. I'm not sure if this should require a separate issue, but in section 5.3.5 \"Fouque-Tibouchi method\" I don't see mentioned that multiplying by the cofactor is \"usually\" necessary for BLS curves either.\r\nTo quote Fouque-Tibouchi: \r\n> Our results apply almost without change to any elliptic curve of the form [\u2026]: this includes in  particular the curves constructed by Barreto, Lynn and Scott in [2, \u00a73.1] and [\u2026]\r\n> The elliptic curve group in those cases is not usually of prime order, [\u2026], so hashing to the prime order subgroup requires multiplying the point obtained with the technique described herein by the cofactor. This does not affect indifferentiability, as was shown in [12, \u00a76.1].\r\n\r\nIn a recent work of [Budroni and Pintore](https://eprint.iacr.org/2017/419.pdf)  present a (much) faster way of multiplying by the cofactor in G2.\r\n\r\n Would it be welcome a pull request that mentions in which cases it is necessary to multiply by the cofactor? \r\nWould it be pertinent to mention also Pintore-Budroni as a way of performing fast multiplication by the cofactor? \r\nShould there be a sage poc?\r\n\r\n/cc. @AnitaDurr\r\n/cc. @armfazh (a little bird told me you're the right person for asking this!)",
          "createdAt": "2019-03-17T12:14:57Z",
          "updatedAt": "2019-03-17T14:14:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Your comments were moved to #95.\r\n@mmaker\r\n@AnitaDurr\r\n",
          "createdAt": "2019-03-19T17:08:47Z",
          "updatedAt": "2019-03-19T17:08:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "All encodings now invoke `clear_h()` as the last step, which (at least abstractly) addresses this issue by making cofactor clearing non-optional.\r\n\r\nSo this is addressed in the document, but not here. We could move the impl part into #112 and close this one.",
          "createdAt": "2019-06-03T22:40:36Z",
          "updatedAt": "2019-06-03T22:40:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved for the main document, and moving the implementation work to #112.",
          "createdAt": "2019-06-05T14:53:11Z",
          "updatedAt": "2019-06-05T14:53:11Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU0MDg5OTQ1NDE=",
      "title": "Consider to remove index in Hash2base input",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/80",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am aware that the index allows to separate calls to `hash2base` function inside of SWU and on the construction of Random Oracles. \r\nHowever, I think that the index can be handled externally as follows:\r\n```\r\nRandomOracle(alpha) = hash2Base( alpha || 0 ) + hash2Base( alpha || 1 )\r\n```\r\nand SWU can be handled in the same fashion.  \r\n```\r\ndef SWU(alpha):\r\n    u = hash2Base(label || alpha || 0 ) \r\n    v = hash2Base(label || alpha || 1 )\r\n```\r\nThis modification eases the internal implementation of `hash2base` function and does not require to indicate default values for index in the cases where it is not present.\r\n",
      "createdAt": "2019-02-11T21:55:12Z",
      "updatedAt": "2019-03-01T16:28:11Z",
      "closedAt": "2019-03-01T16:28:11Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "@grittygrease ",
          "createdAt": "2019-02-11T22:26:31Z",
          "updatedAt": "2019-02-11T22:26:31Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "What is your proposed change to the text?",
          "createdAt": "2019-02-11T22:31:44Z",
          "updatedAt": "2019-02-11T22:31:44Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking on something like this. (PR will come soon)\r\n\r\n```\r\nHashToBase(x)\r\n\r\nParameters:\r\n\r\n  H - cryptographic hash function to use\r\n  hbits - number of bits output by H\r\n  p - order of the base field Fp\r\n  label - context label for domain separation\r\n\r\nPreconditions:\r\n\r\n  floor(log2(p)) + 1 >= hbits\r\n\r\nInput:\r\n\r\n  x - value to be hashed, an octet string\r\n\r\nOutput:\r\n\r\n  y - a value in the field Fp\r\n\r\nSteps:\r\n\r\n  1. t1 = H(\"h2c\" || label || I2OSP(len(x), 4) || x)\r\n  2. t2 = OS2IP(t1)\r\n  3. y = t2 (mod p)\r\n  4. Output y\r\n```\r\n",
          "createdAt": "2019-02-11T22:52:05Z",
          "updatedAt": "2019-02-11T22:52:05Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "If we were to make this change, we would have to make sure the encoding of the index in the external call is handled correctly. E..g in `RandomOracle(alpha) = hash2Base( alpha || 0 ) + hash2Base( alpha || 1 )`, fixing it to be `RandomOracle(alpha) = hash2Base( alpha || 0x00 ) + hash2Base( alpha || 0x01 )`, so that it is exactly one byte. \r\n\r\nBut this seems reasonable since we only have 4 indexes.",
          "createdAt": "2019-02-12T18:41:19Z",
          "updatedAt": "2019-02-12T18:41:41Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "On the other hand, what I like about the current use of the index, is to make it clear that you are doing domain separation. ",
          "createdAt": "2019-02-12T18:42:36Z",
          "updatedAt": "2019-02-12T18:42:36Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Domain separation is right and using just one byte is enough. Decide whether this byte should be pre- or post-fixed.\r\n",
          "createdAt": "2019-02-12T19:04:17Z",
          "updatedAt": "2019-02-12T19:04:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see a strong reason to change this, so I would prefer to leave the text as is.",
          "createdAt": "2019-02-12T19:10:35Z",
          "updatedAt": "2019-02-12T19:10:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason is simplicity. There are only two cases (SWU & RandomOracles) that require domain separation. And this can be handled externally to the `HashToBase` function.\r\n",
          "createdAt": "2019-02-12T20:01:47Z",
          "updatedAt": "2019-02-12T20:01:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Why is including the index and concatenating inside HashToBase more difficult than concatenating before calling HashToBase? I think seeing a PR would help clear this up.",
          "createdAt": "2019-02-12T20:05:33Z",
          "updatedAt": "2019-02-12T20:05:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "A: It is equivalent concatenating before or inside the function calling.\r\nHowever, my point is that each function must have only one job to do. and I consider that `HashToBase` is getting overloaded with details that only concern to specific algorithms, particularly SWU.",
          "createdAt": "2019-02-12T20:24:50Z",
          "updatedAt": "2019-02-12T20:24:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a fair point. Functions with optional arguments are annoying. Can you prepare a PR for us to discuss?",
          "createdAt": "2019-02-12T21:25:04Z",
          "updatedAt": "2019-02-12T21:25:04Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Look at PR #83 for proposed changes.",
          "createdAt": "2019-02-13T00:41:11Z",
          "updatedAt": "2019-02-13T00:41:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #83.",
          "createdAt": "2019-03-01T16:28:11Z",
          "updatedAt": "2019-03-01T16:28:11Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU0MDkwMDU3ODY=",
      "title": "Consider to deprecate hash2increment?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/81",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The purpose of the document is to avoid this bad practice (hash&increment), maybe it must be deprecated or recommended at last resort.\r\n@grittygrease ",
      "createdAt": "2019-02-11T22:26:44Z",
      "updatedAt": "2019-03-01T16:25:26Z",
      "closedAt": "2019-03-01T16:25:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you mean try and increment? I'm not sure it's bad practice, so I think deprecation is a bit extreme. Perhaps we can ask the list?",
          "createdAt": "2019-02-11T22:28:36Z",
          "updatedAt": "2019-02-11T22:28:36Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should leave it, but not give it a ciphersuite or recommend its use.",
          "createdAt": "2019-02-11T22:35:59Z",
          "updatedAt": "2019-02-11T22:35:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now. We can re-open if others really want to see this happen.",
          "createdAt": "2019-03-01T16:25:26Z",
          "updatedAt": "2019-03-01T16:25:26Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU0MDkwMDc0MjM=",
      "title": "Fix a selection method for roots",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/82",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### background\r\nThe `sqrt(x)` function mathematically provides two correct answers, say r0, r1 \\in Fp such that `r0^2=r1^2=x` and r0+r1 = p\r\n### issue\r\nMost of the encoding papers prove how to obtain points on a elliptic curve internally using the `sqrt` function and this is enough for mathematical purposes. \r\nHowever, for implementation purposes this could bring a source of errors/incompatibilities if the `sqrt` function is not defined accordingly. \r\nI see two options to fix this issue:\r\n\r\n1. Declare explicitly how to compute the `sqrt` function for each case. Although that for `p=3 mod 4` is easy, the remainder cases are not easy to state.\r\n\r\n2. Declare explicitly which root to choose. Relying on math, the document can state, for example, that the valid root to use is the one that is odd (or even). It is known that either `r0` or `r1` will be odd. This allows the implementer to use the best-known algorithm for computing `sqrt` as soon as the root returned by it be the one that is odd (or even).\r\n\r\nI believe that Option 2 is suitable and more flexible. \r\nHappy to hear your comments about it.\r\n\r\n",
      "createdAt": "2019-02-11T22:31:35Z",
      "updatedAt": "2019-06-04T15:38:25Z",
      "closedAt": "2019-06-04T15:38:24Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #54.",
          "createdAt": "2019-02-11T22:34:03Z",
          "updatedAt": "2019-02-11T22:34:03Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Something that inspires this issue was the following script.\r\n```\r\np = 11\r\nF = GF(p)\r\nF(4) ** ((p+1)//4) == sqrt(F(4))  \r\n```\r\nThis should print `true` however is not, because `sqrt` from Sage not always follows the formula for p=3 mod 4.\r\n\r\n",
          "createdAt": "2019-02-11T22:35:10Z",
          "updatedAt": "2019-02-11T22:35:10Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point. We should be explicit. How do you determine whether an element is odd or even in an extension field?",
          "createdAt": "2019-02-11T22:39:52Z",
          "updatedAt": "2019-02-11T22:39:52Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "If `a \\in Fp` (a prime field), then `ZZ(a) mod 2 = {even,odd}`.\r\nIn the case of an extension field, we can think about testing the first component of the element.\r\nExample: if `a \\in Fp^3` then the element can be written as  `a= a_2x^2+a_1x+a_0`, thus testing `ZZ(a_0) mod 2 = {even,odd}` gives the desired property.",
          "createdAt": "2019-02-11T22:48:35Z",
          "updatedAt": "2019-02-11T22:48:35Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "As far as I can tell, this is only an issue in the case of a non-deterministic/non-constant time square root?\r\n\r\nSince we are recommending CT implementations, this might not be an issue (other than updating the sage checks). This was partially addressed in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/76.\r\n\r\nFor all of the ciphersuites we describe, we have the constant time method via exponentiation.  Are there other popularly used curves/fields which don't fit into those two scenarios?\r\n\r\n",
          "createdAt": "2019-02-12T20:12:43Z",
          "updatedAt": "2019-02-12T20:12:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh might you have time to take a stab at this?",
          "createdAt": "2019-02-28T01:35:35Z",
          "updatedAt": "2019-02-28T01:35:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "My initial observation is to allow the implementer to use any algorithm for calculating `sqrt` and the hash2curve mapping must state which of the roots to use.\r\nThere are two evidences of this reasoning:\r\n1) In the future, better algorithms for `sqrt` could appear. \r\n  Example: It is known that for p=3 mod 4, the exponent (p+1)/4 gives us one of the roots. However, in the future, it could be a better algorithm that computes `sqrt` that does not obtain the same root as the one obtained by the previous method. \r\n2) Notice that in EdDSA, the calculation of `sqrt` is not explicitly stated, but what is explicitly stated is which root to choose using one bit.  \r\n2.1) In the RFC8032 (Ed25519/448), there is a recommendation about how to compute `sqrt`, but any correct method can work as well.\r\n\r\nThe problem now is how to choose one root over the other. This can be done as I mentioned [above](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/82#issuecomment-462526235). Such a method works, except for elements on extension fields.\r\nThe next task is to find a method that allows distinguishing the roots on extension fields.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-03-01T20:41:06Z",
          "updatedAt": "2019-03-01T20:41:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, your approach sounds reasonable to me. Can you please prepare a PR?",
          "createdAt": "2019-03-04T16:07:15Z",
          "updatedAt": "2019-03-04T16:07:15Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Future proofing for an improved constant time square root algorithm feels like premature optimization. Won't the majority of use cases use the simple deterministic algorithms? I would support adding guidance in the appendix for the other cases, however.",
          "createdAt": "2019-03-04T16:51:59Z",
          "updatedAt": "2019-03-04T16:51:59Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "It is true, deterministic algorithms is what is required for `sqrt`.\r\n\r\nHowever, calculating `sqrt(a)` gives two possible answers, the problem now is: which root to choose in order to `hash2curve` be also deterministic. \r\n\r\nWe can offer guidance on how to choose a root in order to make test vectors reproducible.\r\nI can prepare a small paragraph summarizing this discussion.\r\n",
          "createdAt": "2019-03-04T18:00:22Z",
          "updatedAt": "2019-03-04T18:00:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess my point is whether we should specify precisely how to calculate square root in a deterministic way. Which makes the choice of root redundant, since a deterministic algorithm already \"chooses\" a root inherently.\r\n\r\nIf it were the case that all algorithms only need to use `a^(p-1)/2` or similar, then the resulting implementation is substantially simpler - just compute the exponentiation, there is no awkward root-choosing code.\r\n\r\nIf, on the hand, we allow people to implement `sqrt` however they wish, then I agree this is necessary. It just seems to me that we should be leaning towards the former scenario as much as possible.\r\n\r\n---\r\n\r\nEdit to add: I'm generally thinking of this as \"constant time if and only if deterministic\". We require the former, and achieving the latter motivates not needing a selection method",
          "createdAt": "2019-03-10T20:16:47Z",
          "updatedAt": "2019-03-10T20:18:40Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "This issue also comes up in the context of serialization of curve points (that is, representing curve points as bits), when using the compressed-point representation. I'd suggest coordinating with the folks handling the pairing-curves draft.\r\n\r\nMeanwhile, here's a pointer to how serialization is handled in zcash\r\nhttps://github.com/zkcrypto/pairing/blob/183a64b08e9dc7067f78624ec161371f1829623e/src/bls12_381/ec.rs#L837",
          "createdAt": "2019-04-16T19:21:22Z",
          "updatedAt": "2019-04-16T19:21:22Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The changes in #104 fix the sign of the output rather than the sign of the sqrt, which addresses this issue. In addition, #115 gives explicit sqrt functions for p = 3 mod 4, p = 5 mod 8, and p = 9 mod 16, which covers essentially every case of interest.",
          "createdAt": "2019-06-03T22:41:56Z",
          "updatedAt": "2019-06-03T22:42:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed. Closing as fixed in #104.",
          "createdAt": "2019-06-04T15:38:24Z",
          "updatedAt": "2019-06-04T15:38:24Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU0MDk5NDkzNTY=",
      "title": "Awkward description of FFSTV",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/85",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think the way we specify the FFSTV (and potentially all the algorithms) is a bit clunky (at best) or ambiguous.\r\n\r\nIf we look at https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#general-construction-ffstv13-ffstv\r\n\r\n```\r\n~~~\r\nhash2curve(alpha) = F(H0(alpha)) + F(H1(alpha))\r\n~~~\r\n\r\nThis construction works for the Icart, SWU, and Simplfied SWU encodings.\r\n\r\nHere, H0 and H1 are constructed as follows:\r\n\r\n~~~\r\nH0(alpha) = HashToBase(alpha || 0x2)\r\nH1(alpha) = HashToBase(alpha || 0x3)\r\n~~~\r\n```\r\n\r\nJust to check we are in agreement with what this is/should be doing. As it is written, you will hash alpha (with 0x02 or 0x03), pass the result to F. Which generally speaking will compute another hash. \r\n\r\nI.e. in Icart, you would effectively have `u = HashToBase(HashToBase(alpha || 0x02))` when computing the first of those? Which is a bit confusing since HashToBase outputs an element in Fp.\r\n\r\nAs an alternative, would we consider rewriting the algorithms to all be `Fp -> E`... Which saves the redundant hashing for some algorithms, but is messy since SWU actually needs `(Fp x Fp) -> E`.\r\n\r\nAnyway, just checking that the above is a correct reading.",
      "createdAt": "2019-02-13T18:50:14Z",
      "updatedAt": "2019-03-01T18:29:19Z",
      "closedAt": "2019-03-01T18:29:18Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I just updated #84 concerning this issue.\r\n",
          "createdAt": "2019-02-13T19:36:22Z",
          "updatedAt": "2019-02-13T19:36:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice! That looks like a clean way to address this.",
          "createdAt": "2019-02-13T23:19:41Z",
          "updatedAt": "2019-02-13T23:19:41Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #84 ",
          "createdAt": "2019-03-01T18:29:18Z",
          "updatedAt": "2019-03-01T18:29:18Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU0MTUyNjMxODA=",
      "title": "Two minor bugs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/87",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the description of HashToBase in section 4, there is a requirement that \u201cH is a hash function which outputs at least floor(log2(p))+**2** bits. In appendix C.5 however, the precondition says that the hash function should output >= floor(log2(p))+**1** bits. I'm not sure which is correct, but they should be consistent.\r\n\r\nIn the algorithm for SimpleSWU, the overview says that the right factor of alpha is (1+(1/(t^4 **+** t^2))), but the original paper (Prop 7) shows (1+(1/(t^4 **-** t^2))). The problem is only in the overview; the algorithm details look correct because step 3 negates alpha.\r\n",
      "createdAt": "2019-02-27T18:23:12Z",
      "updatedAt": "2019-03-01T16:23:55Z",
      "closedAt": "2019-03-01T16:23:55Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The second error was fixed in the current version (github) of the draft.\r\nSee https://raw.githubusercontent.com/chris-wood/draft-irtf-cfrg-hash-to-curve/master/draft-irtf-cfrg-hash-to-curve.md\r\n",
          "createdAt": "2019-02-27T19:36:17Z",
          "updatedAt": "2019-02-27T19:36:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@crockeea I pushed a fix for the first issue to master. It should just be 1 bit.",
          "createdAt": "2019-03-01T16:23:54Z",
          "updatedAt": "2019-03-01T16:23:54Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU0MTYxNzg3ODU=",
      "title": "Consider renaming HashToBase to hash2base for consistency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/88",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-01T16:24:34Z",
      "updatedAt": "2019-03-01T21:13:31Z",
      "closedAt": "2019-03-01T21:13:31Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU0MTk1OTMyNzI=",
      "title": "wrong BLS reference curve vs signature",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/90",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nin section 5.3.5. Fouque-Tibouchi Method\r\nThe reference to BLS curve points to the work of BLS signatures.\r\nBLS signatures ->  [BLS01]\r\nBLS curve -> [BLS02]\r\n\r\n[BLS02] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Constructing elliptic curves with prescribed embedding degrees. SCN. 2002",
      "createdAt": "2019-03-11T17:29:06Z",
      "updatedAt": "2019-03-11T18:48:00Z",
      "closedAt": "2019-03-11T18:48:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh can you prepare a PR quickly to fix this? We can update the version shortly thereafter.",
          "createdAt": "2019-03-11T17:30:05Z",
          "updatedAt": "2019-03-11T17:30:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #91.\r\n",
          "createdAt": "2019-03-11T18:48:00Z",
          "updatedAt": "2019-03-11T18:48:00Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU0MjE1ODk3MjE=",
      "title": "Are all encodings \"well-distributed\" as defined in FFSTV?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/93",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "help wanted"
      ],
      "body": "Edit: See below, the core issue is showing whether all encodings are \"well-distributed\" which is necessary to use the FFSTV `F(H1(m)) + F(H2(m))` generic RO mechanism.\r\n\r\n----\r\n\r\nWe are missing proofs for using the FFSTV encoding -> RO mechanism for most of the ciphersuites. The original paper (IIRC) proved it for Icart.\r\n\r\nRelated issues: #23 #26 ",
      "createdAt": "2019-03-15T15:58:21Z",
      "updatedAt": "2019-03-19T02:10:24Z",
      "closedAt": "2019-03-19T02:09:57Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The FFSTV paper states that \r\n```\r\nH(m) = F(H1(m)) + F(H2(m)) \r\n```\r\nis indistinguishable of a random oracle for any encoding `F` that is well-distributed.\r\nHence, this construction is not restricted to the Icart function.\r\n\r\nIs there something I am missing related to this issue?\r\n\r\n",
          "createdAt": "2019-03-15T21:55:13Z",
          "updatedAt": "2019-03-15T21:55:13Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "You're right, I should word it differently. As far as I'm aware the proof for well-distributed(ness) of the other encoding methods is missing.\r\n\r\nRelevant summary from the intro: ![sec](https://imgur.com/orw3NHQ.png)\r\n\r\nI would love to be wrong if there are existing proofs for Elligator, SWU,etc to meet the well-distributed condition. But the line\r\n\r\n> but the proof requires rather technicaltools from algebraic geometry, and uses many particular properties of Icart\u2019s function, which makesit difficult to adapt to other encodings\r\n\r\nMake that sound unlikely?\r\n\r\nI had a rough proof for Elligator2 meeting the conditions of the easier construction `F(H1(m)) + H2(m)G` for . (Requires it being an \"admissable encoding\").",
          "createdAt": "2019-03-16T15:28:22Z",
          "updatedAt": "2019-03-16T15:28:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding of the FFSTV paper is that they were able to prove that \r\n```\r\nH(m) = F(h_1(m))+ ... + F(h_s(m))\r\n```\r\nis a random oracle assuming two new things: \r\n -  `s > 1=genus(E)` and \r\n - the condition for `F` is **relaxed** from _admissible_ to **well-distributed**.\r\n\r\nNow, in order to prove that `F` is well-distributed can be done through bounding character sums (algebraic techniques), instead of using algebraic-geometry techniques. \r\n\r\nProofs for well-distributed(ness):\r\n - Icart (FFSTV Section 5.1)\r\n - SWU (FFSTV Section 5.3)\r\n - Elligator 1 (Tib. Section 4.2) \r\n - FT method for BN Curves (FT2012 and TIB Section 4.3)\r\n\r\nA similar argument as for Elligator 1 can be used for proving that Elligator2 is well-distributed.\r\n\r\n\r\n##### Refs:\r\n[FFSTV] Indifferentiable deterministic hashing to elliptic and hyperelliptic curves\r\n[TIB] Elligator squared (Tibouchi)\r\n[FT] Indifferentiable hashing to barreto-naehrig curves.\r\n\r\n",
          "createdAt": "2019-03-18T23:37:39Z",
          "updatedAt": "2019-03-18T23:37:39Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Ahh, you're right, I was misreading it, but the statement from before was applied to previous results. Okay, that's great. Closing this.",
          "createdAt": "2019-03-19T02:09:57Z",
          "updatedAt": "2019-03-19T02:10:24Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU0MjI4NDEzMDc=",
      "title": "encoding for pairings G1 and G2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/95",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is about this comment: https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/79#issuecomment-473659903\r\n\r\n@mmaker\r\n@AnitaDurr\r\n\r\n",
      "createdAt": "2019-03-19T16:48:03Z",
      "updatedAt": "2019-10-27T06:01:46Z",
      "closedAt": "2019-10-27T06:01:46Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "From the current draft:\r\n> The map2curve_ft(alpha) implements the Fouque-Tibouchi's method {{FT12}} (Sec. 3, Def. 2) which covers the case of pairing-friendly curves E : y^2 = x^3 + B. Note that for pairing curves the destination group is usually a subgroup of the curve, hence, a scalar multiplication by the cofactor will be required to send the point to the desired subgroup.\r\n\r\n#### Facts\r\nIn all the cases, draft recommends to multiply by the cofactor to get a point in a subgroup of the curve. \r\nFor both G1 and G2, there is required to multiply by a cofactor. However, it is true that for G2, the cofactor multiplication is more expensive than on G1.\r\n\r\n#### Comments\r\nAt the end of the day, cofactor multiplication is a scalar multiplication, which can be optimized according to the parameters of the curve.\r\nI think that explaining the techniques used for efficiently perform this scalar multiplication is out of the scope of this draft. \r\nDevelopers are free to chose any method that calculates cP for a cofactor c, where the point P was obtained through the techniques presented in this draft, i.e P=H(m).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-03-19T17:07:41Z",
          "updatedAt": "2019-03-19T17:07:41Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Armando, \r\nthanks for your reply. I thought that it was worth mentioning them since there are not many other motivations for scott and fuentes' methods except hashing -- and in \"Guide to pairing-based cryptography\" I see they're illustrated as a part of hashing into the curve. \r\n\r\nCheers.",
          "createdAt": "2019-03-19T17:18:16Z",
          "updatedAt": "2019-03-19T17:18:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Of course, references to these works will be very useful for the community. Thanks for pointing this out.",
          "createdAt": "2019-03-19T17:30:20Z",
          "updatedAt": "2019-03-19T17:30:20Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing that's probably worth pointing out is that in general the fast cofactor elimination methods don't multiply by the cofactor `h`, but some multiple `k h` for some small-ish `k` that is coprime to the order of the subgroup. This is germane because you will not get the same result if you clear the cofactor with\r\n\r\n    P_out = h * P\r\n\r\nvs\r\n\r\n    P_out = fast_cofactor_elimination(P)\r\n\r\n(For specific examples, see [Budroni and Pintore](https://eprint.iacr.org/2017/419)'s work on explicit constructions of fast endomorphisms for Barreto-Lynn-Scott curves based on the work of Scott et al. and Fuentes-Castaneda et al.)\r\n\r\nSo, it's slightly concerning if the standard specifies that the correct way to clear the cofactor is to multiply by exactly `h`, since in practice for G2 of a pairing-friendly curve this is going to be slow.",
          "createdAt": "2019-04-20T02:13:16Z",
          "updatedAt": "2019-04-20T02:54:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since this is handled in the suites with h_eff.",
          "createdAt": "2019-10-27T06:01:46Z",
          "updatedAt": "2019-10-27T06:01:46Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU0Mjg0MTY1Mzg=",
      "title": "BLS integration considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. For pairing-friendly curves, it might be helpful to have separate cipher\r\nsuites for G1 and G2.\r\n\r\n2. Indeed BLS12-381 is currently missing. For G1, the Fouque-Tibouchi\r\nmethod as written should already work. But for G2, you would need to extend\r\n5.3.5 to handle field extensions. Here\u2019s a pointer to the Chia\r\nimplementation which addresses both:\r\n\r\nhttps://github.com/Chia-Network/bls-signatures/blob/master/SPEC.md",
      "createdAt": "2019-04-02T20:03:08Z",
      "updatedAt": "2019-10-27T06:02:20Z",
      "closedAt": "2019-10-27T06:02:20Z",
      "comments": [
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "May I suggest the ciphersuite string \"H2C-BLS12_381_1-SHA512-FT-\" for hashing to G_1 in BLS12-381 using the Fouque-Tibouchi method with SHA-512?",
          "createdAt": "2019-04-16T19:26:00Z",
          "updatedAt": "2019-04-16T19:26:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. This is handled by Suites and the BLS draft.",
          "createdAt": "2019-10-27T06:02:20Z",
          "updatedAt": "2019-10-27T06:02:20Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU0MzI3ODE5MzU=",
      "title": "Update reference code quality",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/98",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This includes things like updating names, building a framework for testing the hash2curve implementations, and generating test vectors via a script.",
      "createdAt": "2019-04-12T23:44:35Z",
      "updatedAt": "2019-10-28T19:09:46Z",
      "closedAt": "2019-10-28T19:09:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as Nice to Have.",
          "createdAt": "2019-10-28T19:09:45Z",
          "updatedAt": "2019-10-28T19:09:45Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU0MzM1Mzk4MTM=",
      "title": "Define the amount of additional bits for hashing to Fp",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/99",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tracking: The main text is imprecise about the amount of bits required to reduce mod p from {0,1}^k to Fp.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2019-04-16T01:10:29Z",
      "updatedAt": "2019-06-05T14:56:46Z",
      "closedAt": "2019-06-05T14:56:46Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "@mmaker We will track here your derivation for hashing to Fp.",
          "createdAt": "2019-04-16T01:42:22Z",
          "updatedAt": "2019-04-16T01:42:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mmaker will you be able to transcribe your derivation into a PR, or should we take a crack at it?",
          "createdAt": "2019-05-19T01:04:15Z",
          "updatedAt": "2019-05-19T01:04:15Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "According to Brier et al. paper, we can include a line such as:\r\n\r\nIf k is the security parameter, and log2(p)=2k, then the hash function must output at least 3k bits to get 2^-k of statistical distance.\r\n\r\n",
          "createdAt": "2019-05-21T01:07:46Z",
          "updatedAt": "2019-05-21T01:07:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh That works, too!",
          "createdAt": "2019-05-21T16:41:15Z",
          "updatedAt": "2019-05-21T16:41:15Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "{{hash2base}} \"Security and performance considerations\" currently says more or less that. Not clear that it requires a cite since it's a pretty straightforward fact, but we could add one.\r\n\r\n> To control bias, the input msg should be hashed to an integer comprising more than log2(p) bits. In particular, reducing an integer of ceil(log2(p)) + k bits modulo p gives bias at most 2^-k, which is a safe choice for a cryptosystem with k-bit security.\r\n\r\nAlso note [thread 1](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r285818221) and [thread 2](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r285819630) from #104 about this.",
          "createdAt": "2019-05-21T21:10:45Z",
          "updatedAt": "2019-05-21T21:11:20Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One more thought on this:\r\n\r\nThe current version of hash2base (and also the updated version of #116 ) relies on H for two purposes:\r\n\r\n1. to hash the input message in a collision-resistant way, and\r\n2. as a pseudorandom generator.\r\n\r\nAssume that H outputs `b` bits, and that the curve being hashed to is part of a ciphersuite giving `k` bits of security.\r\n\r\nTo satisfy (1), we want `b >= 2 * k`, so that the birthday bound is around 2^-k bits.\r\n\r\nRequirement (2) can only be satisfied by assumption; certainly, modeling H as a random oracle is sufficient to satisfy this requirement. Avoiding assumptions of this kind is hard, for the same reason that we don't expect to be able to write down a proof that AES-128 gives 128-bit security.\r\n\r\nWhat's currently written in this section (only) partially captures (2), and I think in #104 @armfazh was keying on the fact that the text does not really deal with (1). To address this, I propose the following:\r\n\r\n- Include the requirement that H outputs `b >= 2 * k` bits, for collision resistance. This takes care of (1).\r\n\r\n- Make explicit that hash2base models H as a random oracle, and therefore H should be a battle-tested primitive.\r\n\r\nThe SHA-2 family is probably the most extensively studied option for H, so it might make sense for the standard to suggest its use. It may also be reasonable to recommend SHA-3 as an alternative.\r\n\r\n--\r\n\r\nA more complicated version of hash2base might separate the hash function used to compute `m'` from the PRG that expands `m'` into pseudorandom values. In that case, one might use (say) SHA256 as H and AES-128 as the PRG. I'm not strongly in favor of this, because it complicates implementations, but it would be a reasonable choice.",
          "createdAt": "2019-05-24T00:16:12Z",
          "updatedAt": "2019-05-24T00:16:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this issue is taken care of by the combination of #104 and #116: the document now specifies both the required number of bits for the output of H and the number of invocations of H in hash2base in terms of the security parameter.",
          "createdAt": "2019-06-03T22:36:08Z",
          "updatedAt": "2019-06-03T22:36:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, agreed. Closing due to #104 and #116, as well as implicit text suggesting H is a random oracle for hash2base.",
          "createdAt": "2019-06-05T14:56:46Z",
          "updatedAt": "2019-06-05T14:56:46Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU0MzUzNDc1MDA=",
      "title": "Fouque and Tibouchi method: relwork / attribution issue",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/100",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi folks,\r\n\r\nThanks for the hard and excellent work on this!\r\n\r\nThere are a couple small issues with the discussion of hashing to pairing-friendly curves.\r\n\r\n1. I notice in the current draft that the section discussing the work of Fouque and Tibouchi at Latincrypt 2012 does not correctly attribute the work. The FT12 paper is clear that the map the authors describe is an instantiation of the Shallue--van de Woestijne method, with constants selected in a way that is convenient for Barreto-Naehrig curves. So a cite of S--vdW (ANTS 2006) would probably be appropriate here.\r\n\r\n2. ~~It's probably important to point out in this section that the map is undefined when u = 0 and when u = sqrt(-1-B). The first case can happen for any curve. The second case can only happen when (-1-B) is square. For BN curves this will never be true, but for BLS curves is can and likely will be. (As a specific example, -1-B is square for BLS12-381, so the map as described is undefined at +/-sqrt(-5).)~~\r\n\r\n~~In fact, the second comment might be true more generally. A brief search of the document doesn't turn up any instances discussing what to do if/when the map is undefined. This is probably important, since in practice many of these maps will have some undefined inputs, and it would be unfortunate if different implementations diverged in their behavior.~~\r\n\r\n~~Since the document appears to be encouraging constant-time implementations, it's not clear that there's a good blanket recommendation that would apply to every map. So it might be useful to think about how to handle undefined behavior on a map-by-map basis, in a way that is amenable to constant-time implementations. I'm happy to help out with this.~~",
      "createdAt": "2019-04-20T02:35:19Z",
      "updatedAt": "2019-05-21T21:38:04Z",
      "closedAt": "2019-05-21T21:38:04Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I moved the undefined cases question to its own issue #103",
          "createdAt": "2019-04-26T20:31:58Z",
          "updatedAt": "2019-04-26T20:31:58Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU0MzU5MTQ3Mzc=",
      "title": "New BLS hash2curve algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/101",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://eprint.iacr.org/2019/403",
      "createdAt": "2019-04-22T22:15:54Z",
      "updatedAt": "2019-06-02T21:26:13Z",
      "closedAt": "2019-06-02T21:26:13Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 closed this. Looks like I forgot to note that in the commit messages there. Sorry about that.",
          "createdAt": "2019-06-02T21:09:47Z",
          "updatedAt": "2019-06-02T21:09:47Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU0Mzc4MzE1NTc=",
      "title": "suggestion: remove (non-\"simplified\") Shallue--van de Woestijne--Ulas algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/102",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi folks,\r\n\r\nI think there is no reason to suggest in the standard that implementors use non-\"simplified\" SWU (i.e., the one from Ulas 2007). The non-simplified version is less efficient than simplified one and is no more general (i.e., it doesn't apply to any curves that simplified doesn't).\r\n\r\nNote: the second half of the above claim is maybe not totally obvious, but in [our recent work](https://eprint.iacr.org/2019/403) we show a very simple way to extend simplified SWU to curves over fields of any characteristic (not just Fp, p = 3 mod 4).",
      "createdAt": "2019-04-26T20:21:49Z",
      "updatedAt": "2019-05-21T21:38:04Z",
      "closedAt": "2019-05-21T21:38:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The non-simplified version is less efficient than simplified one and is no more general (i.e., it doesn't apply to any curves that simplified doesn't).\r\n\r\nI thought the simplified version only applied to curves where `q = 3 mod 4`, whereas this condition was not applicable for the non-simplified version. Is this not true? If it is true, is the claim that there are no curves where `q \\neq 3 mod 4`?",
          "createdAt": "2019-05-19T01:03:06Z",
          "updatedAt": "2019-05-19T01:03:06Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Our [recent eprint (\u00a74.1)](https://bls-hash.crypto.fyi) shows how to extend the simplified version to p != 3 mod 4. It's just a tiny tweak. I rolled this into the omnibus PR (that's the `\\xi` constant).",
          "createdAt": "2019-05-19T02:17:46Z",
          "updatedAt": "2019-05-19T02:17:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I missed that -- thank you!",
          "createdAt": "2019-05-20T15:23:30Z",
          "updatedAt": "2019-05-20T15:23:30Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU0Mzc4MzQ3MTY=",
      "title": "handling undefined cases for maps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/103",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(moved here from #100)\r\n\r\nA brief search of the document doesn't turn up any instances discussing what to do if/when the map is undefined. This is probably important, since in practice many of these maps will have some undefined inputs, and it would be unfortunate if different implementations diverged in their behavior.\r\n\r\nSince the document appears to be encouraging constant-time implementations, it's not clear that there's a good blanket recommendation that would apply to every map. So it might be useful to think about how to handle undefined behavior on a map-by-map basis, in a way that is amenable to constant-time implementations. I'm happy to help out with this.",
      "createdAt": "2019-04-26T20:31:19Z",
      "updatedAt": "2019-06-02T21:08:41Z",
      "closedAt": "2019-06-02T21:08:41Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 closes this.",
          "createdAt": "2019-06-02T21:08:41Z",
          "updatedAt": "2019-06-02T21:08:41Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU0NDU3ODA0NTQ=",
      "title": "style nits: spacing around math operators",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/105",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In a previous commit I tried to improve consistency for spacing around math operators, but I didn't quite catch them all.\r\n\r\n~~I think the biggest remaining one is whether `=` should have surrounding spaces or not.~~ done (#136)\r\n\r\nTODO: implement consistent style",
      "createdAt": "2019-05-19T04:58:33Z",
      "updatedAt": "2019-10-27T02:46:15Z",
      "closedAt": "2019-10-27T02:46:15Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Generalizing to spacing: also need to decide about \"Elligator 2\" (as written in the Elligator paper) vs. Elligator2 (no space).",
          "createdAt": "2019-05-21T18:18:32Z",
          "updatedAt": "2019-05-21T18:18:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: decide whether to use `=` or `==`",
          "createdAt": "2019-06-02T18:09:16Z",
          "updatedAt": "2019-06-02T18:09:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my $0.02:\r\n\r\n- Yes, include spaces around `=`.\r\n- Use `==` for equality statements, i.e., \"if `x == 2`\", and reserve `=` for variable assignment only.\r\n- Write as Elligator2, despite its deviation from the paper.\r\n\r\n@armfazh, what do you think?",
          "createdAt": "2019-06-05T15:05:11Z",
          "updatedAt": "2019-06-05T15:05:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood are we good to close this, then?",
          "createdAt": "2019-10-27T02:26:25Z",
          "updatedAt": "2019-10-27T02:26:25Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU0NDU3ODA2ODg=",
      "title": "sqrt: split by field characteristic",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/106",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood suggested splitting the sqrt description into three separate cases:\r\n\r\n> Perhaps we should re-write this section as a series of algorithms for the different conditions? That might help ease implementation should people choose to use one of them.\r\n\r\n_Originally posted by @chris-wood in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104_",
      "createdAt": "2019-05-19T05:03:39Z",
      "updatedAt": "2019-05-31T17:12:51Z",
      "closedAt": "2019-05-31T17:12:51Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU0NDU3ODA4NzE=",
      "title": "discuss point conversions (perhaps in appendix)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/107",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood suggested:\r\n\r\n> Should we generalize the Montgomery->Edwards point conversion function? (I would have benefited from such a function being written in cleartext *somewhere* earlier this year.) We might then also include conversion from, say, Weierstrass to Montgomery, among others.\r\n\r\n_Originally posted by @chris-wood in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104_",
      "createdAt": "2019-05-19T05:07:35Z",
      "updatedAt": "2019-10-27T03:06:16Z",
      "closedAt": "2019-10-27T03:06:16Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to this: in an offline conversation, @reyzin pointed out that the Montgomery->Edwards conversions as currently specified don't quite match up with the ones in RFC 7748. Specifically, in the case of Ed25519 this document's values for A and B give a curve isomorphic to the curve in 4.1 of that RFC. Either is *correct*, but it would be best to be consistent with that document.\r\n\r\nI've got a TODO to figure out a good way of handling this, and probably this issue should also comprehend that.",
          "createdAt": "2019-05-19T05:12:36Z",
          "updatedAt": "2019-05-19T05:12:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since I consider this resolved.",
          "createdAt": "2019-10-27T03:06:16Z",
          "updatedAt": "2019-10-27T03:06:16Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU0NDU3ODE5Mjk=",
      "title": "sgn0: make impl in poc/ match description in document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/108",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The version of sgn0 in common.sage does the same thing as the description in the document, but is probably more confusing than necessary.\r\n\r\nTODO: rewrite to match impl from the document",
      "createdAt": "2019-05-19T05:26:30Z",
      "updatedAt": "2019-06-03T20:53:30Z",
      "closedAt": "2019-06-03T20:53:30Z",
      "comments": []
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU0NDU3ODI5MzE=",
      "title": "possible enhancement: mapping to projective coordinates everywhere",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/109",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most of the maps can be made faster by dealing in projective rather than affine coordinates, since this should suffice to eliminate inversions (maybe with one more trick here and there).\r\n\r\nIf the goal is to suggest nicely optimized implementations everywhere, one possibility is to allow all map definitions to give projective outputs and then separately handle conversion back to affine coordinates.\r\n\r\nMapping to a projective point and then clearing the denominator is just as fast as mapping directly to an affine coordinate. In most cases, it's faster end-to-end: if the higher-level application does further operations on the output of the map, it's safe to assume those operations will be over projective coordinates, in which case converting to affine coordinates first is unnecessary and strictly slower.\r\n\r\nThis probably requires a small discussion (appx? elsewhere?) about projective coordinates, conversions, etc. Happy to take a crack at this.",
      "createdAt": "2019-05-19T05:41:29Z",
      "updatedAt": "2019-10-27T03:04:43Z",
      "closedAt": "2019-10-27T03:04:43Z",
      "comments": []
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU0NDY3NTc1MDg=",
      "title": "style nits: variable naming",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/110",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "@armfazh prefers short variable names (per comments in #104).\r\n\r\n@chris-wood observed that there are some inconsistencies in naming, e.g., `msg` vs `alpha`.\r\n\r\nMy changes in #104 were aimed at avoiding overloaded symbols.\r\n\r\nI think it's possible to resolve all of these simultaneously, with some thought. Let's discuss what the names should be (short? descriptive? `msg`? `alpha`? `x`?), write down a \"style guide,\" and update the document to follow it.",
      "createdAt": "2019-05-21T18:16:42Z",
      "updatedAt": "2020-03-03T18:58:53Z",
      "closedAt": "2020-03-03T18:58:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~TODO: the \"Try-and-Increment Method\" appendix has some overloading of the variable `h`~~\r\n\r\nremoved by #122",
          "createdAt": "2019-05-21T18:41:39Z",
          "updatedAt": "2019-06-05T18:01:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~spell out \"to\" rather than number 2 everywhere?~~\r\n\r\n~~hash2field/hash_to_field vs hash2base vs hash_to_base_field, etc.~~\r\n\r\ntaken care of by #130",
          "createdAt": "2019-06-05T16:23:39Z",
          "updatedAt": "2019-06-27T20:01:51Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`_to_` rather than `2` improves readability.",
          "createdAt": "2019-06-05T16:32:24Z",
          "updatedAt": "2019-06-05T16:32:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this now.",
          "createdAt": "2020-03-03T18:58:53Z",
          "updatedAt": "2020-03-03T18:58:53Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU0NDY3NzgxMjY=",
      "title": "optimized straight-line implementations: generic or specific?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/111",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now the document gives straight-line procedures for evaluating each map, which seem to be aimed at being general purpose.\r\n\r\nWe've discussed in #104 an alternative approach in which these straight-line implementations are geared toward *specific* curves (e.g., standardized and widely-used curves). This would likely be more useful for implementors, both because they would be able to port these directly (rather than having to understand and adapt the generic procedures) and because it would allow us to roll in more optimizations.\r\n\r\nThe `poc/` directory gives us a good start on the list of curves that should be supported in this way. I'm happy to propose a list of curves and write down optimized straight-line implementations for each.",
      "createdAt": "2019-05-21T19:08:06Z",
      "updatedAt": "2019-10-27T06:13:21Z",
      "closedAt": "2019-10-27T06:13:21Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: if the decision is to target specific rather than generic curves, make sure to cover cofactor clearing in each curve's implementation\r\n\r\n[see conversation from 104](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r282707881)",
          "createdAt": "2019-05-21T19:09:14Z",
          "updatedAt": "2019-05-21T21:06:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Probably #109 gets resolved by this decision, too.",
          "createdAt": "2019-05-21T19:42:40Z",
          "updatedAt": "2019-05-21T19:42:40Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh [notes](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r286204135):\r\n\r\n> There is a section that is missing to be written, which is the instantiations of suites. In such a section, draft must specify all the parameters for a given curve. For example, the suite correspondent to BLS12-381 will state which isogeny was used and all other relevant parameters.\r\n\r\nTODO: make sure this is covered\r\n\r\nNote that commit fe7df96 removes text about finding isogenies. Can bring back if required.",
          "createdAt": "2019-05-21T20:56:53Z",
          "updatedAt": "2019-05-21T21:03:40Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "discussion with @chris-wood:\r\n\r\nintroduce new appx, \"curve-specific impls\". For each of a list of well-known curves, provide a highly optimized implementation of the recommended map for that curve.\r\n\r\nReason: This encourages implementors to use the \"right\" map for common curves, and gives them a nice implementation.",
          "createdAt": "2019-06-05T16:52:20Z",
          "updatedAt": "2019-06-05T16:52:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am agree that there are lots of implementation tricks that can be used for implementing the suites. (number theoretic tricks, projective coordinates, isogenies, birational mappins,)\r\nAs a developer I would be happy to have all of these resources off-the-shelf.\r\n\r\nHowever, I think #126 is a dependency that must be solved first.\r\nBesides of what is pointed there, another concern is about the length of the document. \r\nSimplicity is an aspect to consider too. A concise and simple description of the mappings together with compatible test vectors should be enough.\r\n\r\nA MITM suggestion is to write a complete set of optimizations in a second document that we can post publicly on eprint and arXiv targeting developers.\r\n",
          "createdAt": "2019-06-13T09:58:40Z",
          "updatedAt": "2019-06-13T10:26:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "stashing a note from [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127#discussion_r297413871): check forward refs from mapping descriptions to example code, and be systematic (one way or another) about listing curves to which an encoding applies.",
          "createdAt": "2019-06-26T06:44:02Z",
          "updatedAt": "2019-06-26T06:44:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The decision was to keep body text generic and make optimized appendices.\r\n\r\nSeparately, we still need to add more optimized impls to the appx. I've created #181 to capture that.",
          "createdAt": "2019-10-27T06:13:21Z",
          "updatedAt": "2019-10-27T06:13:21Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU0NDY3OTY4NjM=",
      "title": "meta-issue: implementation cleanup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/112",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Moving these from #104.\r\n\r\n- [x] consider removing unused implementations (e.g., ell2edwards, fouquetibouchi)\r\n\r\n- [ ] update test vectors\r\n\r\n- [x] ~~update hacspec implementations to cover new encodings~~ remove hacspec for now (can bring back later if necessary)\r\n\r\n- [x] clear cofactors to match the document\r\n\r\n- [x] edwards448: use 4-isogeny from RFC7748 rather than current rational map\r\n\r\n- [x] #117 --- make sure to use CMOV in straight-line impls",
      "createdAt": "2019-05-21T19:55:18Z",
      "updatedAt": "2020-03-03T18:58:36Z",
      "closedAt": "2020-03-03T18:58:35Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: the edwards448 impl doesn't use the 4-isogeny from RFC7748. Fix this.",
          "createdAt": "2019-06-28T01:02:37Z",
          "updatedAt": "2019-06-28T01:02:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I kind of like the generic approach in `poc/svdw_new.sage`, which effectively copies the two generic impls from the text and tests that they give the same value, etc. My vote would be to do one such impl for each map, and use those impls to generate test vectors. We can also test the curve-specific code from the appendices against these generic impls.\r\n\r\nHappy to push this forward once we're done with Singapore prep.",
          "createdAt": "2019-10-27T06:17:42Z",
          "updatedAt": "2019-10-27T06:17:42Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've ticked the above boxes based on #188. From my perspective, all that remains is updating test vectors.",
          "createdAt": "2019-11-05T07:24:51Z",
          "updatedAt": "2019-11-05T07:24:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Closing and duping to #216, which tracks test vectors.",
          "createdAt": "2020-03-03T18:58:35Z",
          "updatedAt": "2020-03-03T18:58:35Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU0NDY3OTc4NTE=",
      "title": "related work: points as bitstrings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/113",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Moved from #104 \r\n\r\n- [x] Consider mentioning related work on points-as-bitstrings (Elligator, Elligator Squared, Binary Elligator Squared)",
      "createdAt": "2019-05-21T19:57:52Z",
      "updatedAt": "2019-06-04T21:16:53Z",
      "closedAt": "2019-06-04T21:16:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "see #122",
          "createdAt": "2019-06-04T01:03:44Z",
          "updatedAt": "2019-06-04T01:03:44Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU0NDg1NjcyOTI=",
      "title": "Use cmov-like instructions instead of brancing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/117",
      "state": "CLOSED",
      "author": "vanhoefm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In some parts, examples use branching statements instead of cmov-like instructions. Examples of this are in the hacspec code: https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#simplified-swu-method-sswu\r\n\r\nIt is better to use cmov-like instructions everywhere, to avoid developers from using conditional branches in their code (which possibly will lead to side-channel attacks).",
      "createdAt": "2019-05-26T13:28:36Z",
      "updatedAt": "2019-10-24T19:54:27Z",
      "closedAt": "2019-10-24T19:54:27Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "You're totally right. Note that the sample code is out of date at this point. I'm hoping to address that, which should comprehend both this issue and #112, in the not-too-distant future.",
          "createdAt": "2019-06-02T21:12:38Z",
          "updatedAt": "2019-06-02T21:12:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is comprehended in #112, so I'm closing.",
          "createdAt": "2019-10-24T19:54:27Z",
          "updatedAt": "2019-10-24T19:54:27Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU0NTE2ODAxOTM=",
      "title": "ROM order of operations: clear cofactor after point addition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/120",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current descriptions of the maps include cofactor clearing. In the ROM case this is not good: ofactor clearing is potentially an expensive operation, and it commutes with point addition.\r\n\r\nTODO: the standard should be written in a way that makes clear that the cofactor clearing operation happens *after* point addition in the ROM case.\r\n\r\n#118 and #119 should probably handle this issue.",
      "createdAt": "2019-06-03T20:42:26Z",
      "updatedAt": "2019-06-18T19:58:44Z",
      "closedAt": "2019-06-18T19:58:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this once #118 and #119 land.",
          "createdAt": "2019-06-05T15:07:58Z",
          "updatedAt": "2019-06-05T15:07:58Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> We can close this once #118 and #119 land.\r\n\r\n#121 is the unique dependence.\r\n",
          "createdAt": "2019-06-13T09:33:59Z",
          "updatedAt": "2019-06-13T09:33:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #121. ",
          "createdAt": "2019-06-18T19:58:43Z",
          "updatedAt": "2019-06-18T19:58:43Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU0NTI4NTIyNDE=",
      "title": "ciphersuites and domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Chris and I discussed the issue of ciphersuites and domain separation in hash-to-curve. Put concisely, the question is, should hash-to-curve provide domain separation among the suites, or should domain separation be left to the upper-level protocol? We decided that the best way to proceed is to get feedback from the CFRG list by coming up with and sending two specific proposals along with a discussion of pros and cons.\r\n\r\nFrom chatting with the BLS and VRF folks, my impression is that they prefer to keep ciphersuites out of hash-to-curve. Their argument is (paraphrasing), the upper-level protocol needs to ensure domain separation, so what's the point of doing it redundantly in hash-to-curve? There was also serious concern about variable-length ciphersuite strings (currently used in the poc impls but not specified in the document), because that is a potential source of confusion and bugs. [Right now](https://github.com/pairingwg/bls_standard/blob/master/minutes/spec-v1.md), the BLS sigs standard is proceeding with no ciphersuite in hash-to-curve, only in the BLS signature itself.\r\n\r\nBut there may be room to meet in the middle. For example, it would be essentially free to add a short, fixed-length ciphersuite (say, <20 bytes) in hash2base. It might be worth running this by the BLS and VRF folks before we go to the list, to hear out the likely objectors first and see if we can get buy-in.\r\n\r\nConcretely, I propose that we consider the following two options.\r\n\r\n#### option 1: no ciphersuite\r\n\r\nThis preserves the current version of hash2base as specified in the document. The important line is the one in which msg gets hashed. In the current version, that's\r\n\r\n```\r\nm' = H(msg) || I2OSP(ctr, 1)\r\n```\r\n\r\n#### option 2: fixed string + 4-byte ciphersuite in hash2base\r\n\r\n```\r\nm' = H(\"HASH-TO-CURVE\" || ciphersuite || msg) || I2OSP(ctr, 1)\r\n```\r\n\r\nEDIT: or, maybe slightly preferable so that \"prehash-for-free\" still works:\r\n\r\n```\r\nm' = \"HASH-TO-CURVE\" || ciphersuite || H(msg) || I2OSP(ctr, 1)\r\n```\r\n\r\nEDIT 2: I think it's safe to assume that \"ciphersuite\" here would be generated following something like the procedure in [this comment, below](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507069455). This avoids issues with ciphersuites for curves not discussed in the spec document.\r\n\r\nNote that the string \"HASH-TO-CURVE\" ensures domain separation even from other protocols that use a 4-byte ciphersuite tag. It might be nice for protocols to adopt this approach more genreally.\r\n\r\n(Actually, I kind of like the idea of using the RFC number (e.g., \"RFC1234\" for RFC 1234's domain separation string), but that has the downside that the protocol's test vectors can't be finalized until the RFC number is assigned.)\r\n\r\nThoughts on the above two proposals? Any other issues we should consider?",
      "createdAt": "2019-06-06T06:23:51Z",
      "updatedAt": "2019-10-27T06:07:27Z",
      "closedAt": "2019-10-27T06:07:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we assume a fixed-length value for the cipher suite, e.g., a 2 or 4 byte value that maps to a ciphersuite and is maintained by a registry, I think I'm more comfortable with option 2. While it may be redundant, it seems as though it would help prevent possible misuse or failure to add domain separation by the calling code or protocol. @armfazh @grittygrease @samscott89, please chime in!",
          "createdAt": "2019-06-06T16:27:59Z",
          "updatedAt": "2019-06-06T16:27:59Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I will go for not including domain separation inside the definition of the suite.\r\n\r\nHash-to-curve functions must be as generic as possible. Note that the interface receives a string of opaque bytes. \r\nThen, the job of the caller is to produce a meaningful string according to him/her purposes. As a consequence, providing or not a domain separation string must be decided by the top-level protocol.\r\n\r\nI also consider, the document must provide recommendations about the usage of the suites, providing advise on the cases where domain separation is necessary.\r\n\r\nI might not be considering all the scenarios, feedback is appreciated.",
          "createdAt": "2019-06-13T10:16:24Z",
          "updatedAt": "2019-06-13T10:16:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As a point of comparison, HPKE [1] bakes the cipher suite into the context string used inside the Seal and Open functions. I'm not sure doing something similar here, with a fixed-length suite, would negatively impact generality, especially since the ciphersuite already uniquely determines the set of algorithms used to construct `hash_to_curve`. In other words, including the suite provides further separation between `hash_to_curve` implementations based on different ciphersuites. \r\n\r\n[1] https://tools.ietf.org/html/draft-barnes-cfrg-hpke-00#section-5.1",
          "createdAt": "2019-06-13T15:39:25Z",
          "updatedAt": "2019-06-13T15:39:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought about this a bit more over the past few days, and I tend to think that domain separation in hash-to-curve will not do much for security in practice; I explain below. But as @chris-wood says, if it doesn't hurt performance or generality, I'd tend to err on the side of caution, with two caveats. First, if we include domain separation, we should also do as @armfazh suggests and add either language or a citation that recommends domain separation strings in upper-level protocols; otherwise, the worry is that we'd give users the incorrect impression that domain separation at the protocol level was unnecessary. Second, we need to make sure we have an interop story for curves that are not in the \"official\" ciphersuite table; see my comment immediately below.\r\n\r\n(Come to think of it: are there any CFRG guidelines or informational documnents that talk about domain separation? Should there be? It might be nice if there were a uniform way of doing domain separation, and if every CFRG protocol just did it that way.)\r\n\r\nOK, why should we think it won't do much? Recall that one reason to use domain separation is to make sure that random oracle security proofs still hold when protocols are composed---in particular, that composition doesn't break the freshness of random oracle queries. Concretely, if protocol A's security proof relies on making a fresh random oracle query on input X, and an attacker can force composed protocol B to make a query on input X first, the security of the composition may be broken.\r\n\r\nNow, let's think about a scenario where we're composing two protocols that both use hash-to-curve, and in which neither protocol uses domain separation strings. In this case, whether or not domain separation at the hash-to-curve level helps depends on whether or not the two protocols use the same hash-to-curve suite. Specifically, if the two protocols use different curves, h2c domain separation would help them. But if they use the same curve and h2c suite, it wouldn't.\r\n\r\nSo: if we think that composed protocols would end up using the same suite in almost all cases, then we should probably conclude that h2c domain separation won't do much. My inclination is to believe that implementors will prefer to use a single hash-to-curve codebase, i.e., that they'll actively try to use a common suite when composing protocols---which defeats the h2c domain separation.\r\n\r\nBut like I said, if adding separation is really free, then maybe there's no reason not to do it...",
          "createdAt": "2019-06-13T17:43:25Z",
          "updatedAt": "2019-06-19T21:56:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "On the question of whether h2c is really free, I have a concern: if domain separation includes an opaque ciphersuite ID from a table, there is the possibility that interop will be broken for curves/suites that aren't in the table.\r\n\r\nI think this qualifies as a real downside, and it's something we have to think carefully about if we include suite IDs in hash2base.\r\n\r\nAlong these lines, if we're going to have a ciphersuite table in the RFC, how and when does that table get updated with new suites? Would it make sense to run an informal registry of not-yet-standardized suites, e.g., on GitHub? (I see this ties into #126)",
          "createdAt": "2019-06-13T17:49:47Z",
          "updatedAt": "2019-06-13T17:53:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Come to think of it: are there any CFRG guidelines or informational documnents that talk about domain separation? Should there be? It might be nice if there were a uniform way of doing domain separation, and if every CFRG protocol just did it that way.\r\n\r\nInteresting idea! At the very least, it seems like something worth discussing in Montreal. Shall we put down something in writing?",
          "createdAt": "2019-06-13T19:32:43Z",
          "updatedAt": "2019-06-13T19:32:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Interesting idea! At the very least, it seems like something worth discussing in Montreal. Shall we put down something in writing?\r\n\r\nOh, good idea! Let me think a bit about this. (But: is it reasonable to assume that the in-writing bit is lower priority than getting this draft updated?)",
          "createdAt": "2019-06-13T23:54:51Z",
          "updatedAt": "2019-06-13T23:54:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  is it reasonable to assume that the in-writing bit is lower priority than getting this draft updated?\r\n\r\nAbsolutely!",
          "createdAt": "2019-06-14T12:46:05Z",
          "updatedAt": "2019-06-14T12:46:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking about this for a few more days, I still don't see a clear path to a good interop story for curves that aren't enumerated in the document. Because of that, I'm worried that adding a ciphersuite tag will hurt the interop story for hash-to-curve without a compensating improvement in security (for reasons given in my prior comments).\r\n\r\nSo: I think my preference is tending towards adding language that encourages upper-level protocols to add domain separation, but not to add it in hash-to-curve.\r\n\r\nI've asked the BLS and VRF standards authors for their thoughts; I'm hopeful that they'll come and add comments to this issue.",
          "createdAt": "2019-06-19T22:01:05Z",
          "updatedAt": "2019-06-19T22:01:05Z"
        },
        {
          "author": "reyzin",
          "authorAssociation": "NONE",
          "body": "I tend to agree with @kwantam. The security benefits of domain separation at the hash-to-curve level are unclear to me, but the logistical drawbacks are. If you add ciphersuites to this draft and someone wants to use hash-to-curve with a new hash function or a new curve, they would have to figure out the IETF process for adding a new ciphersuite to this standard, in addition to whatever other standardization and implementation efforts they are already undertaking. Increasing logistical barriers means some people just won't bother and will choose their own options, ignoring this process.\r\n\r\nI think the value of hash-to-curve draft is that it covers a broad range of use cases, hash functions, base fields, and curves. Adding ciphersuites will reduce this value.\r\n\r\nAlso, adding ciphersuties will make existing implementations already deployed in the wild (such as implementations of the [VRF draft](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/)) incompatible.",
          "createdAt": "2019-06-20T18:31:34Z",
          "updatedAt": "2019-06-20T18:31:34Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "I also tend to agree with both @kwantam and @reyzin, namely that ciphersuite and domain separation should be provided/enforced by the high-level application.\r\n\r\nHere's a slightly different take on the issue: do we expect a ciphersuite string in hash-to-curve to contain any additional information that's not already in the ciphersuite string for the high-level application (e.g. BLS signatures)? To me, that shouldn't be, because the latter should completely determine which hash-to-curve algorithm will be used. If so, I don't see any advantage to having the same information appear twice; if anything, there's only disadvantages, namely aesthetics, and as @reyzin pointed out, logistic drawbacks to maintaining consistency.\r\n\r\nSide note / clarification: I think it'd still be useful for hash-to-curve to specify a table of ciphersuite strings (which will be referred to by the higher-level applications), but the ciphersuite string should not be part of the input to hash2base.",
          "createdAt": "2019-06-21T04:35:59Z",
          "updatedAt": "2019-06-21T04:35:59Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "The arguments put forth here seem reasonable. Trying not to overthink it, but there are 4 scenarios, where you have the application author and library author are different people, each of whom can either use domain separation or not.\r\n\r\n1. Domain separation in both -> redundant info, and logistical drawbacks\r\n2. App does separation, not library (as suggested here) -> all good!\r\n3. App does not do separation, neither does library (app author is not following RFC properly) -> potential cross-protocol attacks\r\n4. App does not do separation, but library does (app author not following RFC, but library author follows our alternative, i.e. what we previously had) -> Perhaps cannot mount some attack against swapping out curves, but still potentially can do cross-protocol against app usage elsewhere?\r\n\r\nThe point being, the difference between 3 and 4 doesn't seem particularly meaningful, but the gap between 1 and 2 does. Unless there's a convincing reason why 4 is a bad situation.\r\n\r\nThe reason I think this is an important distinction, is the number of implementations of h2c should be much fewer than the numbers of implementations of applications.\r\n",
          "createdAt": "2019-06-21T15:33:52Z",
          "updatedAt": "2019-06-21T15:33:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The point being, the difference between 3 and 4 doesn't seem particularly meaningful, but the gap between 1 and 2 does. Unless there's a convincing reason why 4 is a bad situation.\r\n\r\nIMO this is the crucial bit. I don\u2019t think we can assume applications will add domain separation, even if we say they MUST do so. That seems to imply that we\u2019re left considering the pros and cons of 1+4 (library does it) versus 2+3 (library doesn\u2019t do it). \r\n\r\nWhat\u2019s more troubling is that while I agree with all of the downsides, from logistical nightmares to additional complexity and less re-use, the upsides are not well understood. That is, we have some concerns about possible cross-protocol attacks if h2c doesn\u2019t perform domain separation. (Perhaps these are silly and not well founded \u2014 I\u2019m not an expert here.) I think some more rigor would help make the decision easier. And it\u2019s probably time to take this issue to the list for wider discussion. :-)",
          "createdAt": "2019-06-21T17:36:44Z",
          "updatedAt": "2019-06-21T17:36:44Z"
        },
        {
          "author": "reyzin",
          "authorAssociation": "NONE",
          "body": "@chris-wood you are right, we should consider potential upsides. Here are the upsides as I understand them. The main value of domain separation that I know is if the same secret key is used in multiple different schemes. In that case, domain separation may (but won't always!) help a security proof for the joint security of these schemes to go through, because at least random oracle queries of the two schemes will not overlap, so whatever arguments required fresh randomness / programmability are more likely to still go through.\r\n\r\nI have not seen a convincing case for domain separation besides the above scenario.\r\n\r\nBut in general using the same SK for multiple purposes requires a thorough analysis, and simply putting in domain separation is insufficient. Moreover, domain separation only at the level of hash-to-curve is even less likely to be sufficient, because it will not necessarily ensure domain separation in the upstream apps -- esp. if the apps are using the same curve.\r\n\r\nBasically, app-level domain separation is where you would get the upsides. The chances of the upsides coming from domain separation in hash-to-curve are low, because if people are using the same SK for different schemes, they are likely using the same curve, too.",
          "createdAt": "2019-06-21T18:28:16Z",
          "updatedAt": "2019-06-21T18:28:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another issue that came up in discussing #132: if hash-to-curve injects a ciphersuite string, and assuming that (say) curve25519 and edwards25519 have different ciphersuites, then these two hash functions won't be compatible. It would probably be nicer if hash-to-curve25519 and hash-to-edwards25519 gave points that are equivalent via the birational map specified in RFC7748.",
          "createdAt": "2019-06-28T00:33:51Z",
          "updatedAt": "2019-06-28T00:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@reyzin I concur :-) and I don't have a convincing case to deliver. I was simply advocating for weighing the options. It seems most folks (at least here on GitHub) are in favor of pushing the burden of domain separation to hash-to-curve callers, which is probably fine. Minimally, we should add some text describing why we find this tradeoff acceptable, if we go down that route. ",
          "createdAt": "2019-06-28T04:59:12Z",
          "updatedAt": "2019-06-28T04:59:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I was chatting with @henrycg about this last night, and he pointed out something that's perhaps a second-order concern, but certainly worth writing down: a case where h2c domain separation would *potentially* be useful is when a single protocol makes queries to two distinct hash-to-curve oracles, and relies on those queries being uncorrelated.\r\n\r\n(Note that this is a case where we expect that a protocol's ciphersuite string is *not* sufficient to give domain separation, which answers @hoeteck's question above in a perhaps unexpected way.)\r\n\r\nOur discussion was in the context of a contrived example of a protocol that hashes to both Curve25519 and P-256, but I think there's a much more natural one. Consider a protocol (vaguely reminiscent of the one by [Muller](https://link.springer.com/chapter/10.1007/978-3-540-30108-0_21)) that uses points on both an elliptic curve and on its quadratic twist. Suppose that this hypothetical protocol relies on hashing to both the curve and its twist, and models these two hash functions as independent random oracles.\r\n\r\nIn this case, simply following the hash-to-curve document would *not* yield independent random oracles. Since the curve and its twist by definition reside in the same base field, the hash_to_base function for both curves will make exactly the same calls to H (say, SHA256), and will return exactly the same value. Now it's not at all obvious that the two oracles are uncorrelated!\r\n\r\nTo be clear, I don't know of any protocol like the above. But you could certainly imagine that a reader of the current hash-to-curve draft who is trying to implement such a protocol might incorrectly assume that hashes to two different curves can be treated as orthogonal random oracles!\r\n\r\nThere are a couple possible remedies here:\r\n\r\n1. In the forthcoming section of the document that discusses domain separation, make clear that different hash functions *cannot* be treated as orthogonal random oracles, and upper-level protocols that hash to multiple curves must add domain separation between those curves.\r\n\r\n2. Reconsider the ciphersuite question, again! @henrycg and I discussed a method for coming up with domain separation tags that might work. I'll specify it in a separate comment.",
          "createdAt": "2019-06-30T20:52:52Z",
          "updatedAt": "2019-06-30T22:03:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing the practical concerns with adding a domain separation tag to hash-to-curve, the primary concerns are\r\n\r\n1. How can someone derive a conforming ciphersuite tag for a curve that's not specified in the document, and\r\n\r\n2. How can we give the very nice property that (for example) hash-to-curve25519 and hash-to-edwards25519 return equivalent points? More generally, we'd like it to be the case that isogenous curves have equivalent hash functions, in the sense that hashing any string s to isogenous curves E and E' returns points that are related by the isogeny map.\r\n\r\nHandling (1), at a high level, requires us to specify some deterministic algorithm to compute a ciphersuite tag given the parameters of an elliptic curve. Handling (2) is slightly trickier, but it appears to be possible. Here's how:\r\n\r\nIt is a theorem (due to Tate) that any two curves over a field F having the same number of points are isogenous. (In fact, the implication goes both ways; the other direction is obvious by the definition of an isogeny.) Thus, the algorithm that is used to derive a ciphersuite tag will give equivalent outputs for isogenous curves in the case that the input to the algorithm is F, the field, and n, the order of the elliptic curve group. Here is a candidate such algorithm:\r\n\r\n```\r\nciphersuite_id(F, n, W, H)\r\n\r\nInputs:\r\n- F, a field (extension) parameterized by p and m, such that F = GF(p^m)\r\n- n, the cardinality of the group of rational points on E over F\r\n- W, the parameter from hash_to_base\r\n- H, the hash function from hash_to_base\r\n\r\nOutput: csid, a 4-byte ciphersuite ID string\r\n\r\nSteps:\r\n1.    L1 = ceiling(log_base_256(p))    // i.e., # of bytes necessary to represent p\r\n2.    L2 = ceiling(log_base_256(n))    // i.e., # of bytes necessary to represent n\r\n3.     L = max(L1, L2)\r\n4. L_str = I2OSP(L, 4)\r\n5. W_str = I2OSP(W, 4)\r\n6. m_str = I2OSP(m, 4)\r\n7. p_str = I2OSP(p, L)\r\n8. n_str = I2OSP(n, L)\r\n9. c_pre = H(L_str || W_str || m_str || p_str || n_str)\r\n10. return c_pre[0:4]                  // i.e., the first 4 bytes of c_pre\r\n```\r\n\r\nThis 4-byte tag would be used as described in option 2 in the 1st message of this thread:\r\n\r\n    m' = \"HASH-TO-CURVE\" || csid || H(msg) || I2OSP(ctr, 1)\r\n\r\nNote that for a given curve, csid is fixed for all time, so it can just be a hard-coded constant. There's no need to evaluate the ciphersuite_id function at runtime.\r\n\r\nTo be clear: I'm not sure yet whether I'm in favor of this or not. But at least this clears away some of the deployment / pragmatic concerns with using ciphersuites and lets us focus on whether or not this is desirable strictly from a security perspective.",
          "createdAt": "2019-06-30T21:35:11Z",
          "updatedAt": "2019-07-02T19:33:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The above proposal, while perhaps an improvement, is by no means perfect. Here are some concerns that I can think of, off the top of my head:\r\n\r\n1. It doesn't give domain separation between a supersingular curve and its quadratic twist, because such curves have the same number of points. This isn't an issue with the algorithm as much as with the specification that isogenous curves should have the same ciphersuite ID: a supersingular curve is isogenous to its quadratic twist, so it has the same ciphersuite ID.\r\n   \r\n   So the question is, will the lack of domain separation between a supersingular curve and its twist have any practical effects on security? Right now the answer seems to be no, but Murphy is always lurking. Maybe adding some text warning about this case would be sufficient, if we took the decision to add separation as described above.\r\n\r\n2. Should the ciphersuite string comprehend elements of the ciphersuite beyond the curve? For example, the ciphersuite will specify whether and how to clear cofactors, and whether to use encode_to_curve (not a random oracle) or hash_to_curve (indifferentiable from random oracle). These aren't comprehended in the above proposal; is that OK?\r\n   \r\n   Unlike the case of hashing to both a curve and its twist (which may itself be implausible!), it seems really hard to imagine that one protocol would want two orthogonal hash functions to the same curve, where one hashes to the full curve and the other hashes to a prime-order subgroup. So maybe this isn't an issue. But it wouldn't be so hard to add a few more fields to `c_pre` if we wanted to comprehend these. Importantly, it seems possible to do this without breaking (say) curve25519/edwards25519 compatibility.\r\n\r\n3. Related to the above: it might be a misfeature right now that `hash_to_curve` invokes `hash_to_base` with `ctr = 0` and `ctr = 1`, rather than with `ctr = 1` and `ctr = 2`. The reason to prefer the latter case is that `encode_to_curve` invokes `hash_to_base` with `ctr = 0`, so using 1 and 2 ensures that `encode` and `hash` make orthogonal random-oracle queries, totally for free.\r\n   \r\n   Actually, probably a better alternative is to change the spec for `encode_to_curve` to use `ctr = 2`. This also gives orthogonality, but doesn't break compatibility with the current BLS signatures spec, which currently specifies indifferentiable hashing using `ctr = 0` and `ctr = 1` and already has some implementations.",
          "createdAt": "2019-06-30T21:54:47Z",
          "updatedAt": "2019-06-30T22:02:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One more possibility related to domain separation that came up when chatting with @henrycg that I forgot to mention earlier today.\r\n\r\nLet's assume that we're not doing any kind of ciphersuite-specific domain separation. In that case, it might still make sense to inject a hash-to-curve--specific (but not ciphersuite-specific) string into the hash_to_base function, with the aim of orthogonalizing the invocations of `H` in hash_to_base from other invocations of the same hash function within a given higher-level protocol. Specifically, consider a protocol that's using SHA-256 as a random oracle both in hash_to_base and in some other subroutine unrelated to hash-to-curve.\r\n\r\nLike in the case a few comments above, protocol designers might reasonably expect that these random oracle invocations are orthogonal---and in all likelihood they are, considering the highly stylized H() invocations in hash_to_base. But adding an extra layer of protection is essentially free and might give a tiny bit of peace of mind. Concretely, I'm thinking something like this\r\n\r\n    m' = \"HASH-TO-CURVE\" || H(msg) || I2OSP(ctr, 1)\r\n\r\ninside hash_to_base.\r\n\r\nIn other words, there's a third option that sits in between \"no domain separation\" and \"per-ciphersuite domain separation,\" namely, adding a fixed string that's the same for all ciphersuites in hash_to_base. This ensures that invocations of H in hash-to-curve are orthogonal to other invocations of H.\r\n\r\nI think this is another instance in which an application-level ciphersuite string isn't enough. And it seems like not enforcing separation between calls to H() inside hash_to_base and calls to H() elsewhere in an upper-level protocol may really be inviting badness.",
          "createdAt": "2019-07-01T06:08:45Z",
          "updatedAt": "2019-07-02T02:42:50Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> ...uses points on both an elliptic curve and on its quadratic twist. Suppose that this hypothetical protocol relies on hashing to both the curve and its twist, and models these two hash functions as independent random oracles.\r\n> In this case, simply following the hash-to-curve document would _not_ yield independent random oracles. Since the curve and its twist by definition reside in the same base field, the hash_to_base function for both curves will make exactly the same calls to H (say, SHA256), and will return exactly the same value. Now it's not at all obvious that the two oracles are uncorrelated!\r\n\r\nIf I am not wrong, the curve and its twist have different curve equations, so how it is possible to get the same point since the elliptic curve coefficients play role in the mappings?\r\n\r\n",
          "createdAt": "2019-07-01T17:14:21Z",
          "updatedAt": "2019-07-01T17:14:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I am not wrong, the curve and its twist have different curve equations, so how it is possible to get the same point since the elliptic curve coefficients play role in the mappings?\r\n\r\nYou're right that the *mapping* will return a different point. I was pointing out that *hash_to_base* will return the same value for both curves when invoked on the same string, because hash_to_base only depends on F (which is definitely the same) and W and H (which are almost certainly the same).\r\n\r\nIf that happens, then the same `u` value is given as the input to two (presumably very similar) map_to_curve functions, one for the curve and one for the twist. As far as I can tell, there's no reason to believe that these two functions will give statistically uncorrelated results. Certainly they're not designed to, and as far as I know there's no analysis of such a situation in the literature.",
          "createdAt": "2019-07-01T17:36:56Z",
          "updatedAt": "2019-07-01T17:37:23Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Folks, I'd like to submit a PR on domain separation by EoD tomorrow, so I'd appreciate any last-minute thoughts on the above.\r\n\r\nHere's my concrete proposal:\r\n\r\n1. Change hash_to_base in the way proposed in [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507128652), namely, add a fixed string to separate the use of H in hash_to_base from other uses of H in the invoking protocol.\r\n   \r\n   The justification for this change is effectively the principle of least surprise: hash-to-curve doesn't *look* like SHA-256, so it's kind of surprising for it to require domain separation from SHA-256. I'd guess that even with a stern warning in the document, many users will get this wrong---especially if they're just invoking a hash-to-curve implementation from a library rather than reading the document and implementing it themselves.\r\n\r\n2. Change to `ctr = 2` for `encode_to_curve`, as discussed in point (3) in [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507070611). This is paranoia, but it's totally free, so we may as well do it.\r\n\r\nThis leaves us with the question of per-curve domain separation. Status quo appears to be that we will clearly state that this document does *not* guarantee domain separation between encodings to different curves. If a protocol invokes two different encodings and requires the results to be orthogonal, the protocol MUST inject its own domain separation tags.\r\n\r\nI have to admit, I don't love this solution. Adding a 4-byte, deterministically-generated domain separation tag via something like [`ciphersuite_id`](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507069455) is cheap, and has none of the practical downsides we've discussed upthread. And once again appealing to the principle of least surprise, it just seems like intuitively, oracles to different curves should be uncorrelated.",
          "createdAt": "2019-07-02T03:46:44Z",
          "updatedAt": "2019-07-02T03:47:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is mostly a note-to-self: to avoid adding another compression function invocation in hash_to_base, we can have at most 23 bytes beyond H(msg) in m'. Right now we add 3, namely, ctr, i, and j. \"HASH-TO-CURVE\" is 13 bytes, so we could in principle have up to a 7-byte csid without spilling into another compression invocation.",
          "createdAt": "2019-07-02T03:50:50Z",
          "updatedAt": "2019-07-02T03:51:48Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "\r\nIf I understand correctly, the latest issue with the curve and its twist goes away if we include the curve in the ciphersuite_id, and the high-level application calls hash_to_curve with the ciphersuite_id. Is that right?\r\n\r\nGoing back to the higher-level discussion, I don't think we should be trying to protect *protocol designers* from deviating from the recommendations of this draft; that incurs too much overhead and takes us down a deep rabbit hole.\r\n\r\nMore generally, we need to distinguish between implementation errors and design errors. I agree with the general principle of resilience to *implementation* errors (e.g. resilience to weak randomness and side channel attacks). On the other hand, I'm a lot less sympathetic to paying a price for resilience to *design* errors.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-02T12:26:35Z",
          "updatedAt": "2019-07-02T12:26:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I understand correctly, the latest issue with the curve and its twist goes away if we include the curve in the ciphersuite_id, and the high-level application calls hash_to_curve with the ciphersuite_id. Is that right?\r\n\r\n@hoeteck more or less -- I assumed that the *implementation* of the specific cipher suite would just include ciphersuite_id, i.e., the caller would not pass anything beyond the message to hash.\r\n",
          "createdAt": "2019-07-02T16:05:23Z",
          "updatedAt": "2019-07-02T16:05:23Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "How about the following as a compromise?\r\n\r\nhash-to-curve does incorporate a ciphersuite_id with an extra 8 (or 16) bits, which are zeroes by default, but can be changed by higher-level applications.\r\n\r\nIn particular, we can use\r\n\r\noption 2: fixed string + 4-byte ciphersuite in hash2base\r\nm' = H(ciphersuite || msg) || I2OSP(ctr, 1)\r\n\r\n// note I removed \"HASH-TO-CURVE\".\r\n\r\nbut the first 2 bytes of ciphersuite are always 0 by default (we can think of 0x00 as encoding the string \"HASH-TO-CURVE\"). Moreover, the hash-to-curve spec should explicitly allow higher-level applications to modify those 2 bytes.\r\n",
          "createdAt": "2019-07-02T17:07:36Z",
          "updatedAt": "2019-07-02T17:07:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I understand correctly, the latest issue with the curve and its twist goes away if we include the curve in the ciphersuite_id, and the high-level application calls hash_to_curve with the ciphersuite_id. Is that right?\r\n\r\nMaybe---it depends what you mean by *the* ciphersuite id. The issue is that a single, protocol-level ciphersuite ID isn't sufficient in this case---the protocol has to use a separate ID tag for each curve it hashes to, in order to ensure that those hashes are orthogonal.\r\n\r\nConcretely, imagine that a protocol implements two functions, hash_to_curve and hash_to_twist, and wants to be sure that they are orthogonal. Then the following is OK:\r\n\r\n    Pcurve = hash_to_curve(ciphersuite_id || \"CURVE\" || msg)\r\n    Ptwist = hash_to_twist(ciphersuite_id || \"TWIST\" || msg)\r\n\r\nbut this is not OK:\r\n\r\n    Pcurve = hash_to_curve(ciphersuite_id || msg)\r\n    Ptwist = hash_to_twist(ciphersuite_id || msg)\r\n\r\nTo me, that's a reasonably subtle distinction, and it seems like \"hash_to_curve\" and \"hash_to_twist\" should be doing that work, not their callers.\r\n\r\n---\r\n\r\nI completely agree that it's impossible to prevent people from misunderstanding or ignoring the recommendations. On the other hand, to me it makes sense to try to anticipate insidious misunderstandings and to make those misunderstandings *implementation errors* that can be caught in one place (with test vectors), rather than subtle bugs at individual call sites that may very well go unnoticed.\r\n\r\nI know I sound like a broken record, but the case of library users really worries me. Library users should not need to understand detailed security recommendations from the hash-to-curve document in order to safely invoke a hash-to-curve function that someone else wrote. Or, maybe more accurately: library users just *will not* read this document. To whatever extent is reasonable, complying implementations should protect them anyway.",
          "createdAt": "2019-07-02T17:09:00Z",
          "updatedAt": "2019-07-02T17:09:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> hash-to-curve does incorporate a ciphersuite_id with an extra 8 (or 16) bits, which are zeroes by default, but can be changed by higher-level applications.\r\n\r\nI think I'm not quite understanding your proposal:\r\n\r\n1. Doesn't the current interface already do this, since the caller is already welcome to prefix `msg` with arbitrary tags? In other words: is this any different? How?\r\n\r\n2. Why remove \"HASH-TO-CURVE\"?\r\n\r\n3. Are you proposing to change the API to something like hash_to_curve(msg, ciphersuite) ?\r\n\r\n4. Does this really improve the situation compared to the no-ciphersuite option? By default there's still no domain separation for SHA-256 inside hash_to_base, and random oracles to different curves are not orthogonal.",
          "createdAt": "2019-07-02T17:19:55Z",
          "updatedAt": "2019-07-02T17:19:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the other hand, I'm a lot less sympathetic to paying a price for resilience to _design_ errors.\r\n\r\nI realize that you don't mean a price in the literal sense, but to be clear: there is no computational overhead when adding a per-curve ciphersuite. hash_to_base invokes exactly the same number of rounds of SHA2 in either case.",
          "createdAt": "2019-07-02T17:23:20Z",
          "updatedAt": "2019-07-02T17:23:20Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "There are a couple issues being discussed, but here, I'm focusing on the issue of option 1 vs option 2 at the beginning of this thread, in the context of BLS signatures. In BLS signatures, we want to support additional ciphersuite information beyond what's in hash-to-curve, let's suppose we only need a single byte (concretely, this byte would indicate different mechanisms for preventing rogue-key attacks, e.g. 0x01 for proof of possession and 0x02 for message augmentation).\r\n\r\nTo answer,\r\n\r\n> 1. ... the caller is already welcome to prefix msg with arbitrary tags?\r\n> In other words: is this any different? How?\r\n\r\nLet's suppose we go with option 2 with pre-hashed for free, namely:\r\n\r\n`m' = \"HASH-TO-CURVE\" || ciphersuite || H(msg) || I2OSP(ctr, 1)`\r\n\r\nLet's supposed we want to sign the message \"Hello\" using BLS signatures with option 0x01 over BLS12-381 curve. Looking up the current table, I'd use \"H2C-0008\". Now, what would m' be?\r\n\r\n* option H1. set msg in m' := 0x00 || \"Hello\" (What Riad referred to as prefix msg with arbitrary tag).\r\n\r\n     `m' = \"HASH-TO-CURVE\" || H2C-0008 || H(0x01 || \"Hello\") || I2OSP(ctr, 1)`\r\n\r\n* option H1b. The same thing, but with pre-hashed for free, namely:\r\n\r\n     `m' = \"HASH-TO-CURVE\" || H2C-0008 || H(0x01 || H(\"Hello\")) || I2OSP(ctr, 1)`\r\n\r\n* option H2. allow higher-level applications to modify first bytes of ciphersuite (as I suggested above). Then, in the pre-hashed for free setting, we get:\r\n\r\n     `m' = \"HASH-TO-CURVE\" || H2C-0108 || H(\"Hello\") || I2OSP(ctr, 1)`\r\n\r\nI see two advantages in option H2:\r\n\r\n* (concrete efficiency) comparing option H1b and H2, we save one hash.\r\n* (\"aesthetics\") all the ciphersuite information go into the same place, namely `H2C-0108`. This makes defining ciphersuite for higher-level applications much cleaner, namely\r\n\r\n    `higher-level specific options || hash-to-curve options`\r\n\r\nMore generally, we can have H2C-xxyyzz with 3 bytes, with xx defaulting to 00 and reserved for high-level applications.\r\n\r\n> 2. Why remove \"HASH-TO-CURVE\"?\r\n\r\nThis is mostly aesthetic, but if we include a string \"HASH-TO-CURVE\" in m', then we should also include \"BLS-SIGN\" in m', and I don't know a clean way to do in option 2. But let's put this aside for now.\r\n\r\nHope that clarifies things somewhat! :)\r\n",
          "createdAt": "2019-07-02T18:01:52Z",
          "updatedAt": "2019-07-02T18:01:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> * option H2. allow higher-level applications to modify first bytes of ciphersuite (as I suggested above). Then, in the pre-hashed for free setting, we get:\r\n>   `m' = \"HASH-TO-CURVE\" || H2C-0108 || H(\"Hello\") || I2OSP(ctr, 1)`\r\n\r\nI agree this is nice from a performance perspective, but in my mind it doesn't provide meaningful domain separation. This is related to pairingwg/bls_standard#17. The issue is that one byte is not sufficient to ensure that different protocols make distinct calls to the random oracle. Concretely, if protocols A and B both use a one-byte ciphersuite tag, there's a really good chance that both of them will compute exactly the same value for `m'`---especially if they just enumerate their ciphersuites starting from 0 the way BLS is currently doing.\r\n\r\nThis is exactly the situation we're trying to avoid with domain separation: the protocols need to somehow include a globally unique (we hope) string inside `m'`. This is why I'm strongly in favor of \"HASH-TO-CURVE\", \"BLS-SIGN\", \"RFC7748\", or whatever.\r\n\r\nI'm also not in favor of weakening the abstraction / complicating the interface between hash-to-curve and upper-level protocols. In my mind, the signature of the hash-to-curve functions should be\r\n\r\n    {0, 1}^* -> E\r\n\r\nAnd they should behave in a way that, to the greatest extent possible, aligns with intuition. For the purposes of this thread, from my perspective \"intuitive\" means that different hash functions are fully distinct from all other random oracles in a protocol. This is the best possible guarantee that hash-to-curve can give. That doesn't mean that higher-level protocols don't need to do domain separation among themselves! but it *does* mean that it's safe to treat conforming hash-to-curve implementations as a black box. In other words, of course hash-to-curve functions *can* be misused, but the simplest and most obvious way to use them is probably the right way, modulo responsibilities that only the upper-level protocol is in a position to discharge.\r\n\r\nAs far as performance goes, in my mind the calling protocol should *only* be passing tagged messages to *any* random oracle. This means that there really is no extra cost for computing\r\n\r\n    H(\"MY-PROTOCOL\" || 0x01 || original_message)\r\n\r\nbecause the upper-level protocol should *never* call `H(original_message)`, to a first approximation.\r\n\r\n---\r\n\r\nEDIT: this is sort of separate from the above, but I think it's pretty clear from the discussion upthread that fixing a table of ciphersuite IDs is a non-starter. So let's assume that we'd compute the ciphersuite ID using a deterministic algorithm. I've edited the first post in the thread to that effect.",
          "createdAt": "2019-07-02T19:01:33Z",
          "updatedAt": "2019-07-02T19:30:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "To add another perspective:\r\n\r\nI spoke with Dan (Boneh) about this today, and his take was that this is very application dependent, so it might be best to leave it to the applications to decide whether they want per-curve domain separation rather than arbitrarily decree that there shall be separation just between isogeny classes. So that's another vote against per-curve separation.\r\n\r\nDan *is* in favor of adding some fixed string to the H() calls inside hash_to_base, roughly as discussed [here](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507128652). But he suggested that it is probably better to use HKDF than to \"roll our own\" PRG. Let's leave that to an orthogonal discussion---I've created #137.\r\n\r\n---\r\n\r\nSince it seems like there's little enthusiasm to go all-in on per-curve domain separation, I'm fine adding text that explicitly delegates this task to the upper-level protocols, at least for now. We can revisit this decision in the future if necessary, but I'd rather get *some* text about domain separation before the deadline, since that's probably the most effective way to solicit feedback from the broader community.",
          "createdAt": "2019-07-02T22:21:27Z",
          "updatedAt": "2019-07-02T22:21:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I created #139 capturing more or less what's here, tabling the question of per-curve domain separation for now since there seems to be little enthusiasm for it. Comments appreciated.",
          "createdAt": "2019-07-03T06:31:44Z",
          "updatedAt": "2019-07-03T06:31:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We reached a consensus on domain separation, so I'm closing this issue.",
          "createdAt": "2019-10-27T06:07:26Z",
          "updatedAt": "2019-10-27T06:07:26Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWU0NTU2NDYwMDc=",
      "title": "Scoping the definition of suites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/126",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Let's explicitly enumerate the groups of interest for instantiating suites.\r\nPlease also consider the following points:\r\n   1) Which are the groups of interest?\r\n   2) Should we cover curves standardized by agencies different than NIST and IETF? \r\n   3) What is the criteria for not to include a specific curve?\r\n   4) Should we provide a way to generate extensible suites for addressing curves not considered in the doc?\r\n\r\nAnswering these questions will help us to have a clearer path for finishing the last part of the document.",
      "createdAt": "2019-06-13T09:55:38Z",
      "updatedAt": "2019-10-27T06:09:14Z",
      "closedAt": "2019-10-27T06:09:14Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The list of curves I have written down are:\r\n\r\n- FIPS 186-4 curves: p256, p384, p521. Not p192 or p224, though: they're not used much, and we shouldn't encourage them to be.\r\n- RFC 7748: Curve25519, Curve448\r\n- RFC 8032: Ed25519, Ed448\r\n- Bitcoin et al: SECP256K1\r\n- Pairing-friendly curves: BLS12-381 for sure, since BLS signatures is going to use it. The [pairing-friendly curve draft](https://github.com/pairingwg/pfc_standard/) also mentions BN256 (100-bit security), BN462, and BLS48-581. Probably we should coordinate with them and make sure to cover the curves they standardize.\r\n- SIKEP503 - currently in poc code. What about [other post-quantum candidate curves](https://github.com/microsoft/PQCrypto-SIDH)?\r\n- SS132 - a supersingular curve apparently from RFC5091",
          "createdAt": "2019-06-13T18:14:19Z",
          "updatedAt": "2019-06-13T18:14:19Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is a larger list of curve (https://eprint.iacr.org/2015/1060.pdf)\r\n\r\nThe point for discussion that I want to raise is not whether we must encourage or not the use of CurveX instead of CurveY. \r\n\r\nMy point is that covering exhaustively all cases could not be possible since there are many curves and there will be more curves in the future. So, I think the document must provide a general guideline for an implementer using the brand-new CurveXYZ be able to instantiate a suite not deviating from the framework and algorithms we are proposing. And for the most popular curves (it could be the curves used for TLS) provide enumerated suites.\r\n\r\n\r\n",
          "createdAt": "2019-06-13T18:42:07Z",
          "updatedAt": "2019-06-13T18:42:07Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I think I was unclear.\r\n\r\nI completely agreed that we can't cover all curves exhaustively, and that we should give people enough information to make good choices for curves that aren't covered.\r\n\r\nBut we can do this while also choosing suites that accomplish other useful goals. In particular, here's what I'd like to see:\r\n\r\n1. Every suite entry should have a corresponding \"straight-line implementation\" in the appendix of the document that uses every optimization we know.\r\n\r\n2. Because of (1), the suites should be chosen to cover curves that are standardized and in widespread use. It's good for the community if we spend the time thinking carefully about efficient implementations for widely-used curves and document the results. This is the reason I suggested the FIPS curves, '25519 and '448, and SECP256K1, and it's also also why I included the pairing-friendly curves: those curves and related applications are in the process of being standardized. TLS is a great suggestion, @armfazh; do you have specific suggestions other than the ones I listed above?\r\n\r\n3. Beyond the curves in (2), I think we should make sure that the defined suites include at least one curve for each map in the document. For this purpose it's OK to relax the \"widespread use\" requirement. The reason for this is, even if implementors don't use exactly the curve we give as an example, having a careful implementation of the map available, even for a different curve, will be helpful to implementors. This is why I included SIKE-P503 and SS-132: these are examples of \"Elligator A=0\" and \"Boneh-Franklin,\" respectively.\r\n\r\n> The point for discussion that I want to raise is not whether we must encourage or not the use of CurveX instead of CurveY.\r\n\r\nAh, but here's the thing: including any curve in the document *is* tacitly endorsing that curve for use, whether we want it to be or not. Because of this, we should be careful about which curves we suggest---hence my suggestion to leave out p192 and p224.\r\n\r\nAlso, related to using curves that aren't covered: as I said in #124, if we require including the hash-to-curve ciphersuite identifier for domain separation, we have to be *extra* careful to allow a path forward for curves we didn't cover. This is quickly becoming my biggest concern with the ciphersuite/domain separation issue.",
          "createdAt": "2019-06-13T22:24:53Z",
          "updatedAt": "2019-06-13T22:24:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Per @chris-wood's [comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/121#discussion_r290771878), we should decide whether or not to add non-RO suites. (Probably yes...)",
          "createdAt": "2019-06-17T22:36:44Z",
          "updatedAt": "2019-06-17T22:36:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like we've got a good handle on suites at this point, so I'm closing this issue.\r\n\r\nIf anyone wants to add a new curve to suites, they can open a separate issue or PR.",
          "createdAt": "2019-10-27T06:09:14Z",
          "updatedAt": "2019-10-27T06:09:14Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU0NTk1ODAyMTQ=",
      "title": "map2curve / appendix : more detailed discussion",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/128",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the discussion of #127, @samscott89 [suggested](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127#discussion_r296278246) a more in-depth discussion of some properties of the map2curve functions: injectivity, invertibility, well-distributedness, etc.\r\n\r\nI agree with the above-linked comment that it could be useful for future documents to refer to a nice summary of these properties. On the other hand, since they're a bit lower level than what's necessary for the purpose of standardizing (implementations of) hashes to curves, and in particular since they're not likely to be of interest to implementors in most cases, it seems like this might be a good candidate for an appendix that briefly summarizes the relevant properties and cites the appropriate primary sources (FFSTV13, for example).\r\n\r\nI think there are some other issues that need to be addressed first, so I'm stashing an issue and we can revisit in the future.",
      "createdAt": "2019-06-23T14:08:47Z",
      "updatedAt": "2019-06-26T17:04:04Z",
      "closedAt": "2019-06-26T17:04:04Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a sentence/comment might well suffice in this case. It's just that this document might end up having a better description of map2curve functions than exist elsewhere. So perhaps worth keeping a few pertinent pieces of information in there, without letting this doc expand into a elliptic curve encyclopedia.",
          "createdAt": "2019-06-24T00:48:40Z",
          "updatedAt": "2019-06-24T00:48:40Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU0NjA0OTkxOTg=",
      "title": "meta-issue: triage for July 8th draft update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/129",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The deadline for getting drafts updated before IETF 105 is [July 8th](https://datatracker.ietf.org/meeting/105/important-dates/). This is an attempt at triaging the open issues and known TODOs to hit that date.\r\n\r\nPlease let me know if anything seems to be miscategorized!\r\n\r\n## Really should have\r\n\r\n- [x] Definitions: maps, encodings, etc. (#127, #128) - making sure that the definitions and high-level framing are clear is important for getting useful feedback on the next draft. Plus, these should be very close to converging!\r\n\r\n- [x] Fix point conversions for Edwards -> Montgomery to agree with existing RFCs (#107) - see second comment in linked issue. VRF won't reference us until this is fixed. #132 handles this.\r\n\r\n- [x] Update list of suites / decide on suite scope (#96, #126) - my hope is that we can take an initial cut at this and then solicit feedback.\r\n\r\n- [x] Cofactor clearing (#95) - @chris-wood and I discussed including \"cofactor clearing value\" in the suites table. For curves that have optimized cofactor clearing (generally, pairing-friendly curves), this is sufficient to make sure that people who don't implement the optimization can still output the correct point via scalar multiplication. Adding a column in the suites table addresses this.\r\n\r\n## Nice to have\r\n\r\n- [ ] Submit PR to VRF folks to refer to this draft rather than describing its own version of hash-to-curve - not sure if we can coordinate this in time, but we should try!\r\n   \r\n   (EDIT: I'm in a conversation with the VRF folks about this. Looks like we won't make it before July 8th, but that's fine---we'll make it happen as we can.)\r\n\r\n- [ ] Projective coordinates / optimized implementations (#4, #43, #109, #111, #117) - once we have an updated list of suites, we should put optimized impls in the appx.\r\n\r\n- [x] Domain separation (#124) - the discussion in the issue seems at this point to have identified the main pros and cons, so it seems like we should open this up for discussion on-list or at the meeting. We might not get this feedback in time, but we should try.\r\n   \r\n   (EDIT: marked this completed because #139 landed. Not sure if that means we can close #124, though.)\r\n\r\n## Not a blocker\r\n\r\n- [ ] Flow chart (#63, #118) - these will be very useful, but (as far as I know) we can't include non-ASCII diagrams in the draft, so it probably doesn't make sense to spend too much time on these before the deadline.\r\n\r\n- [ ] Code quality (#98, #112) - reference code isn't gated by the draft process, so we can de-prioritize.\r\n\r\n- [ ] style nits (#105, #110) - would be great to cover these, but not a killer if we don't.",
      "createdAt": "2019-06-25T15:38:36Z",
      "updatedAt": "2019-08-13T16:03:40Z",
      "closedAt": "2019-08-13T16:03:40Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "On the topic of compatibility with the [VRF draft](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04):\r\n\r\nmap_to_curve_elligator2 is compatible with what's described in steps 8-12 of section 5.4.1.2, other than the sign of the point (which they appear to always set to the positive value after converting to Edwards form). Also, the way they convert from a Montgomery to an Elligator point is exactly the way that is described in RFC7748.\r\n\r\nSo they can't just say \"use encode_to_curve\" in the VRF document, since they way they hash to the input `u` to map_to_curve_elligator2 is not the same as hash_to_base, but they can simplify their text a good deal.\r\n\r\nI'll ping the VRF authors this evening.",
          "createdAt": "2019-06-28T23:04:03Z",
          "updatedAt": "2019-06-28T23:05:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I marked the second big ticket item resolved.",
          "createdAt": "2019-07-02T16:02:18Z",
          "updatedAt": "2019-07-02T16:02:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I sent an email to the VRF folks late last week, but haven't heard back yet. I'm going to prioritize suites list and domain separation since it's not clear that we could get a PR into the VRF draft before the deadline. Does this sound OK @chris-wood ?",
          "createdAt": "2019-07-02T21:07:13Z",
          "updatedAt": "2019-07-02T21:09:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If you're open to it, could I take the suites one and you work on the optimized implementation task? ",
          "createdAt": "2019-07-02T21:45:35Z",
          "updatedAt": "2019-07-02T21:45:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've got some reasonable progress locally on the suites; probably I could push something in the next few hours. But I'm happy to hand it off and switch to the impls if you'd prefer.",
          "createdAt": "2019-07-02T21:52:37Z",
          "updatedAt": "2019-07-02T21:52:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam Ah, then never mind! Please proceed as planned.",
          "createdAt": "2019-07-02T21:53:07Z",
          "updatedAt": "2019-07-02T21:53:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I recommend you make a push with the first suite you have, then we discuss about format, and once everything was agreed, we can continue adding suites.",
          "createdAt": "2019-07-02T21:56:26Z",
          "updatedAt": "2019-07-02T21:56:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Good idea @armfazh. I'll push a preliminary cut soon.",
          "createdAt": "2019-07-02T22:23:23Z",
          "updatedAt": "2019-07-02T22:23:23Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#138 is ciphersuites WIP. I've got the parameters mostly written down for these suites, so I'll get that info into the document in the next few commits, but you can start taking a look in the meantime.",
          "createdAt": "2019-07-03T00:23:49Z",
          "updatedAt": "2019-07-03T00:24:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue, because we've either handled the issues pointed to here or we've got other issues that capture them",
          "createdAt": "2019-08-13T16:03:40Z",
          "updatedAt": "2019-08-13T16:03:40Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU0NjE2MDQ3NTg=",
      "title": "Investigate Elligator2 implementation speedup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/133",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Bj\u00f6rn Haase on the list:\r\n\r\n> Regarding the Elligator 2 map, the algorithm shown in the  github version of the draft is actually slower than necessary. It requires two exponentiations (for one inverse and one square root).\r\n>\r\n> Some time ago Mike Hamburg did point me to a solution on how to implement this with one single exponentiation. The algorithm is found also somewhere hidden within the Ed25519 paper of Bernstein, Duif, Lange, Schwabe and Yang. Still Beno\u00eet and me did consider it helpful to write down the faster algorithm explicitly in our last paper, because we thought that there might be others that missed this optimization opportunity :-).\r\n>\r\n> You'll find the explicit write-down in section 8.2 on page 33 of\r\n>\r\n> https://tches.iacr.org/index.php/TCHES/article/view/7384\r\n",
      "createdAt": "2019-06-27T15:41:59Z",
      "updatedAt": "2019-07-08T23:30:52Z",
      "closedAt": "2019-07-08T23:30:52Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: this is an optimization I was planning to use heavily in the curve-specific versions---and not just for curve25519---but it's good to keep this as a reminder.\r\n\r\nA slightly unfortunate issue with this optimization is that it's only a savings if the map outputs a point in projective coordinates. Otherwise, you just trade one division for another: you can skip the division when computing sqrt(g(x)) with this trick, but then you still end up with x expressed as a fraction.\r\n\r\nFor the curve-specific implementations, we discussed making explicit that returning a projective point is cheaper. This at least gives implementors some breadcrumbs for curves that don't have example code.\r\n\r\nThe best would be if we could show optimizations like this for the generic implementations, but unfortunately all of these tricks rely on the form of p, or at least *knowing* whether p is (say) 3 mod 4 or 5 mod 8 or 9 mod 16. So probably it will have to be relegated to the curve-specific implementations.",
          "createdAt": "2019-06-27T19:58:48Z",
          "updatedAt": "2019-06-27T20:00:08Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU0NjIyMzMwNTM=",
      "title": "clarify Montgomery forms in {{elligator2}}",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/134",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The classic definition of the Montgomery form is\r\n\r\n    B * y^2 = x^3 + A * x^2 + x\r\n\r\nwhereas the Elligator paper works in the following slightly different form\r\n\r\n    y'^2 = x'^3 + A' * x'^2 + B' * x'\r\n\r\n#132 shows how to convert between these forms in the new appendix via a change of variables.\r\n\r\nIt might make sense to ref this change of variables from the {{elligator2}} section; otherwise, it could end up confusing people who intend to hit one form and accidentally hit the other.\r\n\r\n(Fortunately, both curve25519 and curve448 have B = 1, which means the two forms are equivalent!)",
      "createdAt": "2019-06-28T22:55:08Z",
      "updatedAt": "2019-11-09T00:21:07Z",
      "closedAt": "2019-07-02T16:01:36Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "To avoid confusion, one can call this equation a Weierstrass curve.\r\n```\r\ny'^2 = x'^3 + A' * x'^2 + B' * x'\r\n```\r\n\r\n",
          "createdAt": "2019-06-28T23:27:17Z",
          "updatedAt": "2019-06-28T23:27:17Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "(SAGE) I wrote the birational maps between Montgomery and Twisted Edwards curves.\r\n\r\n```python\r\nRE.<x,y,a,d> = QQ[]\r\nE = a*x**2+y**2 - ( 1 + d*x**2*y**2 )\r\nFE = Frac(RE.quotient_ring(E))\r\n\r\nRM.<u,v,A,B> = QQ[]\r\nM = B*v**2 - (u**3+A*u**2+u )\r\nFM = Frac(RM.quotient_ring(M))\r\n\r\nRW.<s,t,C,D> = QQ[]\r\nW = t**2 - (s**3+C*s**2+D*s )\r\nFW = Frac(RW.quotient_ring(W))\r\n\r\nE_to_M = E.subs(x=(u/v),y=(u-1)/(u+1),a=(A+2)/B,d=(A-2)/B)\r\nM_to_E = M.subs(u=(1+y)/(1-y),v=(1+y)/(x*(1-y)),A=2*(a+d)/(a-d),B=4/(a-d))\r\n\r\nassert FM( E_to_M ) == 0, \"do not match E -> M \" \r\nassert FE( M_to_E ) == 0, \"do not match M -> E \" \r\n\r\nW_to_E = W.subs(s=(1+y)/((4/(a-d))*(1-y)),t=(1+y)/((4/(a-d))*x*(1-y)),C=(a+d)/2,D=(a-d)**2/16)\r\nassert FE( W_to_E ) == 0, \"do not match W -> E \"\r\n\r\n```\r\nThe last one is the map from Weierstrass to Twisted Edwards curve, but I didn't have the map from E -> W. @kwantam do you have the explicit substitutions for the latter map?\r\n\r\n\r\n",
          "createdAt": "2019-06-28T23:31:38Z",
          "updatedAt": "2019-06-28T23:31:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> To avoid confusion, one can call this equation a Weierstrass curve.\r\n> \r\n> ```\r\n> y'^2 = x'^3 + A' * x'^2 + B' * x'\r\n> ```\r\n\r\nThis is a good point. Probably that means we have to move the change-of-variables from the appendix to {{montgomery}}, but that's easy enough. I'll look at doing it in another commit on #132.",
          "createdAt": "2019-06-29T01:31:12Z",
          "updatedAt": "2019-06-29T01:31:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The last one is the map from Weierstrass to Twisted Edwards curve, but I didn't have the map from E -> W. @kwantam do you have the explicit substitutions for the latter map?\r\n\r\nSure. I think the missing trick is that `D` has to be square, so we have to specify W in terms of `sqrtD**2` rather than `D`:\r\n\r\n```python\r\nRE.<x,y,a,d> = QQ[]\r\nE = a*x**2+y**2 - ( 1 + d*x**2*y**2 )\r\nFE = Frac(RE.quotient_ring(E))\r\n\r\nRM.<u,v,A,B> = QQ[]\r\nM = B*v**2 - (u**3+A*u**2+u )\r\nFM = Frac(RM.quotient_ring(M))\r\n\r\nRW.<s,t,C,sqrtD> = QQ[]\r\nW = t**2 - (s**3+C*s**2+sqrtD**2*s )\r\nFW = Frac(RW.quotient_ring(W))\r\n\r\nE_to_M = E.subs(x=(u/v),y=(u-1)/(u+1),a=(A+2)/B,d=(A-2)/B)\r\nM_to_E = M.subs(u=(1+y)/(1-y),v=(1+y)/(x*(1-y)),A=2*(a+d)/(a-d),B=4/(a-d))\r\n\r\nassert FM( E_to_M ) == 0, \"do not match E -> M \"\r\nassert FE( M_to_E ) == 0, \"do not match M -> E \"\r\n\r\nW_to_E = W.subs(s=(1+y)/((4/(a-d))*(1-y)),t=(1+y)/((4/(a-d))*x*(1-y)),C=(a+d)/2,sqrtD=(a-d)/4)\r\nE_to_W = E.subs(x=s/t,y=(s/sqrtD-1)/(s/sqrtD+1),a=C+2*sqrtD,d=C-2*sqrtD)\r\n\r\nassert FE( W_to_E ) == 0, \"do not match W -> E \"\r\nassert FW( E_to_W ) == 0, \"do not match E -> W \"\r\n```",
          "createdAt": "2019-06-29T02:10:04Z",
          "updatedAt": "2019-06-29T02:10:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Link to the snippet: https://gist.github.com/armfazh/ab759968419e95fb5680b4a0dd046a6d",
          "createdAt": "2019-11-09T00:21:07Z",
          "updatedAt": "2019-11-09T00:21:07Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU0NjMxNzkxMzU=",
      "title": "integer power",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/135",
      "state": "CLOSED",
      "author": "vadym-f",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Field calculation \\pmod{p} at steps 15,16 of Icart method (lines 311,312)\r\nused later as a power at step 17\r\nmight be a copy-paste\r\nthat should be calculation over integers instead.",
      "createdAt": "2019-07-02T11:38:38Z",
      "updatedAt": "2019-07-07T06:38:26Z",
      "closedAt": "2019-07-07T06:38:26Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for reporting this.\r\n\r\nI'm not sure that I'm seeing exactly the issue you're referring to. Can you please let me know if #145 addresses this issue?\r\n\r\nIf not, can you please let me know which version of the document you're referring to in your comment?\r\n\r\nThanks again!",
          "createdAt": "2019-07-07T05:36:00Z",
          "updatedAt": "2019-07-07T05:36:00Z"
        },
        {
          "author": "vadym-f",
          "authorAssociation": "NONE",
          "body": "Thank you Riad for your time pushing this into an agreed-on standard text,\r\nfor recent IACR preprint, and proof system.\r\n\r\nYes, #145 fixes formal nuisance with explicit excessive (mod p) in the\r\ntext, including the power.\r\nIt looks very clear for me now.\r\nI was looking into -00 version, which seems somewhat outdated.\r\n\r\nOn Sun, Jul 7, 2019 at 8:36 AM Riad S. Wahby <notifications@github.com>\r\nwrote:\r\n\r\n> Thanks for reporting this.\r\n>\r\n> I'm not sure that I'm seeing exactly the issue you're referring to. Can\r\n> you please let me know if #145\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/145>\r\n> addresses this issue?\r\n>\r\n> If not, can you please let me know which version of the document you're\r\n> referring to in your comment?\r\n>\r\n> Thanks again!\r\n>\r\n> \u2014\r\n> You are receiving this because you authored the thread.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/135?email_source=notifications&email_token=AJ273N2TZVHHWN7FPENLPATP6F6EDA5CNFSM4H423722YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODZLE6PQ#issuecomment-508972862>,\r\n> or mute the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AJ273N6XXUGYUINLHSEQECTP6F6EDANCNFSM4H42372Q>\r\n> .\r\n>\r\n",
          "createdAt": "2019-07-07T06:27:42Z",
          "updatedAt": "2019-07-07T06:36:44Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU0NjM0NjEwNDA=",
      "title": "HKDF in place of ad-hoc PRG currently used by hash_to_base?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/137",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Dan Boneh points out that there's little reason to roll our own PRG inside hash_to_base. Instead, he suggests using [HKDF](https://tools.ietf.org/html/rfc5869).\r\n\r\n(I have to admit, I'm slightly annoyed at myself for having failed to consider this option. Sorry, folks.)\r\n\r\nWhile this makes hash_to_base slightly more expensive, the difference in cost is negligible compared to the end-to-end cost of hashing to a curve.\r\n\r\nThe main issues I see with taking this approach are:\r\n\r\n- is there a way to get \"prehash for free\" as in the current approach?\r\n- is there a compatibility story for the BLS signatures standard?\r\n\r\n@hoeteck, thoughts on how this might play out with BLS? I can imagine there isn't a huge appetite for this change. On the other hand, I wonder if we can really justify using a hash_to_base function that lacks rigorous analysis when the (arguably) \"right thing\" is kind of well known?",
      "createdAt": "2019-07-02T22:20:40Z",
      "updatedAt": "2019-07-06T18:21:51Z",
      "closedAt": "2019-07-06T18:21:51Z",
      "comments": [
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "\r\nUsing HKDF is a great idea, indeed! It's also used in TLS 1.3.\r\n\r\nHKDF-Expand also takes as input a context/info, and ciphersuite/domain separation info would fit in naturally over there.\r\n\r\n> thoughts on how this might play out with BLS?\r\n\r\nCome to think about it, we should probably use HKDF for key generation in BLS signatures, since it also takes into account weak randomness used for key generation.\r\n\r\n> I have to admit, I'm slightly annoyed at myself for having failed to consider this option. \r\n\r\nYou're doing great! Don't be so harsh on yourself :)",
          "createdAt": "2019-07-02T22:44:07Z",
          "updatedAt": "2019-07-02T22:44:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using HKDF is a great idea, indeed! It's also used in TLS 1.3.\r\n\r\n+1!\r\n\r\n> You're doing great! Don't be so harsh on yourself :)\r\n\r\nHeavy +1.",
          "createdAt": "2019-07-03T20:55:43Z",
          "updatedAt": "2019-07-03T20:55:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #141",
          "createdAt": "2019-07-06T18:21:49Z",
          "updatedAt": "2019-07-06T18:21:49Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0NjM3Mjk5NTE=",
      "title": "Future-proofing ciphersuite labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/140",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This seems like a low-priority issue, but wanted to get the thoughts down\r\nfor future discussion:\r\n\r\nLooking ahead to where we will realistically fall on ciphersuite definitions,\r\nit is unlikely that aspects such as specific constants (e.g. quadratic non-residues),\r\nand even the scalar used for cofactor clearing (in the case of optimised\r\nimplementations) will be explicit in the ciphersuite **label**, despite\r\nbeing explicit in the definition itself.\r\n\r\nIn the future, there is a chance that different choices will be desired, \r\nfor example, due to new algorithmic improvements. Changing these requires\r\na new ciphersuite tag, else implementations may become incompatible.\r\n\r\nThis leaves open the question of versioning the ciphersuites themselves,\r\nsince we may want a \"v2\" of a ciphersuite.\r\n\r\nHowever, this possibility seems low enough probability that forcing a \"v1\"\r\nsuffix onto all existing ciphersuites seems unnecessary.\r\nOne solution seems to be considering future extensions to the draft to\r\nallow changing \"curvexxx-hashyyy-mapzzz-ro\" to simply \"curvexxx-hashyyy-mapzzz-ro-v2\"\r\nin such an scenario.\r\n",
      "createdAt": "2019-07-03T12:40:53Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I should add: this specific issue is orthogonal to the issue of maintaining a registry/adding new curves/maps.",
          "createdAt": "2019-07-03T12:41:49Z",
          "updatedAt": "2019-07-03T12:41:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, this possibility seems low enough probability that forcing a \"v1\"\r\n> suffix onto all existing ciphersuites seems unnecessary.\r\n\r\nAgreed.\r\n\r\n> One solution seems to be considering future extensions to the draft to\r\n> allow changing \"curvexxx-hashyyy-mapzzz-ro\" to simply \"curvexxx-hashyyy-mapzzz-ro-v2\"\r\n> in such an scenario.\r\n\r\nI think the current text in {{suites}} allows this: it doesn't require that the suite *ends* with (say) \"-RO\", just *contains* it. So appending a \"-V2\" to a suite ID yields a valid suite ID.\r\n\r\nOr: am I misunderstanding what you're suggesting? (If so, apologies!)",
          "createdAt": "2019-07-05T00:04:22Z",
          "updatedAt": "2019-07-05T00:04:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "No, that's exactly right. Opening this is sort of a sanity check for \"we shouldn't need to do anything about this, and the obvious approach works, right?\". For example, this might become relevant if we were to try and enforce something like all tags are precisely 32 bytes.",
          "createdAt": "2019-07-05T18:34:38Z",
          "updatedAt": "2019-07-05T18:34:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/161#issuecomment-517732622) (stashing this here because I'm trying to close #161 now)",
          "createdAt": "2019-08-09T00:28:47Z",
          "updatedAt": "2019-08-09T00:29:04Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU0NjQ4ODI4NzI=",
      "title": "possible enhancement: simplify sgn0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/144",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's a potential enhancement/improvement to sgn0 that we might want to consider. This option may have been discussed a little before, but it's probably worth revisiting before things get too ossified.\r\n\r\nThe current version of sgn0 says that an element x in GF(p) is negative just when it is greater than (p - 1) / 2. (Things are slightly more complicated for GF(p^m), but let's ignore that for now.)\r\n\r\nSince p is odd, an alternative means of differentiating between x and -x is via the least significant bit: if the least significant bit of x is set, call x negative, otherwise call it positive. (This works because p - x and x have opposite LSBs, except when x = 0.)\r\n\r\nThe major advantage to this approach is that it's much easier to check a single bit in constant time than it is to compare a value to (p-1)/2. On the other hand, I'd guess that in many cases a constant-time comparison function is already available, so maybe this isn't such a decisive advantage after all.\r\n\r\nThe major disadvantage (if it can be called that) is that it leads to slightly nonintuitive definitions of \"negative.\" For example, normally we'd think of 1 as positive, but by the parity definition, sgn0(1) == -1, and sgn0(p - 1) == 1. But maybe that's OK.\r\n\r\nThoughts?\r\n\r\nSince this would be a breaking change, sooner is better than later. Also, it might change the suites definitions, since some suites have a constant Z that is \"smallest in absolute value, breaking ties by choosing the positive one,\" and changing the definition of sign might change that.",
      "createdAt": "2019-07-06T19:16:39Z",
      "updatedAt": "2019-10-30T16:30:13Z",
      "closedAt": "2019-10-30T16:30:13Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "From the implementation side, field arithmetic usually is implemented using redundant representations, in some cases, lazy-reduction (modulo a multiple of a prime) are used too.\r\n\r\nIn both cases, comparison or parity require a conversion from the internal representation to recover its unique representation 0<= x < p, and thus to determine x > p/2 or x mod 2.\r\nIn summary, from the implementation side (when using redundant representations) both operations are annoying. \r\n\r\nEven though checking parity is simpler, I consider that x > (p-1)/2 is well understood and does not present odd semantic cases (as the ones you mentioned above).\r\n",
          "createdAt": "2019-07-30T01:32:47Z",
          "updatedAt": "2019-07-30T01:32:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, your point about redundant representations is a good one.\r\n\r\nEven if not using redundant representations, Montgomery arithmetic will require a multiplication before doing either comparison or LSB check---so performance-wise, probably no change, just as you say.",
          "createdAt": "2019-07-30T01:38:49Z",
          "updatedAt": "2019-07-30T01:38:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From an offline exchange, we might also specify `sgn0` per suite.",
          "createdAt": "2019-08-19T20:32:02Z",
          "updatedAt": "2019-08-19T20:32:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood, I spoke with @reyzin about this and I think your suggestion is a good one. I'll put together a PR that defines the two or three standard sgn0 variants and then sets the variant per-suite.\r\n\r\nI'm not fully sold on this since it increases the complexity of the document a bit, but let's take a look.",
          "createdAt": "2019-10-13T05:22:10Z",
          "updatedAt": "2019-10-13T05:22:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good!",
          "createdAt": "2019-10-13T21:11:46Z",
          "updatedAt": "2019-10-13T21:11:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I looked at IEEE 1363a-2004 and it looks like we can cover that serialization format, the BLS12-381ish format, and the Ed25519ish format with just two sgn0 variants. I'm working on a [branch](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/tree/sqrt_sgn0_variants) that breaks these out. I still need to do some work to figure out who's actually implementing which serialization method for each curve, though.\r\n\r\n@chris-wood do you happen to know where the elliptic curve point serialization format in TLS comes from? That is, is it defined globally or per curve? I'll happily go dig through the RFC and impls, I'm just wondering if you remember off the top of your head.",
          "createdAt": "2019-10-14T04:16:04Z",
          "updatedAt": "2019-10-14T04:16:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> is it defined globally or per curve?\r\n\r\nPer-curve, but there's an [extension that lets endpoints specify the format](https://tools.ietf.org/html/rfc4492#section-5.1.2), too. (Uncompressed is the default for older curves. Curve25519 and newer curves specify the format as part of the group.)",
          "createdAt": "2019-10-14T14:15:38Z",
          "updatedAt": "2019-10-14T14:18:15Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it---thanks!\r\n\r\nIt looks like essentially everyone except the pairing-friendly curves is using X9.62 (aka SEC1) point compression. This makes life relatively easy.",
          "createdAt": "2019-10-16T21:27:39Z",
          "updatedAt": "2019-10-16T21:27:39Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWU0NjU0OTQyMTY=",
      "title": "add README in poc that gives correspondence between code and sections of the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/151",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "It should be warned somewhere in the main doc which sage scripts correspond to the version we will submit.\r\n\r\n_Originally posted by @armfazh in https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/146#issuecomment-509419284_",
      "createdAt": "2019-07-08T22:56:43Z",
      "updatedAt": "2019-11-17T03:35:06Z",
      "closedAt": "2019-11-17T03:35:06Z",
      "comments": []
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU0NjU2NzE0NjA=",
      "title": "Add section on try and increment",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/153",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not mention the \"naive\" try and increment. I feel implementers will undoubtedly want to consider it. If the intent is to discourage the use of try and increment a section explaining why it is discouraged may be warranted. If it is not discouraged then a section standardising it may also be warranted. ",
      "createdAt": "2019-07-09T09:26:09Z",
      "updatedAt": "2019-07-10T21:51:33Z",
      "closedAt": "2019-07-10T21:43:30Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I think try and increment is dead based on https://github.com/zkcrypto/pairing/issues/56#issuecomment-501942010 ",
          "createdAt": "2019-07-10T06:46:58Z",
          "updatedAt": "2019-07-10T06:46:58Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Try and increment has the advantage of being trivial to specify (though not implement optimally). It is also likely used in production today. Even if \"dead\", an explanatory death note is probably warranted.",
          "createdAt": "2019-07-10T09:48:35Z",
          "updatedAt": "2019-07-10T09:48:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to omit a complete specification of try-and-increment since we're aiming for constant-time algorithms. ",
          "createdAt": "2019-07-10T21:43:30Z",
          "updatedAt": "2019-07-10T21:43:30Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We decided to omit a complete specification of try-and-increment\r\n\r\nI'm not asking for a specification of try-and-increment. I'm asking for a rationale for *not* specifying try-and-increment.",
          "createdAt": "2019-07-10T21:51:33Z",
          "updatedAt": "2019-07-10T21:51:33Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU0Njg4MTU0MTU=",
      "title": "cover S--vdW at least for j=0 and j=1728 cases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/155",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In [this post](https://mailarchive.ietf.org/arch/msg/cfrg/gFn3tvf62e1FKx_SkVXk8hsSVig), Dan Harkins points out (in essence) that the draft isn't clear on how to apply S--vdW to the case where j-invariant is 1728.\r\n\r\nIt would be nice to make S--vdW clear on this point, since it's effectively the \"method of last resort\": it will always work, even when some other method won't.",
      "createdAt": "2019-07-16T19:04:38Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See [this document](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/raw/generalized_svdw/svdw_general.pdf) for proposed parameterization of S--vdW that can be easily (well, in a relative sense) applied to any curve.",
          "createdAt": "2019-08-02T14:51:43Z",
          "updatedAt": "2019-08-02T14:51:43Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed #167 following both Fouque-Tibouchi (FT) and Riad's approaches to derive explicit formulas for S-vdW.  PDF file: ([math/sw.pdf](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/a0c68c9c78e67d5019e7aa3659e5a9f0af2ba29a/math/sw.pdf)) with the derivation. \r\n\r\nThe formulas works for any A,B provided there exist a parameter u that holds certain conditions.\r\n\r\nDeriving formulas as FT has the advantage that the image size was already bounded, and it was also proved that such a mapping is admissible, which helps to get indifferentiability.\r\nExample: when E is a BN curve and u=1, it reduces to FT formulas from Latincrypt'12.\r\n\r\n",
          "createdAt": "2019-09-19T00:42:49Z",
          "updatedAt": "2019-09-19T00:48:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Wait, so: does the document cover the FT formula or the alternate derivation that I proposed? Or are you saying it somehow covers both? (if so, that seems unnecessary...)\r\n\r\nTo be clear: SvdW06 gives a lower bound on image size for any instantiation of their map, which is sufficient for admissability, so FT12 doesn't have any advantage in this regard as far as I can tell.\r\n\r\nOn the other hand (as I'm sure you know) the FT12 formula does not work when a = 0 and p != 1 mod 3, which is what motivated the alternate derivation.\r\n\r\nIn any case, my vote is for the simplest possible description of SvdW.\r\n\r\n(I don't have cycles this week, but next week I will have time to take a careful look at #167)",
          "createdAt": "2019-09-19T01:25:17Z",
          "updatedAt": "2019-10-10T04:28:34Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU0Njg4OTUwMzU=",
      "title": "IPR issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/156",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bjoern Haase has filed an IPR notice for Icart's algorithm.\r\n\r\nThere is also some concern that Simplified SWU with Z = -1 is covered by a patent. We may wish to sidestep this issue by specifying that Z != -1 for Simplified SWU.\r\n\r\nGiven the patent issues with Icart, we probably want to switch P-384 from Icart's algorithm to Simplified SWU with Z = -2.",
      "createdAt": "2019-07-16T22:17:41Z",
      "updatedAt": "2019-10-23T03:54:16Z",
      "closedAt": "2019-10-23T03:54:16Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "All the concrete actions in this issue are now comprehended.",
          "createdAt": "2019-10-23T03:54:16Z",
          "updatedAt": "2019-10-23T03:54:16Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU0NzE1MDE4Nzk=",
      "title": "define sign of sqrt in constants for S-vdW and others",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/157",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some of the maps use constants whose definitions include sqrts. The document should specify for these that the intended constant value is the one computed for the \"positive\" sqrt branch, i.e., the value `c = sqrt(something)` such that `sgn0(c) == 1` to avoid ambiguity about the value of `c`.",
      "createdAt": "2019-07-23T06:04:56Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree, also each named suite should state explicitly the set of constants used for a given curve.",
          "createdAt": "2019-07-30T01:34:02Z",
          "updatedAt": "2019-07-30T01:34:02Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU0NzE1MDMzMjA=",
      "title": "consider using WB19 approach for secp256k1 (and others?)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/158",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "secp256k1 is currently specified using Shallue and van de Woestijne. In general it's much cheaper to use the technique from WB19, i.e., map to an isogenous curve and then evaluate the isogeny map. For secp256k1, there are curves 3-isogenous to secp256k1 with nonzero j-invariant in the base field. It probably makes sense to leverage these for a (3x) faster mapping than S-vdW.",
      "createdAt": "2019-07-23T06:10:12Z",
      "updatedAt": "2019-10-26T19:16:29Z",
      "closedAt": "2019-10-26T19:16:29Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(BN curves from the pairing-friendly draft probably want to use WB19, too)",
          "createdAt": "2019-07-23T06:11:06Z",
          "updatedAt": "2019-07-23T06:11:06Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU0NzE5MDIzMTc=",
      "title": "Z selection pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/159",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We may want to include pseudocode that outputs Z for a given map, curve params, etc., to ensure that everyone arrives at the same value!",
      "createdAt": "2019-07-23T19:54:52Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": []
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NzI5ODk0MDA=",
      "title": "suites specify W for hash_to_base, should be L",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/160",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "see title. Just need to harmonize this in suites. Oops!!!",
      "createdAt": "2019-07-25T17:42:10Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": []
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU0NzYyMTc1MDM=",
      "title": "ensure that suite names are prefix-free",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/161",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@hoeteck suggests out-of-band that it will be useful to have prefix-free ciphersuite names in case upper-level protocols want to include those suite names in their domain separation strings.\r\n\r\nOne easy way to do this is to add a trailing hyphen (e.g., \"P256-SHA256-SSWU-RO-\"). Probably reasonable to add as cheap insurance against misuse.",
      "createdAt": "2019-08-02T14:48:02Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, this may also have bearing on #140: probably we *don't* want to add a `-V2-` suffix, since then one csuite is a prefix of another.\r\n\r\nA couple obvious possibilities:\r\n\r\n1.  We could add a version field now, e.g., \"P256-SHA256-SSWU-RO-V0-\"\r\n2.  We could use a different separator than hyphen if we want to add a version number in the future. In particular, \"P256-SHA256-SSWU-RO_V2-\" avoids the prefix issue. So does \"P256:V2-SHA256-SSWU-RO-\". Lots of options here.\r\n\r\nThe first one is maybe aesthetically nicer, whereas something like the second one doesn't require us to anticipate every possible need right now. To me it seems like there are enough workarounds that we should do something approximating the second, not the first.",
          "createdAt": "2019-08-02T14:58:02Z",
          "updatedAt": "2019-08-02T14:58:02Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "MDU6SXNzdWU0NzYyMjQwNDA=",
      "title": "make sure \"H2C\" is unambiguous in hash_to_base",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/162",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "May want to specify that \"H2C\" is the sequence of bytes 0x48, 0x32, 0x43, i.e., the ASCII/UTF-8 encoding of the string.",
      "createdAt": "2019-08-02T15:00:46Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": []
    },
    {
      "number": 164,
      "id": "MDU6SXNzdWU0NzkzMTc0NjU=",
      "title": "404 link in readme",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/164",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "[Compare Editor's Copy to Individual Draft](https://cfrg.github.io/draft-irtf-cfrg-hash-to-curve/draft-irtf-cfrg-hash-to-curve.diff) points to a 404",
      "createdAt": "2019-08-11T00:05:19Z",
      "updatedAt": "2019-10-27T01:23:39Z",
      "closedAt": "2019-10-27T01:23:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed!",
          "createdAt": "2019-10-27T01:23:36Z",
          "updatedAt": "2019-10-27T01:23:36Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWU0ODA5MzU2NTI=",
      "title": "Support for SHA-3 and SHAKE / cSHAKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/165",
      "state": "CLOSED",
      "author": "mimoo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft only seems to standardize the algorithms with SHA-2. I'd like to see support for SHA-3 and SHAKE (and cSHAKE) if possible so that we don't have to write an extension/another RFC later on.\r\n\r\nusing cSHAKE would allow to replace the hash and HKDF with one algorithm.",
      "createdAt": "2019-08-14T23:48:05Z",
      "updatedAt": "2019-10-30T16:29:51Z",
      "closedAt": "2019-10-30T16:29:51Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for bringing this up!\r\n\r\nThe SHA-3 part of this request appears to be easily handled by creating a ciphersuite (but please let me know if this does not seem correct). As such, it shouldn't require an extension or another RFC even if we don't specify SHA-3--based suites.\r\n\r\nRegarding (c)SHAKE:\r\n\r\nI'm sure you're aware of my comments in the other thread, but for the sake of completeness, here's a link: cfrg/draft-irtf-cfrg-bls-signature#10. To rehash and slightly expand my comments there:\r\n\r\nTo me it does not appear that there's a compelling reason to use (c)SHAKE rather than HKDF:\r\n\r\n- HKDF works just fine for SHA-3; in contrast, there's no sensible notion of \"compatibility\" between SHA-2 and (c)SHAKE.\r\n\r\n- (c)SHAKE is slightly cheaper than HKDF-SHA3, but there's categorically no reason to optimize the cost of HKDF invocations in hash-to-curve---that cost is fully in the noise.\r\n\r\n- The hash-to-curve draft is already quite complex. From my perspective, the bar is very high for specifying multiple KDFs given that HKDF already works for everything.\r\n\r\n- I'm aware of and reasonably sympathetic to the argument that some codebases will already have a (c)SHAKE implementation and won't want to add HKDF, but I'm skeptical of the practical benefit given that there are compact and extremely mature implementations of HKDF, whereas (c)SHAKE is new and comparatively obscure.\r\n\r\nBut: let's discuss further! Opinions are made to be changed :)\r\n\r\nCC @chris-wood @armfazh ",
          "createdAt": "2019-08-15T19:19:07Z",
          "updatedAt": "2019-08-15T19:19:07Z"
        },
        {
          "author": "mimoo",
          "authorAssociation": "NONE",
          "body": "Hey @kwantam thanks for the response!\r\n\r\n> The hash-to-curve draft is already quite complex. From my perspective, the bar is very high for specifying multiple KDFs given that HKDF already works for everything.\r\n\r\nI can agree that supporting more algorithms means having a more complex specification. I'm usually against making a specification more complex. So for once, I'm going to support a side I'm not used to support :)\r\n\r\nBut I have good arguments!\r\n\r\nThe reason is that we are investigating using cSHAKE in place of hash functions, KDFs, and so on. and getting rid of dependencies we don't need. If this draft would switch to cSHAKE exclusively, it would actually be much simpler than the current one.\r\n\r\n> HKDF works just fine for SHA-3; in contrast, there's no sensible notion of \"compatibility\" between SHA-2 and (c)SHAKE.\r\n\r\nIt is true that HKDF works fine for SHA-3/SHAKE, but it also makes little sense to implement it on top of something that already provides pretty much the same API as HKDF. Realistically, we are probably going to just use (c)SHAKE instead and risk diverging from the specification. How costly would it be to add HKDF to the name of the ciphersuite?\r\n\r\n> I'm skeptical of the practical benefit given that there are compact and extremely mature implementations of HKDF, whereas (c)SHAKE is new and comparatively obscure.\r\n\r\ncSHAKE is pretty much the same construction as SHA-3. So I wouldn't say obscure. If we talk about support from libraries, then I agree.\r\n\r\n",
          "createdAt": "2019-08-15T19:52:22Z",
          "updatedAt": "2019-08-15T19:54:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@mimoo thanks for the clarifications :+1:\r\n\r\n> The reason is that we are investigating using cSHAKE in place of hash functions, KDFs, and so on. and getting rid of dependencies we don't need. If this draft would switch to cSHAKE exclusively, it would actually be much simpler than the current one.\r\n\r\nObviously it's easy to disagree about what qualifies as \"much simpler,\" but count me as strongly skeptical. The maximum possible simplification would be obtained by replacing HKDF-`H` with cSHAKE256. But let's think about how much that actually simplifies the document:\r\n\r\n- It doesn't significantly simplify the hash-to-base-field section. At best, it means that we could get rid of the discussion of `H`'s output length.\r\n\r\n- It doesn't significantly simplify the ciphersuites. At best, it means that we could remove `H`.\r\n\r\nMoreover, note that the above simplifications are not intrinsic to the choice of cSHAKE: we could instead require everyone to use HKDF-SHA2-512, whereupon we'd also get the above simplifications. So the claim about simplification appears to be a generic argument for fixing one hash function, not an argument for using cSHAKE.\r\n\r\nBut beyond that, to first order there does not appear to be *any* interest in using SHA-3 other than yours (please interpret \"yours\" broadly---I surmise that you are speaking on behalf of your employer). So you can certainly understand how from my perspective the suggestion to require everyone to use SHA-3 isn't even remotely plausible. This means that the only option is to specify multiple KDFs, and that is *not* a simplification.\r\n\r\nIn other words, specifying cSHAKE would, under any remotely plausible interpretation, dramatically increase the complexity of the standard.\r\n\r\n> It is true that HKDF works fine for SHA-3/SHAKE, but it also makes little sense to implement it on top of something that already provides pretty much the same API as HKDF.\r\n\r\nAs far as I can tell, the above effectively restates the argument that it's more efficient to use cSHAKE than to use HKDF-SHA3. In a narrow sense, there's no doubt that this is true.\r\n\r\n(EDIT: to be clear: SHA-3 *does not* provide the same API as HKDF. cSHAKE does, but no one is arguing to use cSHAKE inside HKDF.)\r\n\r\nBut in the broader context of the standard, the more important question is: how does the cost/benefit of using HKDF-SHA3 compare to the cost/benefit of specifying multiple KDFs? And there, it seems to me that the cost of HKDF-SHA3 vs cSHAKE is effectively zero (because the cost of the hashing is in the noise), whereas the cost of specifying multiple KDFs is high (because it increases the complexity of the document).\r\n\r\nSo to me, what you say in the quote above is articulating an aesthetic preference, not a technical justification.\r\n\r\n> Realistically, we are probably going to just use (c)SHAKE instead and risk diverging from the specification. How costly would it be to add HKDF to the name of the ciphersuite?\r\n\r\nThis appears to be a statement that you have no intention of following the standard unless the document is modified to reflect what you've already decided to do. (Please correct me if I'm wrong.)\r\n\r\nI want to be clear: that is a totally fine decision, though I hope you do not follow that course.\r\n\r\nIn any case, I'm sure you can see that, from my perspective, this is not a persuasive argument either for or against change: since everyone else who is currently implementing (to my knownedge) prefers to use HKDF-SHA2, either choice means that *someone* will violate the standard.\r\n\r\n> cSHAKE is pretty much the same construction as SHA-3.\r\n\r\nExactly! and I have no hesitation in claiming that compared to HKDF and SHA-2, SHA-3 is obscure.\r\n\r\nBut the point is: even if SHA-3 were *exactly* as popular as SHA-2 (which certainly isn't true now, and indeed may never become true), that would not be enough to justify ruling out the use of SHA-2 in the standard.\r\n\r\nMeanwhile, the current standard explicitly provides for the use of SHA-3 (see #137). Yes, it is very slightly sub-optimal. But please see above regarding aesthetic vs technical justifications.",
          "createdAt": "2019-08-15T21:18:54Z",
          "updatedAt": "2019-08-15T21:23:43Z"
        },
        {
          "author": "mimoo",
          "authorAssociation": "NONE",
          "body": "I think I can agree with most of your points. I still think that if we're writing an RFC today, it doesn't make sense to not include SHA-3 or constructions that will probably grow or even replace the current ones in the future.\r\n\r\n> everyone else who is currently implementing\r\n\r\nhow many people are doing this? It sounds like one request is already a pretty big percentage :D",
          "createdAt": "2019-08-15T21:31:24Z",
          "updatedAt": "2019-08-15T21:31:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the quick response :+1:\r\n\r\n> I still think that if we're writing an RFC today, it doesn't make sense to not include SHA-3 or constructions that will probably grow or even replace the current ones in the future.\r\n\r\nWith apologies (I may be misinterpreting), the above appears to be saying that nothing short of fully optimizing for SHA-3 (in this case, by using SHAKE rather than HKDF) counts as \"including\" it in the standard. If indeed that's what the statement means, I think it's reasonable to regard that as a tendentious characterization.\r\n\r\nWe certainly *do* consider SHA-3 important, and the current document is perfectly compatible with its use. If it would be helpful for us to explicitly list ciphersuites and test vectors for SHA-3, that's absolutely something we will consider! (but I'm sure you can understand that I can't promise to do it before consulting with my co-authors).\r\n\r\n> how many people are doing this? It sounds like one request is already a pretty big percentage :D\r\n\r\nAs @JustinDrake [points out](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/10#issuecomment-521440891), everyone who has been participating in the bi-weekly BLS signatures teleconference appears to prefer some variant of SHA-2. Concretely, the [BLS sigs README](https://github.com/cfrg/draft-irtf-cfrg-bls-signature) lists a few reference implementations, and those are all using SHA-2.",
          "createdAt": "2019-08-15T21:49:14Z",
          "updatedAt": "2019-08-16T02:08:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> How costly would it be to add HKDF to the name of the ciphersuite?\r\n\r\nBy the way, a small suggestion:\r\n\r\nIf you prefer to specify a ciphersuite that uses cSHAKE instead of HKDF, I'd recommend indicating this in the ciphersuite ID to avoid confusion. For example, you might consider ciphersuite names simliar to the following:\r\n\r\n    BLS12381G1-SHA3256-SSWU-RO:KDF=cSHAKE-\r\n\r\nOr perhaps\r\n\r\n    BLS12381G1-SHA3256:KDF=cSHAKE-SSWU-RO-\r\n\r\nThis will help ensure orthogonality to folks using HKDF-SHA3.",
          "createdAt": "2019-08-15T21:56:50Z",
          "updatedAt": "2019-08-16T02:09:30Z"
        },
        {
          "author": "mimoo",
          "authorAssociation": "NONE",
          "body": "> With apologies (I may be misinterpreting), this appears to be saying that nothing short of fully optimizing for SHA-3 counts as including it. I think it's reasonable to regard this as a tendentious characterization.\r\n\r\nNot sure I understand this paragraph\r\n\r\n> If it would be helpful for us to explicitly list ciphersuites and test vectors for SHA-3, that's absolutely something we will consider\r\n\r\ncool!",
          "createdAt": "2019-08-15T22:54:07Z",
          "updatedAt": "2019-08-15T22:54:07Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I'd personally suggest specifying only for cloneable XoFs like SHAKE128 and Blake2x but relegate HKDF to some legacy algorithms appendix, but yeah the speed does not matter here.  It's possible memory usage matters for some very small devices, but those can always do something custom.",
          "createdAt": "2019-08-18T10:12:58Z",
          "updatedAt": "2019-08-18T10:12:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm leaning towards adding some words in the document (maybe in the hash_to_base section, or in the ciphersuites section) about how one could define new suites that use variants of hash_to_base, e.g., built on different PRGs.\r\n\r\nI'm really not inclined to define multiple hash_to_base variants because of issues with exploding complexity. But on the other hand, doing it now means that we can try and make sure that domain separation is done correctly, etc...",
          "createdAt": "2019-10-13T05:31:04Z",
          "updatedAt": "2019-10-13T05:31:04Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWU0ODI0NDMyOTQ=",
      "title": "cofactor clearing pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/166",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I ran into @mmaker at CRYPTO, who suggested that including pseudocode for fast cofactor clearing for BLS12-381 would be a nice addition to the document and probably wouldn't be all that complicated.\r\n\r\nI tend to agree---certainly if we're going to have optimized pcode in the appendix, there's a good argument for including this...\r\n\r\nThoughts?",
      "createdAt": "2019-08-19T17:46:24Z",
      "updatedAt": "2020-04-17T23:13:07Z",
      "closedAt": "2020-04-17T23:13:07Z",
      "comments": [
        {
          "author": "kirk-baird",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it would be good to have the co-factor clearing as it would make it easier for others to implement, hence gain popularity as opposed to multiplication by the co-factor.",
          "createdAt": "2019-08-30T04:29:31Z",
          "updatedAt": "2019-08-30T04:29:31Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In an attempt of helping you guys out, here's how I would personally do it:\r\n```sage\r\nq = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\r\nr = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\r\nx = -0xd201000000010000\r\n\r\nZq = GF(q)\r\nZq2.<i> = GF(q^2, modulus=[1, 0, 1])\r\nu = i+1\r\n\r\nE2 = EllipticCurve(Zq2, [0, 4*u])\r\nE1 = EllipticCurve(Zq, [0, 4])\r\n```\r\n\r\nHere I define the map \u03c8:\r\n```sage\r\ndef psi(P):\r\n    x, y = P.xy()\r\n    return E2(x.frobenius()/(u^((q-1)/3)), y.frobenius()/u^((q-1)/2))\r\n\r\ndef psi2(P):\r\n    # return psi(psi(P))\r\n    x, y = P.xy()\r\n    return E2(x.frobenius(2)/Zq(2)^((q-1)/3), -y.frobenius(2))\r\n```\r\nHere is Scott: \r\n```sage\r\ndef mul_cofactor_s(P):\r\n    return (x^3-x^2-x+4)*P + (x^3-x^2-x+1)*psi(P) + (-x^2+2*x-1)*psi2(P)\r\n```\r\n\r\nHere is budroni-pintore:\r\n```sage\r\ndef mul_cofactor_bp(P):\r\n    return (x^2-x-1)*P + (x-1)*psi(P) + 2*psi2(P)\r\n```\r\n\r\nThen I guess most software developers will notice themselves that, if willing, one can precompute all those constants. lmk if there's any way I can help you out integrating this to the draft!",
          "createdAt": "2019-09-02T20:21:02Z",
          "updatedAt": "2019-09-02T23:36:46Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your contribution @mmaker .",
          "createdAt": "2019-09-03T17:17:19Z",
          "updatedAt": "2019-09-03T17:17:19Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @kwantam ! \r\nI tried to sketch a cofactor multiplication section in the appendix, see: https://github.com/mmaker/draft-irtf-cfrg-hash-to-curve/commit/43bd8fc7a4310115e6accc19b2f9f1360a0778b4.\r\nI encountered a couple difficulties you might help me out resolve: \r\n\r\n- inconsistencies: \r\n   - citation sometimes are separated by \\n\\n, sometimes by \\n. Sometimes indentation is different. Which one should I use? Mind if I make them all uniform in separate pull request? Also editorial keys seem inconsistent sometimes. \r\n  -  the code is standard python, while I'm using sage. The example implementation (i.e. `poc/`) uses sage. What should I use? The RFC is not going to be more clear if we add add finite field extensions and Frobenius mapping in pure python.\r\n- there's no place where BLS12-381 constants are defined. Actually, at this stage of the draft curve BLS12-381 is just mentioned. Wouldn't it be more appropriate to move this to the BLS draft where hashing to BLS12-381 is defined, at this point? \r\n- after some thinking, I don't see any reason for adopting Scott's method given there's a much better method. Are you okay with me not reporting it?",
          "createdAt": "2019-09-08T21:45:52Z",
          "updatedAt": "2019-09-08T21:46:10Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ping?\r\n(the BLS draft uses hashing into G1, so\u2026 that was a bad idea. But the issue remains.)\r\n",
          "createdAt": "2019-10-02T13:54:17Z",
          "updatedAt": "2019-10-02T13:55:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay. I'm catching up on some straggling work elsewhere and hope to return to this in the next couple days. Thanks for the contribution---and for your patience with me :)",
          "createdAt": "2019-10-02T18:24:59Z",
          "updatedAt": "2019-10-02T18:24:59Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ping?\r\n\r\n(No worries :P)",
          "createdAt": "2019-10-14T14:29:29Z",
          "updatedAt": "2019-10-14T14:29:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry! I will have time to look in more detail in the next few days.\r\n\r\nBut, some quick answers:\r\n\r\n1. I'm sure there are plenty of inconsistencies. We'd love a PR for bib cleanup, but I understand that's a big and not particularly pleasant undertaking, so don't feel bad if you'd rather spend time on other things :)\r\n    \r\n    As far as code goes, I thought the poc/ code *was* in sage, no? There's some python in there, but I think all of it actually gets executed in Sage. I thought...\r\n\r\n2. Yes, I think probably in the end all of this BLS12-381--specific info wants to be in the pairings draft, not here. That may also go for the isogeny constants that we currently specify in the appendix.\r\n\r\n3. Which method do you mean by Scott's? Do you mean the method of clearing the cofactor on G1 that requires multiplication by a smaller value than h, or do you mean [SBCDK09]?",
          "createdAt": "2019-10-14T18:27:07Z",
          "updatedAt": "2019-10-14T18:27:45Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Riad: thanks for the partial answer: \r\n\r\n1. alright\r\n2. I see some python for defining prime field operations. If this chunk of code is executed in sage, there's more appropriate data structures! e.g in my code above I am able to do mod p operations, but I don't have to define them all over again like in here:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/poc/fouquetibouchi_hacspec.py\r\nhence, I thought this was meant for execution outside sage? (the file extension is also different) \r\n3. Yes, I mean that \"[SBCDK09]\" is not relevant for the spec. I'm proposing we just explain Fuentes et al.'s method as presented in Budroni-Pintore",
          "createdAt": "2019-10-16T14:51:53Z",
          "updatedAt": "2019-10-16T14:53:15Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right. It's safe to regard the hacpsec stuff as legacy. We might get back to using it eventually, but I'd say just go with sage and we'll deal with porting if/when we decide to use hacspec again.",
          "createdAt": "2019-10-16T14:58:12Z",
          "updatedAt": "2019-10-16T14:58:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "closing since we merged #232",
          "createdAt": "2020-04-17T23:13:03Z",
          "updatedAt": "2020-04-17T23:13:03Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU1MDgwNzc1MjM=",
      "title": "require Z != -1 for s-swu",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/171",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This avoids infringing US patent 8712038.",
      "createdAt": "2019-10-16T20:20:37Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #156",
          "createdAt": "2019-10-16T21:34:43Z",
          "updatedAt": "2019-10-16T21:34:43Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For patent issues would it make sense to explain the restrictions and explicitly link to the relevant patents? This would serve several purposes:\r\n\r\n1) Provide context behind the standardisation decisions.\r\n2) Help implementers avoid using patented ideas.\r\n2) Help implementers use the patented ideas once the patent has expired. (For example, [US7110538](https://patents.google.com/patent/US7110538) is due to expire soon.)",
          "createdAt": "2019-10-17T04:04:02Z",
          "updatedAt": "2019-10-17T04:04:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question! I think it would be a nice idea, but the IETF [specifically disallows this](https://tools.ietf.org/html/rfc3668#section-11).\r\n\r\nThe correct way to do this, I believe, is to file a separate IPR disclosure form, and include the rationale in the comments on that form.\r\n\r\nI posted an [updated proposal](https://mailarchive.ietf.org/arch/msg/cfrg/jV4Wr4fbMKkd4vzsbEhKbous16Y) for entirely avoiding the S-SWU patents. I will update the document with the newest procedure, and then update the IPR disclosures with the corresponding rationale.",
          "createdAt": "2019-10-21T00:22:02Z",
          "updatedAt": "2019-10-21T00:22:02Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU1MTE1ODcyNjU=",
      "title": "proposal: remove the maps to supersingular curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/173",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "At this point we don't have any clear examples of when people would want to do this.\r\n\r\nIt might become the case in the future that someone wants to do it. If so, it would be easy to create a new document that incorporates all of h2c by reference and specifies Boneh-Franklin and/or Ell2-A0.\r\n\r\nThe advantage of getting rid of them here is reducing confusion and reducing document surface area. To me this is a win.\r\n\r\nThoughts?\r\n\r\nCC @grittygrease @armfazh @chris-wood @JustinDrake",
      "createdAt": "2019-10-23T21:41:53Z",
      "updatedAt": "2020-01-23T22:28:59Z",
      "closedAt": "2020-01-23T22:28:58Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Among the verifiable delay function designs, the [most powerful candidate](https://eprint.iacr.org/2019/166) involves hashing to a supersingular curve, even a randomly chosen supersingular curve.  Just fyi, the isogenies VDF is the most powerful candidate in the sense that it provides a strictly more functionality than any other VDF design.  VDFs are an extremely niche construction though, so you should probably still remove hashing to supersingular curves. ",
          "createdAt": "2019-10-26T09:03:46Z",
          "updatedAt": "2019-10-26T09:03:46Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it provides a strictly more functionality than any other VDF design\r\n\r\nCan you elaborate? :)",
          "createdAt": "2019-10-26T10:09:50Z",
          "updatedAt": "2019-10-26T10:09:50Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@burdges great, thanks for pointing this out!\r\n\r\n(I now dimly remember reading this paper...)",
          "createdAt": "2019-10-26T20:42:42Z",
          "updatedAt": "2019-10-26T20:42:42Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "@JustinDrake At least two pairing based protocols are transformed by using a isogeny with known running time T and a bound A on the adversarial advantage: \r\n\r\nFirst, BLS signatures gives you the basic VDF itself from that paper.\r\n\r\nSecond, if you consider that VDF output as the identity-based secret key in an identity-based encryption scheme, with master secret key the VDF isogeny, then anyone can encrypt to the eventual evaluation of the VDF after it starts but before T/A.  \r\n\r\nIt's a true \"encrypt to the near future\" protocol.  All the conventional time-lock puzzles permit encryption into the further future beyond T/A, but because they do not share one evaluation track, they only really work for very high value data, which makes them useless.  In particular time-lock puzzles cost way too much for voting protocols, while an isogenies VDF replaces the trusted parties who open votes.\r\n\r\nIn principle, one could transform other pairing-based protocols similarly.  We must avoid too many isogenies running in parallel though, so not sure how many others really yield anything interesting.  ",
          "createdAt": "2019-10-27T10:29:54Z",
          "updatedAt": "2019-10-27T10:34:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@burdges going back and looking again, it's not totally clear to me that the supersingular mappings in the draft are necessary or all that helpful for the VDF application. The reason is, the B-F and Ell2A=0 maps only work for subsets of all supersingular curves, and it's not obvious to me whether one would choose a curve from one of those subsets as the starting point of the VDF. In other words, it's easy to imagine needing a map other than one of the supersingular-specific ones when implementing this VDF.\r\n\r\n(Of course, maybe one would intentionally choose a curve that's easy to hash to... not clear to me.)",
          "createdAt": "2019-10-29T21:37:11Z",
          "updatedAt": "2019-10-29T21:37:11Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "There are larger constraints like the divisors of the group order, so you cannot necessarily choose from any particular family. ",
          "createdAt": "2019-10-29T23:10:25Z",
          "updatedAt": "2019-10-29T23:10:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I spoke with Luca De Feo about this VDF at [ECC19](https://eccworkshop.org/2019/), and in the process realized that in fact one cannot use a curve with j=1728 or j=0 because it's crucial that no one know the structure of the endomorphism ring of the starting curve (or they can shortcut the VDF). Missed that the first time or forgot it along the way...\r\n\r\nSo neither of the maps apply to that VDF.\r\n\r\nIn principle they might apply to CSIDH, CSI-FiSh, or related schemes, where the starting curve can indeed have j=1728 or j=0, but as far as I know no such scheme requires hashing to points on curves.\r\n\r\nI also gave a talk on hashing to curves at ECC19 and, in the process, asked the audience if there were any known schemes that needed to hash to such curves. The response generally seemed to be \"no\".\r\n\r\nSo my guess is that these schemes would not be missed if we didn't include them in this standard. But maybe the cost is not so much. If we want to give test vectors, perhaps we can use curves with j=1728 and j=0 over the CSIDH p512 prime, which is defined as \r\n\r\n    p512 = 4 * prod(first 73 odd primes) * 587 - 1",
          "createdAt": "2019-12-06T19:08:40Z",
          "updatedAt": "2019-12-06T19:09:43Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Yes true, I missed the maps depended upon j=1728 or j=0, at least when thinking about VDFs.  \r\n\r\nAfaik, any interesting protocol based on both isogenies and pairings will need curves that cannot be reached from j=1728 or j=0 because the pairings occur on multiple curves with at least one of the curves behind some secret isogeny.  I doubt hasing-to-the-curve helps much with post quantum protocols too. ",
          "createdAt": "2019-12-07T00:55:32Z",
          "updatedAt": "2019-12-07T00:55:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Chiming in late: given the discussion above, and the fact that this can always be done in a future document, I'd advocate for removing hashing to supersingular curves. @kwantam if you still think this is the right thing to do, I can put together a PR to drop them. (@armfazh, what do you think?)",
          "createdAt": "2020-01-20T22:41:33Z",
          "updatedAt": "2020-01-20T22:41:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd still like to do this. I need to double check, but I think #198 is basically ready to go.",
          "createdAt": "2020-01-20T23:30:21Z",
          "updatedAt": "2020-01-20T23:30:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing via #198",
          "createdAt": "2020-01-23T22:28:58Z",
          "updatedAt": "2020-01-23T22:28:58Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWU1MTIxNTczODc=",
      "title": "meta-issue: triage for Singapore IETF meeting",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/174",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The next IETF meeting in Singapore happens soon. The cutoff for submitting a new I-D is [November 4th at 23:59 UTC](https://datatracker.ietf.org/meeting/106/important-dates/). This issue is to help with triage.\r\n\r\n# High priority\r\n\r\n- [x] Z selection (#159, #171, #172) --- PR is merged (#172)\r\n\r\n- [x] SvdW update (#155, #157, #172) --- PR is merged (#172)\r\n\r\n- [x] Ciphersuite updates (#158) --- PR is merged (#172)\r\n\r\n- [x] sgn0 / sqrt definitions (#144) --- ~~I've got a PR in the wings for this. I'll push it to completion and submit it in the next couple days.~~ PIR is merged (#176)\r\n\r\n- [ ] Coordinate with Ristretto --- can happen before or after. Main goal is to figure out what the right API is, both for Ristretto and for whichever pieces of h2c the Ristretto draft uses.\r\n\r\n- [x] Coordinate with VRF --- I've opened a pull request (fcelda/nsec5-draft#35) against VRF for this. Probably safe to assume we'll coordinate there for this.\r\n\r\n# Nice to have\r\n\r\n- [ ] Handle some out-of-band comments from emails (some of these haven't been translated to issues)\r\n\r\n- [x] Discussion of alternative hash_to_base algorithms (#165) --- probably just want a paragraph in Suites talking about how to indicate that a suite uses an alternative hash_to_base (e.g., SHAKE). PR is merged (#175)\r\n\r\n- [x] Style nits (#105) --- might be nice to do a sweep for these, if there's time.\r\n\r\n- [ ] Variable naming nits (#110) --- same as above.\r\n\r\n# Not now\r\n\r\n- [ ] cofactor clearing pseudocode (#166) --- I think this probably goes in the pairings draft, not ours, right?\r\n\r\n- [x] #164 --- only pertains to the repo, not the draft\r\n\r\n- [ ] Decide on removing supersingular maps (#173) - I'd like to talk to some more folks before we make a decision on this. I'm going to be at the ECC Workshop in December---maybe some people there have an opinion.\r\n\r\n- [ ] Flow-chart (#63, #118) - nice to have, but probably doesn't go inside the draft, so we can push this to later.\r\n\r\n- [ ] Code clean-up (#98, #112, #151) --- hate to keep kicking this can down the road, but we've got enough on our plates and I doubt there's time. (This also includes test vectors...)\r\n\r\n# Issues that can be closed right now\r\n\r\nI think all of the following can be closed without further action. Please reply if you disagree.\r\n\r\n- [x] #43 - Ristretto will handle this\r\n- [x] #95 - Suites now handle this\r\n- [x] #96 - BLS sigs draft now handles this\r\n- [x] #107 - we now discuss the relevant conversions\r\n- [x] #109 - we decided to do projective in the appendices and affine in the body\r\n- [x] #111 - we decided to do generic straight-line in body text, specific appendix\r\n- [x] #124 - we've decided on a plan here, and it's in the text\r\n- [x] #126 - I think we've got a plan here, too",
      "createdAt": "2019-10-24T20:13:43Z",
      "updatedAt": "2019-11-05T07:18:53Z",
      "closedAt": "2019-11-05T07:18:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "CC @chris-wood @armfazh please let me know whether you think any of the \"issues that can be closed\" above should stay open.\r\n\r\nI'm going to have new PRs to handle most of the \"high priority\" issues in the next few days. My plan was mostly to rely on y'all for reviewing, if that's OK.",
          "createdAt": "2019-10-24T20:15:51Z",
          "updatedAt": "2019-10-24T20:15:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I'm fine with closing those ones, and I'm happy to review the high priority issues as they come in. I'll fix #164 and work on code quality and test vectors from our Sage implementations. I'll also claim #105 and #110.",
          "createdAt": "2019-10-24T20:19:32Z",
          "updatedAt": "2019-10-24T20:19:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I spoke with @reyzin about incorporating hash-to-curve by reference in the next version of the VRF document. The plan is to push ahead with edits to VRF after we've pushed draft-05. I'll plan to put together a PR against VRF at that time.",
          "createdAt": "2019-10-29T18:30:02Z",
          "updatedAt": "2019-10-29T18:30:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We've pushed -05, so this issue is done. We'll bring remaining issues forward on the next push.",
          "createdAt": "2019-11-05T07:18:52Z",
          "updatedAt": "2019-11-05T07:18:52Z"
        }
      ]
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWU1MTI5MjYwNTY=",
      "title": "suites: optimized impls in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/181",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now we have only the P-256, curve/edwards25519, and curve/edwards448.\r\n\r\nTODO: add others\r\n\r\n- [x] P-384\r\n- [x] P-521\r\n- [x] SECP256k1\r\n- [x] BLS12-381 G1\r\n- [x] BLS12-381 G2\r\n- [x] SSWU for p = 5 mod 8 --- no specific curves in mind, but in principle they could exist (e.g., M-221 converted to short Weierstrass)\r\n\r\nThe potential optimizations for Shallue-van de Woestijne are pretty minimal, so I am assuming that for all of the above we would give straight-line impls only of Simplified SWU. Glad to consider doing otherwise, though.",
      "createdAt": "2019-10-27T06:13:12Z",
      "updatedAt": "2020-04-20T18:12:04Z",
      "closedAt": "2020-04-20T18:12:04Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#183 handles P-384 and P-521 for S-SWU. ~~(Actually, maybe it should also be used for secp256k1...)~~\r\n\r\nUpdated to handle secp256k1, too.\r\n\r\n~~(Hmm, and it should also handle BLS12-381 G1...)~~\r\n\r\nUpdated to handle BLS12-381 G1, too.",
          "createdAt": "2019-10-28T00:07:35Z",
          "updatedAt": "2019-10-28T06:10:43Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assuming that this is about appendix D, on vaguely related note, there is typo in commentary to step 23 in map_to_curve_simple_swu_3mod4. It currently reads `... -10 * u^2 * x1n ...` when it should read `... Z * u^2 * x1n ...`.",
          "createdAt": "2020-03-01T16:20:02Z",
          "updatedAt": "2020-03-01T16:20:02Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWU1MTgxMTU3MzI=",
      "title": "is_square for field extensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/190",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Michael Scott points out (citing El Mrabet and Joye's book, which cites [Adj and Rodriguez-Henriquez](https://eprint.iacr.org/2012/685)) that is_square can be computed more cheaply than an exponentiation in extension fields.\r\n\r\nThe idea is that, for (a0, a1) = a in F(p^2), is_square(a) = is_square(|a|) over F(p), where |a| = a0^2 + a1^2. For an extension tower at least, one assumes this can be done recursively.\r\n\r\nAt the very least we should cite the AR-H12 paper when discussing is_square().",
      "createdAt": "2019-11-05T23:15:36Z",
      "updatedAt": "2020-04-16T12:58:34Z",
      "closedAt": "2020-04-16T12:58:34Z",
      "comments": []
    },
    {
      "number": 194,
      "id": "MDU6SXNzdWU1MjE2ODA3Mjk=",
      "title": "Consider mentioning Lemire's \"multiply-then-shift\" strategy as alternative to modulo reduction in hash_to_base",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/194",
      "state": "CLOSED",
      "author": "peteroupc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Consider whether the strategy mentioned in \"[A fast alternative to the modulo reduction](https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/)\", by @Lemire , is useful to mention as an alternative to the \"mod p\" in the hash_to_base function in the draft, and possibly elsewhere a mod operation appears in that draft.  This alternative is especially worth mentioning if the alternative&mdash;\r\n\r\n- can be implemented in constant time, similarly to modulo reduction, and\r\n- has similar or better performance to modulo reduction.",
      "createdAt": "2019-11-12T17:06:50Z",
      "updatedAt": "2020-01-28T18:49:51Z",
      "closedAt": "2019-11-16T21:18:45Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the suggestion!\r\n\r\nThis document will not be a resource for fast arithmetic strategies, so probably the above trick is out of scope.\r\n\r\nMoreover, unless I'm badly misunderstanding something, in this document's context the above trick is not likely to be helpful. The reason is that p is essentially always going to be at least a couple hundred bits, whereas this trick is fast precisely because it's taking advantage of the fact that word-sized multiplication is cheap (From the article: \"Computing (x * N) div 2^32 is very fast on a 64-bit processor.\")\r\n\r\nIf people tended to use elliptic curves over extension fields p^k for p a 32-bit integer, this might be something to consider. But to my knowledge there are no such curves in widespread use today---and curves over those fields are believed to be less secure, so this isn't likely to change in the future.\r\n\r\nI'm closing this issue; please feel free to reopen and provide some more background if I've misunderstood something.",
          "createdAt": "2019-11-16T21:18:45Z",
          "updatedAt": "2019-11-16T21:20:13Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "Letting D. Lemire know about this.\r\n\r\n@Lemire : You were the one that suggested this strategy; please weigh in.\r\n",
          "createdAt": "2019-11-16T21:30:58Z",
          "updatedAt": "2019-11-16T21:30:58Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "There is one aspect that's important to note here: The \"constant-time\" aspect.\r\n\r\n@lemire said the following in briansmith/ring#942 :\r\n\r\n> Division instructions often reveal something about their inputs in that their running times vary based on the input. (Of course, this depends on the hardware.)\r\n\r\nThe \"main\" hash-to-base method uses a mod operation, which has to be implemented in constant time like the rest of the method.  Especially since this document is not meant to give guidance on how to implement operations in constant time, it is likely that an implementor of these methods will use the simple \"%\" operator (or its equivalent) without realizing that the operator's implementation (under the hood) might not be \"constant-time\" in all relevant hardware. (Note that generally, the \"%\" operator includes division.)\r\n\r\nAlthough I am aware that mod can be implemented using a multiplication by a multiplicative inverse together with other operations, this seems to me to have no big advantage over the \"multiply-then-shift\" strategy I suggest here, especially since the hash_to_base method is the only method in the draft where the \"mod\" operation appears -- for example, the line:\r\n\r\n     6.   e_i = OS2IP(tv) mod p\r\n\r\n...could be replaced with:\r\n\r\n    6.   e_i = (OS2IP(tv) * p) >> bits\r\n",
          "createdAt": "2020-01-28T16:55:01Z",
          "updatedAt": "2020-01-28T16:55:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks again for the comment. A few responses (apologies for the bulleted list; it's for clarity, not to be brusque):\r\n\r\n1. This document does not deal with low-level details of field arithmetic. These details are useful! but this is not the place to do it. Other documents exist for this purpose, and I have no doubt that their authors spent considerable time writing them.\r\n\r\n2. The document linked from the first comment does not deal with multi-precision arithmetic---it's an optimization for doing modular reduction for word-sized integers, which is not relevant in this context. (Generalizing this trick to multi-precision arithmetic reconstructs something vaguely similar to Montgomery modular reduction. So it's a cool observation, but it is already well known by practitioners.)\r\n\r\n3. You are right that `%` is generally not constant time. In most programming languages, however, the `%` operator is defined for native integer types, not for multi-precision types---so it's *not possible* to use `%` in hash-to-base.\r\n\r\n    There are some languages---like Python---where integers are natively multi-precision. But *no* native integer operations are (guaranteed to be) constant-time in Python! so the suggested multiply-and-shift approach also does not yield a constant-time implementation. This is generally true, to my knowledge, for mainstream programming languages that have native multi-precision types.\r\n\r\n4. This document is intended for use in a context where one already has working elliptic curve operations, which underneath *require* field operations (and thus, reduction mod p). Requiring the use of a different, incompatible strategy for selecting a random element mod p doesn't make sense when the intended audience of this document *must* already have suitable code available.\r\n\r\n5. Related to the prior point, the following is false:\r\n\r\n    > the hash_to_base method is the only method in the draft where the \"mod\" operation appears\r\n\r\n     The reason it's false is that every elliptic curve operation implicitly requires many reductions mod p.\r\n\r\nI understand and appreciate the desire to make this document useful to the broadest possible audience, and to the extent this is possible we're happy to do it. But what's suggested here does not do that: for novice implementors the suggested level of detail is insufficient, while for experienced ones it's unnecessary.",
          "createdAt": "2020-01-28T18:49:50Z",
          "updatedAt": "2020-01-28T18:49:50Z"
        }
      ]
    },
    {
      "number": 195,
      "id": "MDU6SXNzdWU1MjU0NjczNTQ=",
      "title": "Montgomery / Weierstrass inconsistency in Twisted Edwards section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/195",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@armfazh points out that there's an inconsistency that we probably want to address in the \"Rational maps from Montgomery to twisted Edwards curves\" section: it talks about Montgomery and Long Weierstrass curves interchangeably, which could be confusing.\r\n\r\n[link to @armfazh's comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189#discussion_r348238478) and [my follow-up](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189#discussion_r348284336).\r\n\r\nOne way to address this is to split the \"Long Weierstrass to Edwards\" map into its own section, and make explicit everywhere that the Edwards mapping works for either one. I like this approach because it lets us keep talking about equivalent *Montgomery* curves when such curves are standardized (as I mentioned in my post linked above, I think this makes more explicit the kind of reusability we're aiming for).\r\n\r\nIt might be more consistent to always talk about Montgomery or always talk about Weierstrass. We should think about this to try and understand whether this can be made clean and clear; it's not obvious to me right now.",
      "createdAt": "2019-11-20T04:27:50Z",
      "updatedAt": "2020-03-03T18:57:29Z",
      "closedAt": "2020-03-03T18:57:29Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another approach would be to take @armfazh's suggestion from #189: remove all use of Long Weierstrass from the document, build the Weierstrass-to-Montgomery conversion into the Elligator 2 description, and then *only* deal with Montgomery and Twisted Edwards curves in this section.\r\n\r\nCome to think of it, that probably works quite nicely. Happy to take a crack at this if y'all like this approach.",
          "createdAt": "2019-11-20T04:41:28Z",
          "updatedAt": "2019-11-20T04:41:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(cc @armfazh @chris-wood )",
          "createdAt": "2019-11-20T04:41:43Z",
          "updatedAt": "2019-11-20T04:41:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, one more thought: ell2C0 might require a bit more care if we do elligator purely in terms of Montgomery curves. But we can have the \"change of variables\" live only at that spot in the document, which is anyway not going to be particularly popular I'd guess.",
          "createdAt": "2019-11-20T04:58:32Z",
          "updatedAt": "2019-11-20T04:58:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> build the Weierstrass-to-Montgomery conversion into the Elligator 2 description\r\n\r\nI'm not sure I follow this suggestion -- @kwantam, could you elaborate?",
          "createdAt": "2019-11-20T10:23:05Z",
          "updatedAt": "2019-11-20T10:23:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Right now, the Elligator2 description is written for Weierstrass curves\r\n\r\n~~~\r\n    Y^3 = X^3 + C * X^2 + D * X            (1)\r\n~~~\r\n\r\nThen, for Montgomery curves, i.e.,\r\n\r\n~~~\r\n    K * t^2 = s^3 + J * s^2 + s            (2)\r\n~~~\r\n\r\nwe give a change of variables that converts from form (2) to form (1).\r\n\r\nWe could rewrite the Elligator2 map to deal directly with form (2), basically by modifying the map so that the change of variables is just built into its description. Mechanically, this would involve changing a couple of the constants and adding two extra multiplications at the end of the mapping function.\r\n\r\nI think probably this *would* be a clarity improvement overall---fewer moving parts for the reader to keep track of.\r\n\r\n(EDIT: I think I'd prefer to land #189 and then do this in a separate PR, though.)",
          "createdAt": "2019-11-20T17:28:22Z",
          "updatedAt": "2019-11-20T17:29:45Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Another approach would be to take @armfazh's suggestion from #189: remove all use of Long Weierstrass from the document,\r\n\r\nI consider the document must focus more on mappings for curves Montgomery and TEdwards curves. So we provide descriptions of mappings that solve this problem.\r\nSo here is a possible way to do it.\r\n\r\nFor Montgomery curves M: \r\n\r\n> We could rewrite the Elligator2 map to deal directly with form (2), basically by modifying the map so that the change of variables is just built into its description. Mechanically, this would involve changing a couple of the constants and adding two extra multiplications at the end of the mapping function.\r\n\r\nI would add a comment saying that some multiplications can be saved since K=1 (the coefficient of y^2 in a Montgomery curve).\r\n\r\nFor TEdwards curves E:\r\n\r\n```vb\r\nif `E` in {edwards25519,edwards448}\r\n    `map` is set to M -> E from RFC7748.\r\n    (X,Y) = elligator2(u)\r\n    (v,w) = map(X,Y)\r\nelse    \r\n    `map` is set to W -> E ( where W is the long Weiestrass curve required by elligator2)\r\n    `map2` is the composition of elligator2 and `map`. \r\n    // In the document, we only describe map2 as a general solution for TEdwards.\r\n    (v, w) = map2(u)\r\nend if\r\nreturn  (v, w)\r\n```\r\n\r\n",
          "createdAt": "2019-11-20T21:07:09Z",
          "updatedAt": "2019-11-20T21:07:09Z"
        }
      ]
    },
    {
      "number": 199,
      "id": "MDU6SXNzdWU1NTA5MDgzNTU=",
      "title": "Update to Python 3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/199",
      "state": "CLOSED",
      "author": "mratsim",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Python 2 has been end-of-life'd on January 1st 2020 and is not supported anymore.\r\n\r\nCurrently the codebase relies on Python 2: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/6cf7fa9742e2f85f5ee6454861afd462e38d4230/poc/hash_to_base.py#L11-L12\r\n\r\nBesides this line there are issue with `xrange` and byte strings being detected as Unicode objects.\r\n\r\nI'm not familiar with Sagemath but according to this ticket all internal Sagemath tests are passing since 2 weeks ago: https://trac.sagemath.org/ticket/26212.\r\nThe other meta-issues have not been updated for more than a year and are probably stale (https://trac.sagemath.org/ticket/15980 / https://trac.sagemath.org/ticket/16052)\r\n",
      "createdAt": "2020-01-16T16:12:45Z",
      "updatedAt": "2020-01-22T02:17:32Z",
      "closedAt": "2020-01-22T02:17:32Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @mratsim! We'll update the code ASAP. (PRs are also welcome and appreciated, if you feel so inclined. :))",
          "createdAt": "2020-01-20T22:42:42Z",
          "updatedAt": "2020-01-20T22:42:42Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I have a TODO to fix this. I will try to get to it this week.\r\n\r\nUnfortunately, we cannot deprecate Python2 in this code, because many people will continue to use Sage 8.x, which is built on Python2, for the forseeable future---it's in Ubuntu LTS, for example. This may make the fixes slightly more annoying, but I'm hopeful it won't be too bad.",
          "createdAt": "2020-01-20T23:28:51Z",
          "updatedAt": "2020-01-20T23:28:51Z"
        }
      ]
    },
    {
      "number": 200,
      "id": "MDU6SXNzdWU1NTEzNjkxMzc=",
      "title": "Null-terminated (octet) strings for message and Domain-Separation Tag",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/200",
      "state": "CLOSED",
      "author": "mratsim",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Linked to https://github.com/ethereum/eth2.0-specs/issues/1576\r\n\r\nThe current spec uses the terms `strings`, `bit string`, `octet string` however their representation is not explained.\r\nIn particular the ``hash_to_curve`` section does not mention that the message should be terminated by a null byte but the reference implementation does append a null byte:\r\n\r\nImplementation\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/6cf7fa9742e2f85f5ee6454861afd462e38d4230/poc/hash_to_base.py#L59-L67\r\n\r\nSpec\r\n\r\n```\r\nhash_to_base(msg, ctr)\r\n\r\nParameters:\r\n- DST, a domain separation tag (see discussion above).\r\n- H, a cryptographic hash function.\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- p, the characteristic of F (see immediately above).\r\n- m, the extension degree of F, m >= 1 (see immediately above).\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security\r\n  parameter of the cryptosystem (e.g., k = 128).\r\n- HKDF-Extract and HKDF-Expand are as defined in RFC5869,\r\n  instantiated with the hash function H.\r\n\r\nInputs:\r\n- msg is the message to hash.\r\n- ctr is 0, 1, or 2.\r\n  This is used to efficiently create independent\r\n  instances of hash_to_base (see discussion above).\r\n\r\nOutput:\r\n- u, an element in F.\r\n\r\nSteps:\r\n1. msg_prime = HKDF-Extract(DST, msg || I2OSP(0, 1))\r\n2. info_pfx = \"H2C\" || I2OSP(ctr, 1)   # \"H2C\" is a 3-byte ASCII string\r\n3. for i in (1, ..., m):\r\n4.   info = info_pfx || I2OSP(i, 1)\r\n5.   tv = HKDF-Expand(msg_prime, info, L)\r\n6.   e_i = OS2IP(tv) mod p\r\n7. u = (e_1, ..., e_m)\r\n8. return u\r\n```\r\n\r\nAssuming a message MUST be terminated by a null-byte. Does that also apply to the Domain Separation Tag?",
      "createdAt": "2020-01-17T11:44:23Z",
      "updatedAt": "2020-02-24T02:41:47Z",
      "closedAt": "2020-02-24T02:41:47Z",
      "comments": [
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks to the attentive eye of @benjaminion in https://github.com/ethereum/eth2.0-specs/issues/1576, this has been clarified from [Section 5.1 Security consideration](https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-5.1)\r\n\r\n> Finally, hash_to_base appends one zero byte to msg in the invocation\r\n> of HKDF-Extract.  This ensures that the use of HKDF in hash_to_base\r\n> is indifferentiable from a random oracle (see [LBB19], Lemma 8 and\r\n> [DRST12], Theorems 4.3 and 4.4).  (In particular, this approach works\r\n> because it ensures that the final byte of each HMAC invocation in\r\n> HKDF-Extract and HKDF-Expand is distinct.)\r\n\r\nThis security null-byte is missing in the implementation steps.\r\nSome clarification about string/bit-string/octet-string representation (i.e. not needing a null byte in the general case) could be helpful as well.",
          "createdAt": "2020-01-17T13:17:56Z",
          "updatedAt": "2020-01-17T13:17:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This security null-byte is missing in the implementation steps.\r\n\r\nIs this true? The code below appends a single byte (0x00) to `msg`:\r\n\r\n```\r\nmsg_prime = hkdf_extract(dst, msg + '\\x00', hash_fn) \r\n```",
          "createdAt": "2020-01-20T22:45:28Z",
          "updatedAt": "2020-01-20T22:45:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> In particular the `hash_to_curve` section does not mention that the message should be terminated by a null byte but the reference implementation does append a null byte:\r\n\r\nSorry, that does not appear to be true:\r\n\r\n> Spec\r\n> \r\n> ```\r\n> 1. msg_prime = HKDF-Extract(DST, msg || I2OSP(0, 1))\r\n> ```\r\n\r\nNotice that the second argument to HKDF-Extract is `msg || I2OSP(0, 1)`. This is consistent with the text you quoted from Section 5.1.",
          "createdAt": "2020-01-20T23:20:59Z",
          "updatedAt": "2020-01-20T23:25:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "But: thank you for pointing out that we're not precise enough when we call `msg` a \"string.\" We should say octet-string.",
          "createdAt": "2020-01-20T23:26:13Z",
          "updatedAt": "2020-01-20T23:26:13Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah I see I didn't associate ``I2OSP(0, 1)`` with the nul-byte",
          "createdAt": "2020-01-21T08:01:48Z",
          "updatedAt": "2020-01-21T08:01:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose to change the 0x00 (zero-byte marker) for any other non-zero byte constant. Because it can be confused with null terminating strings (like in C, or in this issue), and also because the value of the marker does not play role in security, other than ->\r\n\r\n> (In particular, this approach works because it ensures that the final byte of each HMAC invocation in HKDF-Extract and HKDF-Expand is distinct.",
          "createdAt": "2020-01-24T21:59:08Z",
          "updatedAt": "2020-01-24T21:59:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I propose to change the 0x00 (zero-byte marker) for any other non-zero byte constant.\r\n\r\nDo we have any other 0x00 markers outside of the one in `hash_to_base`?\r\n",
          "createdAt": "2020-01-25T13:52:47Z",
          "updatedAt": "2020-01-25T13:52:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "0x00 is not an arbitrary choice, it's the only value that makes the\nindifferentiability proof go through. Changing it to another value is\ntherefore not a good idea.\n\nBut this discussion is moot, because we should just replace this\nhash-to-base design with the strictly better one in #202.\n",
          "createdAt": "2020-01-25T14:47:10Z",
          "updatedAt": "2020-01-25T14:47:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 0x00 is not an arbitrary choice,\r\n\r\nI don't think @armfazh meant to imply otherwise -- he pointed towards its role in differentiating HMAC invocations.  ",
          "createdAt": "2020-01-25T15:01:28Z",
          "updatedAt": "2020-01-25T15:01:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "You're right---apologies for being unclear!\n\nI was responding to the claim that it doesn't play a role in security; this\nis false.\n\n(Sorry for clipped responses. I'm writing from my phone.)\n",
          "createdAt": "2020-01-25T15:05:56Z",
          "updatedAt": "2020-01-25T15:05:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you good to close this?",
          "createdAt": "2020-02-16T01:22:05Z",
          "updatedAt": "2020-02-16T01:22:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood @armfazh closing since #202 should obsolete this issue. Please feel free to reopen if we need to discuss this further.",
          "createdAt": "2020-02-24T02:41:47Z",
          "updatedAt": "2020-02-24T02:41:47Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU1NTM2Mzk1MjI=",
      "title": "hash-to-base issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "EDIT: Please see [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577864753) for a summary of the proposed changes.\r\n\r\n---\r\n\r\nSorry to reopen this can of worms, but I think there are a couple reasons to worry about the current version of hash-to-base.\r\n\r\n1. @BjoernMHaase points out that, for embedded systems, hashing can be much more expensive than field or curve operations. The reason is, hashing is done on the main (sometimes 8-bit!) processor, whereas field and curve operations use a specialized co-processor. The result is that, in his CPace implementation, he doesn't want to use our version of hash-to-base.\r\n\r\n    It seems reasonable to expect this to be an issue for several classes of hash-to-curve applications. I think we should be responsive to it, and come up with a simplified version of hash-to-base that's safe in this context.\r\n\r\n2. @reyzin points out that in the VRF draft they were very careful to make sure that all invocations of SHA-2 are domain separated, but our use of H in hash-to-base is incompatible with this. In fact, we sat down and talked through it yesterday, and there does not appear to be a safe and cheap way of domain separating uses of H outside of hash-to-base from its uses inside. The only way to do it appears to be to select a random, 32-byte string (e.g., by hashing a domain separation tag) and prepending that value to every use of H outside of hash-to-base.\r\n\r\n    This is really unsatisfying: first, it adds an extra invocation of the compression function, which is bad in resource-constrained contexts (per (1), above). Second, it means that domain separation requirements \"escape\" the hash-to-curve draft, in the sense that implementors need to understand how hash-to-curve uses H in order to safely reuse H in upper-layer protocols---an abstraction violation.\r\n\r\n3. We've heard from several people that they want to use SHA3, and our version of hash-to-base is overdesigned for this purpose. I don't care so much about overdesign in itself---it would be great if we could have a one size fits all version of hash-to-base---but given issues 1 and 2, we have an opportunity to revisit.\r\n\r\nI'm working on a couple proposals to fix this, one based on KMAC (or perhaps SHAKE) and one that's designed to be safe (including in the sense of (2) above) and efficient for Merkle-Damgaard functions (but should also be safe and efficient for SHA-3). For now I'm not proposing a specific course of action, just giving early warning that this is an issue we should think carefully about.",
      "createdAt": "2020-01-22T16:05:32Z",
      "updatedAt": "2020-04-03T01:24:23Z",
      "closedAt": "2020-02-28T22:45:16Z",
      "comments": [
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hi to all,\n\nI see a larger class of PAKE protocols to be the natural \"users\" of the\nresults of your work. As pointed out also in RFC8125, one aspect to\nconsider is also side-channel resistance beyond constant-time execution,\nspecifically, if smart-card based implementations are to be recommended\nin hostile environment.\n\nLast week during the breaks of the brainpool meeting, I had some\ndiscussion with people with more expertise on secure elements than I am\nhaving, specifically people from NXP and Infineon and BSI people.\n\nWhat I took with me from the discussions is,\n\n1) the major concern with the hash function use might be, that\nsmart-card based protected/masked implementations of hash functions are\nnot commonly available in hardware and their use is to be avoided in\nprotocols that require side-channel protections.\n\n2) Their recommendation was to give preference to constructions based on\nSPN-based block ciphers, where possible. They mentioned, e.g., the PRF\noperation required for expanding secrets.\n\n3) SHA3 might be easier to protect, but today also this algorithm, which\nis better prepared for SPA protections than Merkle-Damgard\nconstructions, but also there platforms with a protected implementation\nare not commonly available today.\n\n4) Expanding the inputs to twice the base field size might be a good\nidea. Some secure-element implementations seem to use randomization the\nbase field representations (by adding multiples of the prime). This\npossibly could provide one component for protecting the Map2Point base\nfield arithmetics against SPA.\n\nI have asked several smart card expert people to post an assessment or\nrecommendation on the CFRG list, but I fear that their company policies\nwon't allow for such contribution.\n\nA second aspect that I noticed in the current hash2curve draft is the\nmandatory co-factor blinding already on the hash2curve level.\n\nWhile Elligator2 returns the point in affine coordinates. (See e.g. the\npost from Mike Hamburg from 2017\nhttps://moderncrypto.org/mail-archive/curves/2017/000939.html)\n\nAfter co-factor blinding, the point will be represented in some\nprojective coordinate system. The cost of this corresponds to an\nadditional base field inversion. Citing again Mike Hamburg from his 2017\npost,\n\n\"The projective ladder requires one more register (Z0) and is slower if you have a dedicated\nsquaring algorithm.  It\u2019s faster [than a variant with inversion and an affine ladder]\nif you\u2019re using multiply as square.\"\n\nYours,\n\nBj\u00f6rn\n\nAm 22.01.2020 um 17:05 schrieb Riad S. Wahby:\n>\n> Sorry to reopen this can of worms, but I think there are a couple\n> reasons to worry about the current version of hash-to-base.\n>\n> 1.\n>\n>     @BjoernMHaase <https://github.com/BjoernMHaase> points out that,\n>     for embedded systems, hashing can be much more expensive than\n>     field or curve operations. The reason is, hashing is done on the\n>     main (sometimes 8-bit!) processor, whereas field and curve\n>     operations use a specialized co-processor. The result is that, in\n>     his CPace implementation, he doesn't want to use our version of\n>     hash-to-base.\n>\n>     It seems reasonable to expect this to be an issue for several\n>     classes of hash-to-curve applications. I think we should be\n>     responsive to it, and come up with a simplified version of\n>     hash-to-base that's safe in this context.\n>\n> 2.\n>\n>     @reyzin <https://github.com/reyzin> points out that in the VRF\n>     draft they were very careful to make sure that all invocations of\n>     SHA-2 are domain separated, but our use of H in hash-to-base is\n>     incompatible with this. In fact, we sat down and talked through it\n>     yesterday, and there does not appear to be a safe and cheap way of\n>     domain separating uses of H outside of hash-to-base from its uses\n>     inside. The only way to do it appears to be to select a random,\n>     32-byte string (e.g., by hashing a domain separation tag) and\n>     prepending that value to every use of H outside of hash-to-base.\n>\n>     This is really unsatisfying: first, it adds an extra invocation of\n>     the compression function, which is bad in embedded contexts.\n>     Second, it means that domain separation requirements \"escape\" the\n>     hash-to-curve draft, in the sense that implementors need to\n>     understand how hash-to-curve uses H in order to safely reuse H in\n>     upper-layer protocols---an abstraction violation.\n>\n> 3.\n>\n>     We've heard from several people that they want to use SHA3, and\n>     our version of hash-to-base is overdesigned for this purpose. I\n>     don't care so much about overdesign in itself---it would be great\n>     if we could have a one size fits all version of hash-to-base---but\n>     given issues 1 and 2, we have an opportunity to revisit.\n>\n> I'm working on a couple proposals to fix this, one based on KMAC (or\n> perhaps SHAKE) and one that's designed to be safe for Merkle-Damgaard\n> functions (but should also be safe and efficient for SHA-3). For now\n> I'm not proposing a specific course of action, just giving early\n> warning that this is an issue we should think carefully about.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202?email_source=notifications&email_token=ADMGYAHTPLA7HYE2KUA6UI3Q7BVE3A5CNFSM4KKIKOM2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IH73ZRA>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ADMGYAB4IJIAXE2PNLERVADQ7BVE3ANCNFSM4KKIKOMQ>.\n>\n",
          "createdAt": "2020-01-22T17:14:17Z",
          "updatedAt": "2020-01-22T17:14:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments, Bj\u00f6rn! A few quick responses below.\r\n\r\n- The suggestions you make for protecting against side channels are excellent, but probably are out of scope for this draft. Of course, anyone is welcome to implement randomized projective coordinates, randomized field element representations, etc.! But probably a separate draft giving guidance on these strategies would be more useful than trying to put them into this draft---especially since these countermeasures are mostly generic, not hash-to-curve--specific.\r\n\r\n- Extracting with a hash function and then expanding with a PRF is a perfectly reasonable strategy in general. It seems worthwhile for us to suggest this as an alternative to the approach or approaches that the document specifies, but I can't promise that we will give a detailed specification of such an approach.\r\n\r\nI will keep thinking about this.",
          "createdAt": "2020-01-22T21:51:45Z",
          "updatedAt": "2020-01-22T21:51:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's a skeletal proposal for a simplified approach to hash-to-field.\r\n\r\nAt a high level, this proposal splits hash-to-field into two steps:\r\n\r\n1. Generate a pseudorandom byte string based on the message and domain separation tag.\r\n\r\n2. Interpret this byte string as one or more elements of F = GF(p^m).\r\n\r\nNote that this is a departure from the current approach: in the above, hash-to-field can return *multiple* field elements in one call. This means that both hash-to-curve and encode-to-curve will call hash-to-field *exactly once*, but will request either one (encode-) or two (hash-) field elements.\r\n\r\nThere are three reasons for this change: first, it minimizes the number of hash function invocations, which is one of the explicit goals of this redesign. Second, it simplifies drop-in use of any hash function in the SHA-2 or SHA-3 family, meaning that we do not have to specify a different hash-to-field function to use, say, SHAKE128. Third, it makes drop-in use of block cipher--based expansion easy (though, per my prior comment, I do not necessarily advocate specifying here).\r\n\r\nHere's the new proposed hash-to-field function:\r\n\r\n~~~\r\nhash_to_field(msg, count)\r\n\r\nParameters:\r\n- DST, a domain separation tag.\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- p, the characteristic of F.\r\n- m, the extension degree of F, m >= 1.\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter.\r\n- expand_message, a function that takes a message, DST, and number of\r\n  bytes and outputs that number of pseudorandom bytes.\r\n\r\nInput:\r\n- msg is the message to hash.\r\n- count is the number of elements of F to output.\r\n\r\nOutputs:\r\n- (u_0, ..., u_(count - 1)), count field elements.\r\n\r\nSteps:\r\n1. prb_length = count * m * L\r\n2. pseudo_random_bytes = expand_message(msg, DST, count * m * L)\r\n3. for i in (0, ..., count - 1):\r\n4.   for j in (0, ..., m - 1):\r\n5.     elm_offset = L * (j + i * m)\r\n6.     tv = pseudo_random_bytes[elm_offset : elm_offset + L]\r\n7.     e_i = OS2IP(tv) mod p\r\n8.   u_i = (e_0, ..., e_(m - 1))\r\n9. return (u_0, ..., u_(count - 1))\r\n~~~\r\n\r\nIn subsequent comments I'll discuss options for the `expand_message` function.",
          "createdAt": "2020-01-22T22:24:17Z",
          "updatedAt": "2020-01-22T22:24:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we just have to specify an `expand_message` function.\r\n\r\nWe can easily build one based on SHAKE128:\r\n\r\n~~~\r\nexpand_message_shake128(msg, DST, len_in_bytes)\r\n\r\nInput:\r\n- msg, an octet string\r\n- DST, an octet string\r\n- len_in_bytes, length of requested output in octets\r\n\r\nOutput:\r\n- pseudo_random_bytes, an octet string\r\n\r\nSteps:\r\n1. msg_prime = DST || I2OSP(len_in_bytes, 2) || msg\r\n2. return SHAKE128(msg_prime, 8 * len_in_bytes)\r\n~~~\r\n\r\n(Note that the length argument to SHAKE128, per FIPS 202, is in *bits*.)\r\n\r\nSHAKE256 is analogous, of course.",
          "createdAt": "2020-01-22T22:30:05Z",
          "updatedAt": "2020-01-22T22:30:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "How about SHA-2? Here we have to be careful, since SHA-2 is a Merkle-Damgaard construction and is thus *not* itself indifferentiable from a random oracle, even if we assume that the underlying compression function is a random oracle. (This relates to well-known length extension attacks, multi-collision attacks, etc., on M-D constructions.)\r\n\r\nNote, however, that the value `expand_message` returns to `hash_to_field` isn't exposed to `hash_to_field`'s caller. Instead, it's cut into (log(p)+k)-bit chunks, which are reduced mod p. We can use this fact to our advantage!\r\n\r\nIn particular, while I haven't yet written down a full proof, it looks very likely that we can build on existing analyses of chop-MD ([1](https://cs.nyu.edu/~dodis/ps/merkle.pdf), [2](https://link.springer.com/chapter/10.1007/978-3-540-71039-4_27), [3](http://www.di.ens.fr/~fouque/pub/csf12.pdf), i.e., constructions like SHA512/256) to show that reducing a (log(p)+k)-bit integer mod p suffices for indifferentiability. Intuitively, the reason is that the same k extra bits we're using to get a near-uniform element of GF(p) also suffice to prevent length extensions, etc.\r\n\r\n~Here's the proposed function:~\r\n\r\nEDIT: removing this version, because it's not quite strong enough. I'll post a new one below.",
          "createdAt": "2020-01-22T22:59:08Z",
          "updatedAt": "2020-01-23T17:28:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "EDIT: I vote **not** to specify this function in the hash-to-curve draft. Please regard this comment as spitballing only.\r\n\r\n---\r\n\r\nIf we really wanted to specify something based on a ctr-mode cipher, we could do something like this:\r\n\r\n~~~\r\nexpand_message_ctr(msg, DST, len_in_bytes)\r\n\r\nParameters:\r\n- E, a block cipher encryption function taking kE-bit keys and bE-bit blocks.\r\n- bE, the block size of E.\r\n- kE, the key length of E.\r\n- H, a hash function that outputs at least kE + bE + k bits, for security parameter k.\r\n\r\nInput and output: same as above\r\n\r\nSteps:\r\n1.  ell = (len_in_bytes * 8) / bE\r\n2.  ABORT if ell > 255\r\n3.  msg_prime = H(DST || I2OSP(ell, 1) || msg)\r\n4.  eKey = first kE bits of msg_prime\r\n5.  eCtr = next kB bits of msg_prime\r\n6.  ctr = OS2IP(eCtr)\r\n7.  for i in (0, ..., ell - 1):\r\n8.    ctr = ctr + 1\r\n9.    b_i = E(eKey, I2OSP(ctr, kB / 8))\r\n10. pseudo_random_bytes = b_0 || ... || b_(ell - 1)\r\n11. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\nOf course, it would be totally reasonable to replace the block cipher with a good stream cipher...\r\n\r\nSince we're throwing away k bits of H's output, it's safe to use a Merkle-Damgaard hash function. When using SHA-3, we can relax the requirement on H's output size to just kE + bE.\r\n\r\nFor collision resistance, we require that kE + bE > 2 * k. Note that by this definition AES-256 is only appropriate for k = 192, not for k = 256 (because the AES block size is small). There are ways to handle this (e.g., XOR the output of two independently-seeded AES-CTR PRGs).",
          "createdAt": "2020-01-22T23:10:29Z",
          "updatedAt": "2020-02-15T10:37:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, here's an improved version of `expand_message_md` along with a very brief sketch of the security argument.\r\n\r\nFor this construction, we require a hash function H whose output size in bits is at least 2 * k, for k the security parameter.\r\n\r\n~~~\r\nexpand_message_md(msg, DST, len_in_bytes)\r\n\r\nParameters:\r\n- H, a Merkle-Damgaard or Sponge-based hash function.\r\n- obs, the output block size of H in bytes.\r\n- k_in_bytes, ceil(k / 8) for k the security parameter, e.g,\r\n  for k = 128, k_in_bytes = 16.\r\n\r\nInput:\r\n- msg, an octet string.\r\n- DST, an octet string.\r\n- len_in_bytes, the length of the requested output in octets.\r\n\r\nOutput:\r\n- pseudo_random_bytes, an octet string.\r\n\r\nSteps:\r\n1. ell = ceil((len_in_bytes + k_in_bytes) / obs)\r\n2. ABORT if ell > 255\r\n3. b_0 = H(DST || I2OSP(0, 1) || I2OSP(ell, 1) || msg)\r\n4. for i in (1, ..., ell - 1):\r\n5.   b_i = H(DST || I2OSP(i, 1) || b_(i - 1))\r\n6. b_0_chopped = first (obs - k_in_bytes) bytes of b_0\r\n7. pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n8. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\n**In principle** one can skip chopping b_0 for functions in the SHA-3 family (or, more generally, for H with a reasonable indifferentiability proof). In practice, it's not clear to me whether the extra complexity is worthwhile. Thoughts?\r\n\r\n---\r\n\r\n### Security argument (sketch)\r\n\r\nWe argue security by composing existing security arguments for chop-MD and NMAC.\r\n\r\nIn particular, chop-MD that cuts off k bits of a hash whose output is at least 2 * k bits is indifferentiable from a random oracle with distinguishing advantage roughly Q / 2^-k, for an adversary making Q queries, paraphrasing [DFL12](http://www.di.ens.fr/~fouque/pub/csf12.pdf). Thus, the output `b_0_chopped` is indifferentiable from a RO with the same advantage.\r\n\r\nWe can view outputs `b_1` through `b_(ell - 1)` in two ways. Either we can regard them as a variant of the NMAC / HMAC^f instantiation due to Coron et al. [[CDMP05](https://cs.nyu.edu/~dodis/ps/merkle.pdf), Theorem 3.5], or we can simply notice that the length of inputs to H for all of these outputs is fixed and all calls to H are prefix-free (since they start `DST || 0`, `DST || 1`, ...). In either case, since the output size of H is at least 2 * k, we have from CDMP05 that the distinguishing advantage is roughly Q^2 / 2^(2 * k).\r\n\r\nNext, we can leverage the composability of indifferentiability to show that the concatenation of independent random oracle outputs is indifferentiable from a random oracle. The simulator is the trivial one.\r\n\r\nFinally, we need one more indifferentiability argument, namely, that chopping the \"big\" RO output into (log p + k)-bit chunks and reducing each one mod p is indifferentiable. Once again the simulator here is quite simple: for each field element, there is an equivalence class of roughly 2^k bit strings; the simulator simply picks one of these. This is indifferentiable for essentially the same reason that reducing a (log p + k)-bit value mod p gives a field element with statistical difference at most 2^-k from uniform.",
          "createdAt": "2020-01-23T20:12:16Z",
          "updatedAt": "2020-02-15T10:45:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, having worked through the above and thought carefully about this, I propose the following:\r\n\r\n1. Replace `hash_to_base` in the current spec with `hash_to_field` as defined [above](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577414575).\r\n2. Specify [`expand_message_shake128` / `256`](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577416556) and [`expand_message_md`](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577855327), but *not* `expand_message_ctr`. The reason is that we don't want to encourage people to use another primitive, and we don't want to take on the burden of proving security for the `_ctr` construction.\r\n3. Update the suite naming scheme to include a field that specifies the expand_message variant and underlying hash function.\r\n\r\n~There's one dangling question for the `_md` construction: do we chop for SHA-3, or only for SHA-2? This is a question of slightly simpler spec vs. slightly more efficient implementation. My inclination is towards the simpler spec, but reasonable people can obviously disagree...~  **EDIT**: My vote is simplicity of specification. Always chop b0, even for SHA-3.\r\n\r\ncc @chris-wood @armfazh @grittygrease @samscott89",
          "createdAt": "2020-01-23T20:35:39Z",
          "updatedAt": "2020-02-15T10:43:31Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hello Riad,\n\nthank you for your effort and consideration. In think that the\ncomputational complexity and RAM requirement is reduced quite a bit with\nyour suggestion. Moreover, by using the SHAKE primitives there will be\n(IMO) a good path for providing future SPA secured implementations.\nMaybe not on all platforms available today, but maybe in the future (the\nSHA3 permutation is much more easily masked and protected than\nMerkle-Damgaard, as much as I understand).\n\nAlso one advantage side-channel wise of your construction is that the\nmessage input (of possibly low entropy in the PAKE context) is fed only\n*once* into the construction. For the presumably important P-256 case,\nyour expand operation would also boil down to only two SHA-256 hash\nfunction invocations (if I counted correctly), if only one single field\nelement is needed, e.g. for encode_to_curve().\n\nNote also that with this approach attempts for side-channel mitigations\n(as I have suggested, e.g. in the CPace draft with the 0-Padding after\nthe low-entropy secret input) could be implemented by just modifying the\nformat of the message field.\n\nWhat I will be doing is, I'll try to motivate some other people to\nreview your suggestion.\n\nAs final remark, I'd like to come up with one question. In case that the\nhash function output block length alone is sufficiently large for\ngenerating the required len_in_bytes amount of PRF bytes: Would you\nconsider it acceptable to just drop the \"chopping\" operation for b0 and\nuse all of the bytes of the b0 output? One might be sparing one\nadditional invocation of the hash. Heuristically, I think that one then\nmight want to add the len_in_bytes field to the initial hashing\noperation yielding b0, e.g. before the message. This way \"length\nextension type\" attacks are not manageble and using the message with\ndifferent lengths results always in different expanded messages, even if\nthe length is changed only by a small amount that does not modify the\nnumber of required blocks.\n\n(My question relates to the case of X25519, which is often used in\nconjunction with Ed25519 and SHA512, even if the security parameters are\nnot matching. An encode2curve operation for X25519 could possibly share\nall of field arithmetics and hash function implementation with Ed25519.\nIn this case only one single hash invocation of SHA512 would be required.)\n\nYours,\n\nBj\u00f6rn\n\n",
          "createdAt": "2020-01-23T21:31:20Z",
          "updatedAt": "2020-01-23T21:31:20Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "I did forget to add the note regarding the \"should one consider to drop\nthe chop operation if used in conjunction with SHA-3?\" topic.\n\nI'd advocate that people really focusing on efficiency would likely be\nusing a SHAKE128 or SHAKE256 construction instead? So maybe there is no\nreal justification for making the specification for sponges different\nfrom Merkle-Damgaard constructions.\n\n",
          "createdAt": "2020-01-23T21:37:04Z",
          "updatedAt": "2020-01-23T21:37:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> In case that the hash function output block length alone is sufficiently large for generating the required len_in_bytes amount of PRF bytes: Would you consider it acceptable to just drop the \"chopping\" operation for b0 and use all of the bytes of the b0 output? One might be sparing one additional invocation of the hash. Heuristically, I think that one then might want to add the len_in_bytes field to the initial hashing operation yielding b0, e.g. before the message. This way \"length extension type\" attacks are not manageble and using the message with different lengths results always in different expanded messages, even if the length is changed only by a small amount that does not modify the number of required blocks.\r\n\r\nUnfortunately, it is not safe to drop the chop operation for b0.\r\n\r\nIt *might* be safe to do this if we prepended `msg` with its length, e.g.:\r\n\r\n    b_0 = H(DST || I2OSP(0, 1) || I2OSP(ell, 1) || I2OSP(len(msg), 8) || msg)\r\n\r\n(But note I am only saying it *might*---I have not thought about it carefully enough to be sure.)\r\n\r\nThere are two reasons I didn't want to go this way: first, it's never obvious how long a field to make this. Surely 8 bytes is enough! But probably 4 isn't, since we could imagine hashing a couple gigabytes in some weird corner case. So now we need a pretty long field.\r\n\r\nSecond, the issue with needing to prepend `len(msg)` to `msg` is that it means we have to know the length of the message before we start hashing it! This is probably true in most usages, but it's not obviously true all the time.\r\n\r\n> (My question relates to the case of X25519, which is often used in conjunction with Ed25519 and SHA512, even if the security parameters are not matching. An encode2curve operation for X25519 could possibly share all of field arithmetics and hash function implementation with Ed25519. In this case only one single hash invocation of SHA512 would be required.)\r\n\r\nRight! But for X25519 or Ed25519, we have log2(p) = 255, k = 128, so this scheme would use 384 bits to generate one element of GF(p), and 512 - 128 = 384, so in fact even without modification you can use a single SHA512 invocation. And in the hash-to-curve (rather than encode-to-curve) case, you would need 2 SHA-512 invocations even if you didn't chop b_0.\r\n\r\n(Note that this isn't strictly true in the case of X25519, since we can get very close to uniform field elements by reducing 256 bits mod p since p is so close to 2^255. But I don't think we should add special cases for p of special forms, because it will complicate things considerably.)",
          "createdAt": "2020-01-23T22:04:24Z",
          "updatedAt": "2020-01-23T22:06:16Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "OK, I understand. It's the same topic as the notorious CBC-MAC issue. In\nfact, the approach that you have sketched would not at all generate\noverhead in comparison with\u00a0 \"dropping the chop\".\n\nIf your suggestion becomes consensus in the Hash2Curve team, I'd be\nmodifying the CPace and AuCPace drafts to use the hash2curve default\nconstructions. (e.g. maybe with the tweak of using SHA512 together with\nCurve25519).\n\n\nAm 23.01.2020 um 23:04 schrieb Riad S. Wahby:\n>\n>     In case that the hash function output block length alone is\n>     sufficiently large for generating the required len_in_bytes amount\n>     of PRF bytes: Would you consider it acceptable to just drop the\n>     \"chopping\" operation for b0 and use all of the bytes of the b0\n>     output? One might be sparing one additional invocation of the\n>     hash. Heuristically, I think that one then might want to add the\n>     len_in_bytes field to the initial hashing operation yielding b0,\n>     e.g. before the message. This way \"length extension type\" attacks\n>     are not manageble and using the message with different lengths\n>     results always in different expanded messages, even if the length\n>     is changed only by a small amount that does not modify the number\n>     of required blocks.\n>\n> Unfortunately, it is not safe to drop the chop operation for b0.\n>\n> It might be safe to do this if we prepended |msg| with its length, e.g.:\n>\n> |b_0 = H(DST || I2OSP(0, 1) || I2OSP(ell, 1) || I2OSP(len(msg), 8) ||\n> msg) |\n>\n> There are two reasons I didn't want to go this way: first, it's never\n> obvious how long a field to make this. Surely 8 bytes is enough! But\n> probably 4 isn't, since we could imagine hashing a couple gigabytes in\n> some weird corner case. So now we need a pretty long field.\n>\n> Second, the issue with needing to prepend |len(msg)| to |msg| is that\n> it means we have to know the length of the message before we start\n> hashing it! This is probably true in most usages, but it's not\n> obviously true all the time.\n>\n>     (My question relates to the case of X25519, which is often used in\n>     conjunction with Ed25519 and SHA512, even if the security\n>     parameters are not matching. An encode2curve operation for X25519\n>     could possibly share all of field arithmetics and hash function\n>     implementation with Ed25519. In this case only one single hash\n>     invocation of SHA512 would be required.)\n>\n> Right! But for X25519 or Ed25519, we have log2(p) = 255, k = 128, so\n> this scheme would use 384 bits to generate one element of GF(p), and\n> 512 - 128 = 384, so in fact even without modification you can use a\n> single SHA512 invocation. And in the hash-to-curve (rather than\n> encode-to-curve) case, you would need 2 SHA-512 invocations in any case.\n>\n> (Note that this isn't strictly true in the case of X25519, since we\n> can get very close to uniform field elements by reducing 256 bits mod\n> p since p is so close to 2^255. But I don't think we should add\n> special cases for p of special forms, because it will complicate\n> things considerably.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202?email_source=notifications&email_token=ADMGYAB6MNAG4II6UCQSZR3Q7IH6TA5CNFSM4KKIKOM2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEJZAUFA#issuecomment-577899028>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ADMGYAEOXOSZ7ABY3GDCZG3Q7IH6TANCNFSM4KKIKOMQ>.\n>\n",
          "createdAt": "2020-01-23T22:13:23Z",
          "updatedAt": "2020-01-23T22:13:23Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If your suggestion becomes consensus in the Hash2Curve team, I'd be modifying the CPace and AuCPace drafts to use the hash2curve default constructions. (e.g. maybe with the tweak of using SHA512 together with Curve25519).\r\n\r\nCool!\r\n\r\nBy the way, the VRF draft also wants to use Curve25519 with SHA-512 (for the same reason as you, I think---because Ed25519 uses this combination), so I plan to propose defining a suite for this use-case.",
          "createdAt": "2020-01-23T22:15:18Z",
          "updatedAt": "2020-01-23T22:15:18Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Did you guys ever assess https://eprint.iacr.org/2019/1294.pdf by Koshelev Dmitrii? ",
          "createdAt": "2020-01-27T22:45:02Z",
          "updatedAt": "2020-01-27T22:45:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Did you guys ever assess https://eprint.iacr.org/2019/1294.pdf by Koshelev Dmitrii?\r\n\r\nUnless I'm misunderstanding, the above pertains to a new mapping, not to hash-to-base. So probably it would be better to discuss in its own issue.\r\n\r\nFirst impression: I doubt we'd include this map given that we've just removed other \"special-purpose\" maps (see #198), and this is another map that's restricted to a family of curves whose practical interest seems limited. But if this doesn't seem right---that is, if there are interesting reasons to have a map specifically for the j=1728 case---then please open a new issue about it and I'd be glad to chat more.",
          "createdAt": "2020-01-27T23:02:40Z",
          "updatedAt": "2020-01-27T23:02:40Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "Has the following discussion been considered?  I believe some of the discussion there may be relevant to the hash_to_base function. sipa/bips#195",
          "createdAt": "2020-02-03T21:40:13Z",
          "updatedAt": "2020-02-03T21:40:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Has the following discussion been considered? I believe some of the discussion there may be relevant to the hash_to_base function. [sipa/bips#195](https://github.com/sipa/bips/issues/195)\r\n\r\nThanks for the pointer.\r\n\r\nIn the context of hash-to-curve, the answer is that there's no public or private inputs---that depends on the invoking protocol. Because of this, it looks to me like there's no way to handle this generically in hash-to-curve: this is a question for the higher-level protocols that invoke h2c.\r\n\r\nThat seem to imply, however, that it might be worthwhile to add some words in the Security Considerations section discussing this, so that invoking protocols are suitably cautious.\r\n\r\n---\r\n\r\nAs a second way of answering: h2c currently tries to help readers avoid *timing* leaks. Power side channels are not really in scope---and, related to what I've said above, it's not clear to me that they could ever be in scope in a generic way that defends all invoking protocols against attack. This also seems to imply the need for a pointer in Security Considerations, I think.",
          "createdAt": "2020-02-03T22:14:31Z",
          "updatedAt": "2020-02-03T22:18:19Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "\u00a0\n\n\nHello to all,\n\n\u00a0\n\n\nactually it was exactly the analysis of Niels Samwel that drove me to the suggestion for proposing the hash-to-base variant in https://tools.ietf.org/html/draft-haase-cpace-00.\n\n\u00a0\n\nYours,\n\n\u00a0\n\nBj\u00f6rn\n\n\nGesendet:\u00a0Montag, 03. Februar 2020 um 23:14 Uhr\nVon:\u00a0\"Riad S. Wahby\" <notifications@github.com>\nAn:\u00a0cfrg/draft-irtf-cfrg-hash-to-curve <draft-irtf-cfrg-hash-to-curve@noreply.github.com>\nCc:\u00a0BjoernMHaase <bjoern.m.haase@web.de>, Mention <mention@noreply.github.com>\nBetreff:\u00a0Re: [cfrg/draft-irtf-cfrg-hash-to-curve] hash-to-base issues (#202)\n\n\n\nHas the following discussion been considered? I believe some of the discussion there may be relevant to the hash_to_base function. sipa/bips#195\n\n\nThanks for the pointer.\n\nIn the context of hash-to-curve, the answer is that there's no public or private inputs---that depends on the invoking protocol. Because of this, it looks to me like there's no way to handle this generically in hash-to-curve: this is a question for the higher-level protocols.\n\nIt may, however, be worthwhile to add some words in the Security Considerations section discussing this.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or unsubscribe.",
          "createdAt": "2020-02-03T22:43:23Z",
          "updatedAt": "2020-02-03T22:43:23Z"
        },
        {
          "author": "secunets",
          "authorAssociation": "NONE",
          "body": "Great discussion. Following closely to learn as much as possible and contribute at the right time. ",
          "createdAt": "2020-02-15T11:49:51Z",
          "updatedAt": "2020-02-15T11:49:51Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam In the spirit of code re-use, would it make sense to allow implementers who have a bigger toolbox than just cryptographic hashes and/xof functions to use these tools? For example, HKDF is available in many languages and libraries already. Perhaps we could allow HKDF to be used with the expand_message_xof function? It would be nice to be able to avoid implementing all of expand_message_xmd if HKDF is available.",
          "createdAt": "2020-04-01T15:42:10Z",
          "updatedAt": "2020-04-01T15:42:10Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we really want even more options?\r\n\r\nHKDF is indeed widely available (or, if not, trivial to implement) and could be the only option for all suites.",
          "createdAt": "2020-04-01T16:01:12Z",
          "updatedAt": "2020-04-01T16:01:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Perhaps we could allow HKDF to be used with the expand_message_xof function? It would be nice to be able to avoid implementing all of expand_message_xmd if HKDF is available.\r\n\r\nIt would be pretty easy to define expand_message_hkdf() if we really want people to be able to use it. But:\r\n\r\n> HKDF is indeed widely available (or, if not, trivial to implement) and could be the only option for all suites.\r\n\r\nProbably not, because of the issues with HKDF described in the first post.\r\n\r\nI'm most worried about the fact that it makes strict domain separation impossible for the underlying hash. Moreover, it would make our discussion of domain separation in the document messier, because we'd have to explain that a lot of what we say doesn't apply to expand_message_hkdf. Or we'll have to explicitly assume (not at all unreasonably) that H-inside-HKDF and H-outside-HKDF are already sufficiently separated, and the fact that further separation is impractical is OK.\r\n\r\nIn any case, I suppose if we wanted to define it, it'd look something like this:\r\n\r\n```\r\ndef expand_message_hkdf(msg, DST, len_in_bytes):\r\n   prk = HKDF_Extract(DST, msg || I2OSP(0, 1))\r\n   pseudo_random_bytes = HKDF_Expand(prk, \"expand_message_hkdf\", len_in_bytes)\r\n   return pseudo_random_bytes\r\n```\r\n\r\n(The extra zero byte appended to msg makes the indifferentiability proof go through.)",
          "createdAt": "2020-04-03T01:22:56Z",
          "updatedAt": "2020-04-03T01:24:23Z"
        }
      ]
    },
    {
      "number": 203,
      "id": "MDU6SXNzdWU1NTQ0MzcwMDQ=",
      "title": "add a suite for hashing to P-224?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/203",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the past we decided that we wouldn't add suites for curves under 128-bit security, because we didn't want to encourage people to use them. But it looks like we might want to add a suite for P-224, even though this violates that decision.\r\n\r\nThe reason I think we should at least discuss it is that, per a couple talks at Real World Crypto, both Google and Apple are using P-224, and in at least one of the talks someone specifically mentioned hashing to P-224.\r\n\r\nI realize this won't be so common going forward and also that adding a suite now doesn't help either Google's or Apple's usage, so I can see the argument against. Still, thought it was worth revisiting the decision in light of more-widespread-than-expected usage...\r\n\r\nThoughts? @chris-wood @armfazh @grittygrease",
      "createdAt": "2020-01-23T22:11:54Z",
      "updatedAt": "2020-01-27T03:24:13Z",
      "closedAt": "2020-01-27T03:24:13Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider we must add or give some guidance to anyone be able to create a suite. Otherwise, we must add any combination of {curve} x {hash} suite.\r\n",
          "createdAt": "2020-01-24T21:54:40Z",
          "updatedAt": "2020-01-24T21:54:40Z"
        },
        {
          "author": "randombit",
          "authorAssociation": "NONE",
          "body": "Having some guidance on adding additional curves would be useful IMO since there will inevitably be demand for supporting at least Brainpool and likely also ANSSI and SM2 curves in PAKEs.",
          "createdAt": "2020-01-24T22:07:09Z",
          "updatedAt": "2020-01-24T22:07:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d I think guidance would help. We probably don't need to fully specify something for P-224.",
          "createdAt": "2020-01-25T14:03:00Z",
          "updatedAt": "2020-01-25T14:03:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool! I'm convinced. Closing.",
          "createdAt": "2020-01-27T03:24:13Z",
          "updatedAt": "2020-01-27T03:24:13Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU1NjE1MDc5NjI=",
      "title": "Inconsistency with RFC7748/RFC8032",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/206",
      "state": "CLOSED",
      "author": "chjj",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From what I understand, the isomorphism factor between a Twisted Edwards and Montgomery curve can be derived as `sqrt((A + 2) / (B * a))`, leaving two possible roots (the sign of which ultimately determines the sign of the point's x/v coordinates). In the case of Curve25519/Ed25519, the computation becomes `sqrt(-486664)`. For Elligator 2, the [draft][draft1] [currently says][draft2] to use a root such that `sgn0(sqrt(-486664)) == 1`. This seems to be inconsistent with the Curve25519/EdDSA RFCs as it does not preserve the base point's sign properly.\r\n\r\n[RFC7748] defines the Montgomery form of Curve25519 to have a base point of:\r\n\r\n```\r\nu = 9\r\nv = 14781619447589544791020593568409986887264606134616475288964881837755586237401\r\n```\r\n\r\nBoth [RFC7748] and [RFC8032] define the Twisted Edwards form of Curve25519 to have a base point of:\r\n\r\n```\r\nx = 15112221349535400772501151409588531511454012693041857206046113283949847762202\r\ny = 46316835694926478169428394003475163141307993866256225615783033603165251855960\r\n```\r\n\r\nThe two square roots of `-486664` are:\r\n\r\n```\r\n+sqrt(-486664) = 6853475219497561581579357271197624642482790079785650197046958215289687604742\r\n-sqrt(-486664) = 51042569399160536130206135233146329284152202253034631822681833788666877215207\r\n```\r\n\r\nInterestingly, neither of the above RFCs explicitly specify which root to use, but when I extract the isomorphism factor by comparing the above base points, I get the negative square root:\r\n\r\n```\r\nv * x / u = 51042569399160536130206135233146329284152202253034631822681833788666877215207\r\n```\r\n\r\nI think the specification should require the sign of `sqrt(-486664)` to be `-1`, not `1`.\r\n\r\nIn Sage:\r\n\r\n``` sage\r\nF = GF(2^255 - 19)\r\nu = F(9)\r\nv = F(14781619447589544791020593568409986887264606134616475288964881837755586237401)\r\nx = F(15112221349535400772501151409588531511454012693041857206046113283949847762202)\r\ny = F(46316835694926478169428394003475163141307993866256225615783033603165251855960)\r\nc = sqrt(F(-486664))\r\n\r\nprint(c)\r\nprint(-c)\r\nprint(c != v * x / u)\r\nprint(-c == v * x / u)\r\nprint(c * u / v != x)\r\nprint(-c * u / v == x)\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\n6853475219497561581579357271197624642482790079785650197046958215289687604742\r\n51042569399160536130206135233146329284152202253034631822681833788666877215207\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\n```\r\n\r\n[draft1]: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#rational-maps-from-montgomery-to-twisted-edwards-curves-rational-map\r\n[draft2]: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#edwards25519-elligator-2-map-to-edwards25519\r\n[RFC7748]: https://tools.ietf.org/html/rfc7748#section-4.1\r\n[RFC8032]: https://tools.ietf.org/html/rfc8032#section-5.1",
      "createdAt": "2020-02-07T09:06:38Z",
      "updatedAt": "2020-02-24T02:39:23Z",
      "closedAt": "2020-02-24T02:39:23Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> [RFC7748](https://tools.ietf.org/html/rfc7748#section-4.1) defines the Montgomery form of Curve25519 to have a base point of:\r\n> \r\n> ```\r\n> u = 9\r\n> v = 14781619447589544791020593568409986887264606134616475288964881837755586237401\r\n> ```\r\n\r\nAre you aware of this change in the errata section?\r\nhttps://www.rfc-editor.org/errata/eid4730",
          "createdAt": "2020-02-07T18:26:00Z",
          "updatedAt": "2020-02-07T18:26:00Z"
        },
        {
          "author": "chjj",
          "authorAssociation": "NONE",
          "body": "> Are you aware of this change in the errata section?\r\n\r\nOh, I didn't catch that. Interesting. I guess this is not an issue after all. Feel free to close.",
          "createdAt": "2020-02-07T22:48:57Z",
          "updatedAt": "2020-02-07T22:48:57Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWU1NjU1MDUyNTM=",
      "title": "Appendix D.1. bug",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/207",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "(xn, xd, yn, nd) = map_to_curve(u) should be (xn, xd, yn, yd) = map_to_curve(u)",
      "createdAt": "2020-02-14T19:09:08Z",
      "updatedAt": "2020-02-23T21:40:06Z",
      "closedAt": "2020-02-23T21:40:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #209.",
          "createdAt": "2020-02-23T21:40:06Z",
          "updatedAt": "2020-02-23T21:40:06Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "MDU6SXNzdWU1NjU5Njc4MzU=",
      "title": "CMOV: inconsistency with Verifiable Random Functions draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/210",
      "state": "CLOSED",
      "author": "mratsim",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The definition of CMOV in the draft is:\r\n\r\nhttps://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-4\r\n\r\n> CMOV(a, b, c): If c is False, CMOV returns a, otherwise it returns\r\n      b.  To prevent against timing attacks, this operation must run in\r\n      constant time, without revealing the value of c.  Commonly,\r\n      implementations assume that the selector c is 1 for True or 0 for\r\n      False.  In this case, given a bit string C, the desired selector c\r\n      can be computed by OR-ing all bits of C together.  The resulting\r\n      selector will be either 0 if all bits of C are zero, or 1 if at\r\n      least one bit of C is 1.\r\n\r\nThe definition in the VRF spec is:\r\n\r\nhttps://tools.ietf.org/html/draft-irtf-cfrg-vrf-06#section-5.4.1.2 (at the bottom of ECVRF_hash_to_curve_elligator2_25519)\r\n\r\n> Alternatively, let CMOV(result_if_1, result_if_0, selector) be the\r\n   function that returns result_if_1 when selector is 1 and result_if_0\r\n   when selector is 0.\r\n>\r\n> [...]\r\n>\r\n> CMOV can\r\n   be implemented in constant time a variety of ways; for example, by\r\n   expanding b from a single bit to an all-0 or all-1 string\r\n   (accomplished by negating b in standard two's-complement arithmetic)\r\n   and then applying bitwise XOR and AND operations as follows: other_x\r\n   XOR ((x XOR other_x) AND b)\r\n\r\n=> The definitions are opposite in both specs\r\n\r\nI didn't find a Github repo for the VRF specs but given:\r\n- the overlap in intended audience of both specs (for example Algorand are implementing both hash to curve and VRF)\r\n- that the VRF spec also has a hash_to_curve section \r\nI think it would be best to have the same definition.",
      "createdAt": "2020-02-16T20:52:43Z",
      "updatedAt": "2020-05-22T23:17:15Z",
      "closedAt": "2020-05-22T23:17:15Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the report :+1:\r\n\r\nWe'll discuss with the VRF folks and push towards consistency.",
          "createdAt": "2020-02-24T02:40:08Z",
          "updatedAt": "2020-02-24T02:40:08Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here are a few remarks that might help decide one way or another:\r\n\r\n## At the word level\r\n\r\nAt the word level, `cmov` is often alternatively called `select`, `choose` or `mux` or the ternary C operator.\r\nIn all cases I came across, the order was always \r\n```python\r\ndef cmov(condition: ConstantTimeBool, result_if_1: Word, result_if_0: Word) -> Word\r\n  ## Return ``result_if_1`` if condition\r\n  ## else return ``result_if_0``\r\n```\r\n- C ternary operator\r\n- `cmov` instruction on x86 CPU.\r\n- LLVM `select`: https://llvm.org/docs/LangRef.html#select-instruction\r\n- BearSSL `mux` by @pornin: https://www.bearssl.org/gitweb/?p=BearSSL;a=blob;f=src/inner.h;h=07e1d0a478e801a91580658918130fb8b595e407;hb=HEAD#l767\r\n- Cryptocoding guidelines `select` by @veorq: https://github.com/veorq/cryptocoding#solution-1\r\n- `ct_choose` by @lmrs2: https://www.cl.cam.ac.uk/~rja14/Papers/whatyouc.pdf (https://github.com/lmrs2/ct_choose)\r\n\r\n## At the big int / field element level\r\n\r\nHowever at the big int level, `cmov`, `cmove` or `ccopy` is in the other order in the libraries I use\r\n```python\r\ndef cmov(a: mut Fp, b: Fp, condition: ConstantTimeBool) -> None\r\n  ## Copy ``b`` into ``a`` if ``condition``\r\n  ## else leave ``a`` as-is.\r\n```\r\n- BearSSL `ccopy` by @pornin: https://www.bearssl.org/gitweb/?p=BearSSL;a=blob;f=src/inner.h;h=07e1d0a478e801a91580658918130fb8b595e407;hb=HEAD#l903\r\n- Milagro `cmove` by @mcarrickscott: https://github.com/miracl/core/blob/9fa4af0ed170c0fb6a992b7d9cda2d0c2daebbab/c/fp.h#L137-L144\r\n- the current hash-to-curve draft\r\n\r\n## Analysis\r\n\r\n2 \"intuitive\" readings are conflicting:\r\n1. return first parameter if true, else return second (word-level)\r\n2. copy if true, else do nothing (bigint-level)\r\n\r\n## Proposal\r\n\r\nMaybe `ccopy` in both the hash-to-curve and the VRF specs would be a better name for conditional copying of field element to avoid potential confusion with the word-level `cmov`.",
          "createdAt": "2020-02-24T12:56:58Z",
          "updatedAt": "2020-02-24T13:00:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This might end up being solved without any change by H2C, because we're working with the VRF authors to get them to refer to H2C suites rather than defining their own hashing functions. If/when that happens, the offending portions of the VRF draft will no longer exist...",
          "createdAt": "2020-02-25T01:08:36Z",
          "updatedAt": "2020-02-25T01:08:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam do you think this conflict will be resolved by the 9th (draft deadline)? It would be good to close this out by then.",
          "createdAt": "2020-03-03T18:59:58Z",
          "updatedAt": "2020-03-03T18:59:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll try! I need to talk to the VRF folks about this asap. Once we land the outstanding PRs and get our suite names finalized, I can refresh the [VRF PR](https://github.com/fcelda/nsec5-draft/pull/35) and hopefully get it integrated.",
          "createdAt": "2020-03-04T09:24:30Z",
          "updatedAt": "2020-03-04T09:24:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam, what's the word here? Do we still need this issue?",
          "createdAt": "2020-05-20T23:21:49Z",
          "updatedAt": "2020-05-20T23:21:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "No, I think this will be taken care of once we come to an understanding with the VRF folks. But let's leave it for now to make sure it doesn't fall through the cracks.",
          "createdAt": "2020-05-21T02:06:51Z",
          "updatedAt": "2020-05-21T02:06:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "What do we need to come to an understanding with the VRF folks? Would it help to get everyone together on a call to discuss?",
          "createdAt": "2020-05-21T03:39:55Z",
          "updatedAt": "2020-05-21T03:39:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've been communicating with Leo actively in the last few days. For now, I think no call is necessary.",
          "createdAt": "2020-05-21T04:08:01Z",
          "updatedAt": "2020-05-21T04:08:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Whoops!)",
          "createdAt": "2020-05-21T13:25:01Z",
          "updatedAt": "2020-05-21T13:25:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Integrated the PR into VRF, so this is done now :)",
          "createdAt": "2020-05-22T23:17:15Z",
          "updatedAt": "2020-05-22T23:17:15Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "MDU6SXNzdWU1NzI0Nzk0MDM=",
      "title": "suite ID questions: field separator, user data",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/213",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@armfazh [suggests](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212#discussion_r385295475) that we change the field separator in Suite ID from `-` to something else, so that we can use `-` in hash names.\r\n\r\nThoughts on other options?\r\n\r\nThe reason that both `-` and `_` are currently excluded in the document is that this lets upper-layer protocols use `_` for field separators while including the hash-to-curve suite name verbatim in their suite name (that's what BLS signatures does now, for example). So I'd rather not use `_`.\r\n\r\n`:` or `|` could work. Other thoughts?",
      "createdAt": "2020-02-28T02:23:34Z",
      "updatedAt": "2020-03-05T18:46:06Z",
      "closedAt": "2020-03-05T18:46:06Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "In [a chain of comments](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212#discussion_r385298672) on #212, we also discussed whether it would be better to allocate an extra field in the Suite-ID for \"user defined\" data.\r\n\r\nRight now, the text recommends adding user-defined data as an optional subfield of the the ENC_VAR field, separated by a colon:\r\n\r\n    ... || ENC_VAR [ ':' USER_DATA ] || '-'\r\n\r\nThe alternative we were discussing is to add a new field, separated by the field separator (currently hyphen, but see above):\r\n\r\n    ... || ENC_VAR || '-' || USER_DATA || '-'\r\n\r\nThe upside of the alternative is that it's nice and uniform. The downside is that it requires that we add an extra field separator to *all* Suite-IDs to ensure that Suite-IDs are prefix-free.",
          "createdAt": "2020-02-28T17:21:03Z",
          "updatedAt": "2020-02-28T17:21:29Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Please recall me why Suite-IDs must be prefix-free? ",
          "createdAt": "2020-02-28T20:07:48Z",
          "updatedAt": "2020-02-28T20:07:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the separator, what if we use parenthesis, e.g. (curve)(SHA-256)(SSWU)(RO)(UDATA).\r\nWhat is the purpose of SuiteIDs (besides being a unique identifier)? -- It will be parsed? -- I think answer is No. \r\n \r\n",
          "createdAt": "2020-02-28T20:13:29Z",
          "updatedAt": "2020-02-28T20:13:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One more thing to potentially discuss: do we want to get rid of EXP_TAG for the default expand_message variants? @armfazh [suggested this](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212#discussion_r385294732). I think @chris-wood and I are in favor of keeping EXP_TAG, but happy to discuss more in this issue, too.",
          "createdAt": "2020-02-28T21:28:30Z",
          "updatedAt": "2020-02-28T21:28:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Please recall me why Suite-IDs must be prefix-free?\r\n\r\nIt's not strictly necessary, and certainly it doesn't help the security of hash-to-curve itself.\r\n\r\nBut it's slightly nice to have, because it means that upper-level protocols can rely on Suite IDs being prefix-free, e.g., when using the Suite-ID as part of a domain separation tag that is required to be prefix-free.\r\n\r\nSo basically it's just a hedge against misuse.\r\n\r\nIf we decide it's annoying or too costly, we can forget about it.",
          "createdAt": "2020-02-28T21:34:08Z",
          "updatedAt": "2020-02-28T21:34:08Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking more on this, I see the need for an EXT_TAG. \r\nHowever, I am not entirely agree on replacing algorithm names, e.g. `SHA-256` by `SHA.256`. \r\nI think using parenthesis or other separator will solve this issue too.",
          "createdAt": "2020-02-28T21:36:51Z",
          "updatedAt": "2020-02-28T21:36:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's fairly common to use `_` to separate fields in suites. Can we do that? (I recognize that upper-layers use `_`, but that doesn't seem like it should preclude use here.)\r\n\r\n```\r\nCURVE_ID || \"_\" || HASH_ID || \"_\" || MAP_ID || \"_\" || ENC_VAR || \"_\"\r\n```\r\n\r\nThat would let us keep `SHA-256`, for example, right? If we really don't want this, let's just go with `|`.  ",
          "createdAt": "2020-03-03T19:03:39Z",
          "updatedAt": "2020-03-03T19:07:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with `_` or `|`.\r\n\r\nIn the case of `_`, I suppose since we have a fixed number of underscores in our suite-id we don't interfere with prefix-freeness in upper-layer suite IDs that use underscores for separation and include our suite ID verbatim.",
          "createdAt": "2020-03-04T05:44:13Z",
          "updatedAt": "2020-03-04T05:44:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "So, where do we stand on USER_DATA? I'm still liking the optional, colon-delimited subfield of ENC_VAR better than a whole new field since it probably won't get used that often (ever?)",
          "createdAt": "2020-03-04T09:38:28Z",
          "updatedAt": "2020-03-04T09:38:28Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "If USER_DATA is likely not to be used, I will vote for removing it. Also this extra info don't play role on the internals of the Suite. As opposed to the other fields.",
          "createdAt": "2020-03-05T01:04:00Z",
          "updatedAt": "2020-03-05T01:04:00Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "We can go forward with '_' as a separator, it matches well with valid variable identifiers in many programming languages.",
          "createdAt": "2020-03-05T01:05:27Z",
          "updatedAt": "2020-03-05T01:05:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! Let's go with `_` and remove `USER_DATA` (in favor of colon-deliminated subfield of `ENC_VAR`). @kwantam, sound good?",
          "createdAt": "2020-03-05T01:06:31Z",
          "updatedAt": "2020-03-05T01:06:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! I'll roll these changes into #214.",
          "createdAt": "2020-03-05T01:08:37Z",
          "updatedAt": "2020-03-05T01:08:37Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> remove `USER_DATA` (in favor of colon-deliminated subfield of `ENC_VAR`).\r\n\r\nI was also considering removing the subfield from ENC_VAR.  \r\n",
          "createdAt": "2020-03-05T01:12:55Z",
          "updatedAt": "2020-03-05T01:12:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was also considering removing the subfield from ENC_VAR.\r\n\r\nRight now it's only a recommendation. If we leave it this way, then at least we're helping people to channel their ~~creativity~~user data somewhere harmless...",
          "createdAt": "2020-03-05T01:22:19Z",
          "updatedAt": "2020-03-05T01:22:19Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1NzM1ODUzNjk=",
      "title": "Test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/216",
      "state": "CLOSED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kwantam"
      ],
      "labels": [],
      "body": "I'd like to argue that it wouldn't be inappropriate to have test vectors exercise conditions in algorithms, or more specifically both outcomes of CMOVs/if conditions. As opposite to just a limited number of specific strings fed to all algorithms,the set that is obviously too small to trigger all conditions in any chosen algorithm. Given current state [when test input is passed to hash_to_field] it naturally ~causes~ poses a challenge, as one would have to search for inputs that trigger specific conditions, but it shouldn't be a heavy computational problem.\r\n\r\nOn related note one can also wonder if it would be beneficial to ensure that [sufficient amount of] inputs to sgn0 are \"endian-unambiguous\". By \"endian ambiguity\" I mean that a specific input can yield same sign for both little- and big-endian variants of sgn0, in which case implementation invoking wrong sgn0 would pass the corresponding test.\r\n\r\nAlso, it might be useful to provide intermediate results from inputs to corresponding map_to_curves, as opposite for complete stack, so that map_to_curves can be tested by themselves. Does it make sense?\r\n",
      "createdAt": "2020-03-01T17:40:48Z",
      "updatedAt": "2020-06-01T21:44:08Z",
      "closedAt": "2020-06-01T21:44:08Z",
      "comments": [
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's currently quite hard to read your proposals. Can you reformat them?",
          "createdAt": "2020-03-01T22:32:48Z",
          "updatedAt": "2020-03-01T22:32:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@dot-asm thanks for the suggestion.\r\n\r\nI agree that it's useful to have test vectors that exercise the conditionals, to the extent possible. For example, it should be relatively easy to pick a set of vectors that exercise different signs, pick either x0 or x1, etc.\r\n\r\nI should note, however, that it is not feasible to create end-to-end test vectors that exercise all of the exceptional conditions in the mappings (because we'd have to, e.g., find an input string that hashes to 0). For these cases, it make sense to test just the mapping functions (without hash_to_field); this is straightforward because we know exactly what the exceptional inputs are for every mapping. The code in `poc` does this already.\r\n\r\nMy guess is that the document will include a relatively small number of tests for each suite, but as you suggest, we should certainly choose these tests to find as many bugs as possible. For extensive testing, my guess is that folks will still need to cross-validate against the `poc/` implementations.",
          "createdAt": "2020-03-01T22:56:04Z",
          "updatedAt": "2020-03-01T22:56:04Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it is not feasible to create end-to-end test vectors that exercise all of the exceptional conditions in the mappings (because we'd have to, e.g., find an input string that hashes to 0).\r\n\r\nAh! Correct! There are conditions that are indeed infeasible.\r\n\r\n> the document will include a relatively small number of tests for each suite\r\n\r\nOr why not a reference to this repository and explicit instructions where to find the most up-to-date set. Or reference to a dedicated page if deemed more appropriate.\r\n\r\n> For extensive testing, my guess is that folks will still need to cross-validate against the poc/ implementations.\r\n\r\nFormally speaking it's a little bit more subtle than this. Because there is component that is customarily beyond implementer's control, compiler. In sense that irregardless how close implementation complies with reference, it doesn't necessarily prevent compiler from generating bad code. [I had a problem just another day.]\r\n\r\nSo as initial and enabling step, would it be appropriate to extend `vectors` with intermediate value from input to map_to_curve? And then make \"msg\" field optional to facilitate infeasible cases? Should I pursue this, or would maintainers prefer to do it themselves?",
          "createdAt": "2020-03-02T09:57:59Z",
          "updatedAt": "2020-03-02T09:57:59Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's currently quite hard to read your proposals. Can you reformat them?\r\n\r\nI've broken initial post to three paragraphs. Does it look better? Basically it revolves around the same issue [in my head], which is why it was a single blob.",
          "createdAt": "2020-03-02T10:03:14Z",
          "updatedAt": "2020-03-02T10:03:14Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Intermediate tests are valuable, it allows to pinpoint issues more easily. This is what I did when implementing the previous draft, I have internal sanity checks on hash_to_base and map_to_curve against another implementation (https://github.com/status-im/nim-blscurve/blob/f01705182204fc0df33857bb417c76115d83a2cc/blscurve/hash_to_curve.nim#L483-L604).\r\n\r\n> > For extensive testing, my guess is that folks will still need to cross-validate against the poc/ implementations.\r\n> \r\n> Formally speaking it's a little bit more subtle than this. Because there is component that is customarily beyond implementer's control, compiler. In sense that irregardless how close implementation complies with reference, it doesn't necessarily prevent compiler from generating bad code. [I had a problem just another day.]\r\n\r\nIn addition to manually crafted vectors, auto-generated vectors from the reference implementation would be helpful, people would just need to download them as a sanity check. This also avoids package versioning issues (like Python 2~3). In terms of volume, a couple MB would be reasonable (compressed though hashes shouldn't compress well).\r\n\r\nAn alternative would be to provide a Python virtualenv (or Docker) but that seems quite involved.\r\n\r\nThe vectors can even be autogenerated by Github Actions or any CI (Azure pipelines, Travis or Appveyor) but that's probably overkill as well since when the spec is finalized the vectors should change.\r\n",
          "createdAt": "2020-03-02T11:24:52Z",
          "updatedAt": "2020-03-02T11:24:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Or why not a reference to this repository and explicit instructions where to find the most up-to-date set. Or reference to a dedicated page if deemed more appropriate.\r\n\r\nI believe there is already a reference to the code in the document. I'll double check that it's in an obvious place.\r\n\r\n> Formally speaking it's a little bit more subtle than this. Because there is component that is customarily beyond implementer's control, compiler. In sense that irregardless how close implementation complies with reference, it doesn't necessarily prevent compiler from generating bad code. [I had a problem just another day.]\r\n\r\nSorry, I don't understand this comment. If the compiler generates incorrect code, the test vectors will presumably mismatch. So what is the proposed action here? I don't think that any number of test vectors will suffice to prove that an arbitrary implementation complies with the spec. More to the point: the test vectors *are not intended* for this purpose! They're a basic sanity check. Implementors are expected to do their own testing beyond the vectors provided in the document.\r\n\r\nOn the other hand, since the reference implementation will be linked from the document, implementors can very easily cross-validate their implementation against the reference. That still doesn't prove anything in a formal sense (the reference implementations aren't formally verified, after all), but it's much more of a debugging aid than a static set of vectors.\r\n\r\n> So as initial and enabling step, would it be appropriate to extend `vectors` with intermediate value from input to map_to_curve?\r\n\r\nYes, this is a good idea.\r\n\r\n> And then make \"msg\" field optional to facilitate infeasible cases?\r\n\r\nProbably this is beyond the scope of test vectors in the document, which are intended as end-to-end sanity checks. And the infeasible cases are already covered by the document: the definition of every map describes all exceptional cases and the expected outputs. (But it might make sense to add a note reminding implementors of this fact.)\r\n\r\nI'm happy to look at a PR, but I'm also happy to take care of it once the current PRs settle out.",
          "createdAt": "2020-03-02T17:30:10Z",
          "updatedAt": "2020-03-02T17:30:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Intermediate tests are valuable, it allows to pinpoint issues more easily. This is what I did when implementing the previous draft, I have internal sanity checks on hash_to_base and map_to_curve against another implementation (https://github.com/status-im/nim-blscurve/blob/f01705182204fc0df33857bb417c76115d83a2cc/blscurve/hash_to_curve.nim#L483-L604).\r\n\r\nVery cool. As another example, the [bls sigs ref code](/algorand/bls_sigs_ref) also uses intermediate test vectors.\r\n\r\n> In addition to manually crafted vectors, auto-generated vectors from the reference implementation would be helpful, people would just need to download them as a sanity check.\r\n\r\nWait, what's the distinction here? The vectors that we include in the document will be automatically generated. Is this just saying that we should make a whole bunch of them available out-of-line?\r\n\r\nI assume we'd just check them into the repo. No need to compress, git already does that transparently when sending things over the network. Users can supply `--depth 1` if they really don't want the whole repo history (and I assume that github makes something like grabbing a tarball of master easy, though I don't think I've ever done it).\r\n\r\n> This also avoids package versioning issues (like Python 2~3). In terms of volume, a couple MB would be reasonable (compressed though hashes shouldn't compress well).\r\n> \r\n> An alternative would be to provide a Python virtualenv (or Docker) but that seems quite involved.\r\n\r\nHmm. The poc code is all written in Sage, it uses no packages outside the base Sage installation, and we test it against both modern versions. So I think the packaging issues you're alluding to don't really exist in a meaningful way (beyond \"cannot get Sage running,\" which seems out of scope and/or easily handled by spinning up a VM). In particular, virtualenv doesn't seem to help because this is not a Python codebase as such.",
          "createdAt": "2020-03-02T17:39:43Z",
          "updatedAt": "2020-03-02T17:40:14Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Action items so far from this thread:\r\n\r\n- [x] make sure that poc code is linked in an obvious place in the doc (say, in the test vectors appendix)\r\n- [x] add intermediate values (output of hash-to-field, output of map-to-curve before cofactor clearing) to test vectors\r\n- [x] ~choose test vectors that give reasonable branch coverage (e.g., different signs, x1 vs x2, etc)~ see #276 (but note that as described there we don't try to cover signs or exceptional cases)\r\n- [x] ~choose test vectors such that sgn0 result is distinct for sgn0_le vs sgn0_be~ no longer needed, only one sgn0 now\r\n- [ ] incorporate @jedisct1's suggestions below\r\n\r\nPlease let me know if I'm missing any.",
          "createdAt": "2020-03-02T17:44:05Z",
          "updatedAt": "2020-06-01T21:29:09Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > In addition to manually crafted vectors, auto-generated vectors from the reference implementation would be helpful, people would just need to download them as a sanity check.\r\n> \r\n> Wait, what's the distinction here? The vectors that we include in the document will be automatically generated. Is this just saying that we should make a whole bunch of them available out-of-line?\r\n\r\nI was under the impression that there were manually crafted vectors that triggered edge cases.\r\n\r\n> I agree that it's useful to have test vectors that exercise the conditionals, to the extent possible. For example, it should be relatively easy to pick a set of vectors that exercise different signs, pick either x0 or x1, etc.\r\n\r\nI suppose crafting them is more involved and so we would have fewer. I suggested to also add random vectors to the mix. Now if triggering special cases can be automated you can disregard that part of my comment.",
          "createdAt": "2020-03-03T10:58:33Z",
          "updatedAt": "2020-03-03T10:58:33Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe there is already a reference to the code in the document.\r\n\r\nThe keyword was rather \"explicit instructions where to find the most up-to-date set.\" As alternative to providing test vectors in the document.\r\n\r\n> Sorry, I don't understand this comment. If the compiler generates incorrect code, the test vectors will presumably mismatch.\r\n\r\nImagine a set of test vectors that don't hit some condition. If compiler generates bad code for **that** condition, then test vectors will pass, and you wouldn't know that there is a problem. And this is provided that high-level language implementation is actually correct, so you would be kind of entitled to not expect problems.\r\n",
          "createdAt": "2020-03-03T11:59:34Z",
          "updatedAt": "2020-03-03T11:59:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Imagine a set of test vectors that don't hit some condition. If compiler generates bad code for **that** condition, then test vectors will pass, and you wouldn't know that there is a problem.\r\n\r\nAh, now I understand. Thanks for the clarification.\r\n\r\nJust so that we're on the same page (and at the risk of repeating myself---sorry!): detecting that kind of thing is **not** the point of the test vectors. If we're assuming the compiler is allowed to do arbitrarily incorrect things, no reasonably-sized set of test vectors can possibly rule out miscompilation of this kind (because, for example, the incorrect code might give incorrect output only for one particular input).",
          "createdAt": "2020-03-03T17:05:21Z",
          "updatedAt": "2020-03-03T17:05:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The keyword was rather \"explicit instructions where to find the most up-to-date set.\" As alternative to providing test vectors in the document.\r\n\r\nA quick note: test vectors for sanity checking must go into the document, because the document is likely to outlive GitHub or wherever the source code is stored.",
          "createdAt": "2020-03-03T17:09:01Z",
          "updatedAt": "2020-03-03T17:09:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suppose crafting them is more involved and so we would have fewer. I suggested to also add random vectors to the mix. Now if triggering special cases can be automated you can disregard that part of my comment.\r\n\r\nFortunately, almost every conditional that's feasible to hit (i.e., ones not requiring a hash preimage) happens with some reasonable probability, so it's easy to generate random inputs and check which code paths they exercise. Should be reasonably easy to automate given that every suite only has a small number of conditionals.",
          "createdAt": "2020-03-03T17:12:13Z",
          "updatedAt": "2020-03-03T17:12:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#217 adds test vectors to the document. For now we're just generating vectors from the same three inputs for each suite, but we can change this in a later revision.",
          "createdAt": "2020-03-09T06:12:36Z",
          "updatedAt": "2020-03-09T06:12:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood @armfazh : are we at all worried about the sheer number of test vectors in the document? According to `wc`, the test vectors take up about 1/2 of the document.\r\n\r\n(I'm not saying this definitely *is* a problem, but I wonder if it makes the document unwieldy or something?)",
          "createdAt": "2020-03-09T19:27:13Z",
          "updatedAt": "2020-03-09T19:27:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> are we at all worried about the sheer number of test vectors in the document? According to wc, the test vectors take up about 1/2 of the document.\r\n\r\nI'm not. I'd rather the document be verbose, and absent a better place to archive test vectors, putting them in the document seems fine.",
          "createdAt": "2020-03-09T19:28:22Z",
          "updatedAt": "2020-03-09T19:28:22Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On vaguely related note reference to `{#suites}` is mistyped in new \"Test vectors\" appendix. It should be `{{suites}}`.",
          "createdAt": "2020-03-10T21:32:18Z",
          "updatedAt": "2020-03-10T21:32:18Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Speaking of test vectors:\r\n\r\n- Maybe it would be good to have at least one vector with a large DST.\r\n- The DSTs of the test vectors all start with the suite, leading to think that this is a requirement (that could totally be justified). The actual document makes it clear that the suite is not required in the construction of the DST. But to avoid confusion, maybe the tests DST prefixes should be closer to a protocol and version number as recommended in the document.",
          "createdAt": "2020-04-03T08:06:43Z",
          "updatedAt": "2020-04-03T08:06:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I'm going to see whether there's an easy way to get better branch coverage with test vectors later tonight. If I find something useful I'll make a PR.",
          "createdAt": "2020-06-01T00:57:32Z",
          "updatedAt": "2020-06-01T00:57:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good! I couldn't find an easy way to get coverage with Sage. I'm very curious to know if you find (or make) one. ",
          "createdAt": "2020-06-01T00:59:46Z",
          "updatedAt": "2020-06-01T00:59:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Guessing if I make one it'll be a really shameful hack :stuck_out_tongue_closed_eyes:",
          "createdAt": "2020-06-01T01:04:13Z",
          "updatedAt": "2020-06-01T01:04:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Heh, yeah, that's basically what I ended up trying to do. Something like looking at calling stack traces and then making sure all branches were covered. It was not pretty.",
          "createdAt": "2020-06-01T01:12:09Z",
          "updatedAt": "2020-06-01T01:12:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Argh, OK, not much progress tonight. I'll spend some more time on this tomorrow evening.",
          "createdAt": "2020-06-01T06:41:33Z",
          "updatedAt": "2020-06-01T06:41:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think #276 takes care of everything here except an example of a DST longer than 255 bytes (which would require pre-hashing).\r\n\r\nIf we decide not to add that, then we can close this issue. Thoughts @chris-wood @armfazh ?",
          "createdAt": "2020-06-01T21:36:07Z",
          "updatedAt": "2020-06-01T21:36:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can close it as is. Both `expand_message` variants demand DSTs be less than 256 bytes, so anything longer seems like it wouldn't add much value. ",
          "createdAt": "2020-06-01T21:42:38Z",
          "updatedAt": "2020-06-01T21:42:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great. I'm closing, but anyone should feel free to reopen if this seems incorrect!",
          "createdAt": "2020-06-01T21:44:08Z",
          "updatedAt": "2020-06-01T21:44:08Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWU1NzcyMzYwNzk=",
      "title": "BP18 reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/218",
      "state": "CLOSED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "BP18 appears to be a poster summary of real thing. Wouldn't it be more appropriate to point at \"Efficient hash maps to G2 on BLS curves\" instead?\r\n",
      "createdAt": "2020-03-07T00:02:40Z",
      "updatedAt": "2020-03-07T00:15:02Z",
      "closedAt": "2020-03-07T00:14:38Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Got it.",
          "createdAt": "2020-03-07T00:15:02Z",
          "updatedAt": "2020-03-07T00:15:02Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWU1NzgzNzE5NDM=",
      "title": "Q: What is the output size of H for long DST strings?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/220",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What is the size of the output of  `H`, when a suite defines expand_message_xof,\r\n`DST = H(\"H2C-OVERSIZE-DST-\" || a_very_long_DST)`",
      "createdAt": "2020-03-10T06:49:56Z",
      "updatedAt": "2020-03-13T19:59:40Z",
      "closedAt": "2020-03-13T19:59:40Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question. You're absolutely right, this is not written clearly. I'll edit and open a PR.",
          "createdAt": "2020-03-10T17:08:15Z",
          "updatedAt": "2020-03-10T17:08:15Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWU1ODA3OTEyMzM=",
      "title": "Security parameter on ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/222",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I was curious about setting the security level (`k`) for curves.\r\n\r\nFor example, before [ia.cr/2015/1027](ia.cr/2015/1027), BN-256 was believed to provide k=128. However, due to the advances on NFS, parameters of curves must be updated.\r\n\r\nSo, setting `k` in some ciphersuites means that we must \r\na) choose the recommended parameter in the spec, or \r\nb) use the latest `k` known to date?\r\n\r\nIt is unclear when the next advance on NFS will happen, but what will be the k parameter used when this happens?\r\n\r\n",
      "createdAt": "2020-03-13T19:12:35Z",
      "updatedAt": "2020-03-18T19:17:53Z",
      "closedAt": "2020-03-18T19:17:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a great point.\r\n\r\nReally, the reason we specify k is so that everyone arrives at the same value for hash_to_field. So we should probably point out that the `k` values specified in the ciphersuite are *upper bounds* on the security level of the curves (which we use to ensure that hash_to_field is designed conservatively), and should not be regarded as an endorsement or guarantee that a curve gives a specific security level.",
          "createdAt": "2020-03-13T20:04:20Z",
          "updatedAt": "2020-03-13T20:04:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> So we should probably point out that the k values specified in the ciphersuite are upper bounds on the security level of the curves (which we use to ensure that hash_to_field is designed conservatively), and should not be regarded as an endorsement or guarantee that a curve gives a specific security level.\r\n\r\nThis is a great suggestion! I can prepare a PR to this effect, unless you've already started @kwantam?",
          "createdAt": "2020-03-13T22:19:39Z",
          "updatedAt": "2020-03-13T22:19:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't started one, but I'm happy to do it if you don't get to it first :)",
          "createdAt": "2020-03-13T23:39:23Z",
          "updatedAt": "2020-03-13T23:39:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I found in [SP-800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) methods similar to ours for generating random bits and from them generate random numbers. See Section A.5, we are actually using Method in A.5.3, where `s` is our `k` security parameter.\r\n\r\nAdditionally, there are recommended methods for generating random bits using hash functions. The content of this document could be useful for describing hash_to_field.\r\n\r\n",
          "createdAt": "2020-03-18T01:06:45Z",
          "updatedAt": "2020-03-18T01:06:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I seem to recall that the hash_drbg in SP-800-90A has some minor issues. One is its complexity!\r\n\r\nI think this is the paper I'm remembering: https://eprint.iacr.org/2018/349\r\n\r\nI don't think any of the additional complexity buys us anything, but I could be missing something.\r\n\r\nI'm going to put together a PR for #223 in the next couple days. We don't have to make any change, but I want to be clear what the changes would be if we do.",
          "createdAt": "2020-03-18T03:24:24Z",
          "updatedAt": "2020-03-18T03:24:24Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU1ODE0MjU4MDg=",
      "title": "expand_message_xmd : a potential optimization",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/223",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi folks,\r\n\r\nIt occurs to me that there's one possible modification to expand_message_xmd that would make it slightly nicer for some users. It's not a clear and unqualified win, but it's worth at least discussing.\r\n\r\nRight now, expand_message_xmd computes the following:\r\n\r\n    Z_pad = I2OSP(0, <block length of H>)\r\n    b_0 = H(Z_pad || msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(strxor(b_0, b_(i-1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThis is to ensure that `b_0` and `b_i` (i >= 1) are hashed with different initialization vectors. The downside of this approach is that some protocols will already have computed `H(msg || ...)`, and the above means that they have to pass over `msg` again to compute `b_0`.\r\n\r\nWe could instead consider doing this:\r\n\r\n    b_0 = H(msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_1 = H(Z_pad || b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(Z_pad || strxor(b_0, b_(i-1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThis also ensures that `b_0` and `b_i` (i >= 1) are hashed starting from different initialization vectors, but now implementors can reuse the work computing `H(msg || ...)` in `b_0`.\r\n\r\nThis looks like strictly more hashing work, since all the `b_i` need to be prefixed with a block of 0s. But as we know, most of the time implementations allow you to preload the state of the hash function, so in practice it's possible to optimize this away. On the other hand, anyone who *doesn't* want to implement this optimization *will* pay extra for hashing.\r\n\r\nSo the question is, do we enable a potentially nice optimization at the cost of making un-optimized implementations slower?\r\n\r\n(This assumes, of course, that we're willing to make any change at all. But now's the time for a change, since to my knowledge no one except me has actually implemented the new hash_to_field functions yet.)",
      "createdAt": "2020-03-14T23:56:19Z",
      "updatedAt": "2020-03-25T23:32:24Z",
      "closedAt": "2020-03-25T23:32:24Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(cc @armfazh @chris-wood )",
          "createdAt": "2020-03-14T23:56:31Z",
          "updatedAt": "2020-03-14T23:56:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "My take is that most un-optimized implementations won't see much increase in cost, whereas optimized implementations *would* enjoy significant savings for long `msg` values. So on balance I'd lean towards making this change. Otherwise, we're kind of stuck in a middle ground: un-optimized implementations are almost imperceptibly faster, but optimized ones are 2x slower in the huge-`msg` asymptote.\r\n\r\n---\r\n\r\nOne additional advantage is that changing the design as described above might *discourage* people from defining prehash modes, which is probably a good thing security-wise.",
          "createdAt": "2020-03-14T23:59:38Z",
          "updatedAt": "2020-03-15T00:00:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thinking about this more, the suggestion doesn't quite work: if `msg` starts with a full block of `0`s, then indifferentiability is broken.\r\n\r\nWe might instead consider:\r\n\r\n    b_0 = H(msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n\r\n    Z_pad = I2OSP(0, r_in_bytes - b_in_bytes)\r\n    b_i = H(b_0 || Z_pad || b_(i-1) || I2OSP(i, 1) || DST_prime)\r\n\r\nNow every b_i hash starts with a block comprising `b_0 || 000...000`, which is distinct from the first block of `msg` unless an attacker can find `msg` starting with the block `X || 000...000` where X == H(msg). I have to think more about the difficulty of this problem.\r\n\r\nThe advantage of this construction over the current one is that this lets us reuse work for computing `H(msg || ...)`. The cost is that an optimal implementation costs one extra compression function evaluation (to compute `h(IV, b_0 || 000...000)`). In other words, we make it slightly friendlier for reusing work, at the cost of exactly one more compression function invocation.\r\n\r\nThoughts?",
          "createdAt": "2020-03-19T04:55:58Z",
          "updatedAt": "2020-03-19T05:05:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam ACKing this issue! I'll implement the different variants and get some benchmarks. ",
          "createdAt": "2020-03-19T17:45:18Z",
          "updatedAt": "2020-03-19T17:45:18Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking more about this, I think the proposal in my [prior message](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/223#issuecomment-600988563) ends up assuming a lot more about the security of the compression function than the current version of xmd does (and, in particular, seems to assume a property that isn't really standard). So I think we'd be better off with the current version, just for the sake of being conservative with security.\r\n\r\n---\r\n\r\nDetails:\r\n\r\nRecall that the current version of xmd ensures that the \"inner\" invocation of H (to compute `b_0`) starts with a different initialization vector than the \"outer\" invocations (to compute `b_i`) by fixing the first block of the inner H's input to the all-zeros block (this suffices to guarantee that the outer and inner IVs are always different, thanks to the way we use the counter). And this is precisely the reason that the work computing the inner H invocation can't be reused by other pieces of an invoking protocol---we need to prepend a fixed block to `msg` to change the IV of the inner hash invocation.\r\n\r\n(Of course, the invoking protocol is welcome to use `H(Z_pad || msg || ...)` rather than `H(msg || ...)` if they want!)\r\n\r\nThe version I proposed in the prior message tries to ensure that the inner and outer invocations use different IVs by fixing the first block of the outer invocation (rather than the inner one). But for this to work, it has to be the case that the adversary can't craft an input to the inner invocation that causes the outer and inner IVs to match---and to rule this out, we need to rely on some property of the hash function that doesn't seem like a standard one.\r\n\r\nWhat property do we need? Well, contrary to what I initially posted above, it's certainly not enough for H to have preimage resistance, because this isn't quite a preimage attack:\r\n\r\n1. Preimage resistance: given some target X, come up with a message m such that X = H(m)\r\n2. What we would need: come up with any X and m such that X = H(X || 000...000 || m)\r\n\r\n(The attacker has strictly more power in the second case than in the first, so we should expect hash functions to be weaker against the second kind of attack than against a preimage attack.)\r\n\r\nIt's also not any of the standard prefix-resistance properties, since those fix a prefix for the attacker to target. We might call what we're looking for prefix-fixpoint-resistance. But since this doesn't appear to be anything like a standard notion of security, it seems at best dubious to base the security of the construction on it.\r\n\r\nAs more evidence that this isn't a great idea, we know that it's relatively easy to find a fixpoint for a Davies-Meyer--style compression function like the one used in SHA-2. I have no idea whether this can be extended to make the attack work, but it seems to be a crack in the armor...",
          "createdAt": "2020-03-19T19:59:01Z",
          "updatedAt": "2020-03-19T20:00:14Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider that we must be act with caution, since it is easy to make wrong decisions that could lead to attacks.\r\nIt would be ideal to have a security proof of the extraction of pseudo random bytes. However, even the authors of eprint.iacr.org/2018/349 had a difficulties on analyzing the algorithms in SP-800-90A.\r\n\r\nAs a matter of sanity, we could take some time to revisit the simplest and secure approach, and from it, departing to make some improvements.",
          "createdAt": "2020-03-19T22:35:34Z",
          "updatedAt": "2020-03-19T22:35:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, since it seems like there's no way to make this work-savings proposal happen unless we're willing to make some weird assumption about a hash function, how about we table this for now and revisit if any of us comes up with a better idea?\r\n\r\n---\r\n\r\nMeanwhile, I think @armfazh is right that we want to write down a detailed analysis of the current expand_message_xmd function.\r\n\r\nJust for the sake of completeness, here's a variant of our current function that gets rid of the XOR operation, at the cost of one more compression function invocation. (The security analysis of this one is somewhat easier because it doesn't use XOR chaining.)\r\n\r\n    b_0 = H(Z_pad || msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_0_pad = b_0 || I2OSP(0, r_in_bytes - b_in_bytes)    # pad b_0 to 1 block\r\n    for i in (1, ..., ell):\r\n        b_i = H(b_0_pad || b_(i - 1) || I2OSP(i, 1) || DST_prime)\r\n\r\nHere, unless `b_0_pad = Z_pad` (which requires finding a first preimage), the inner and outer H functions have independent IVs. Meanwhile, because of the counter, all of the messages are distinct.\r\n\r\nThe extra compression function invocation is to compute `h(IV, b_0_pad)` once; this can be reused for all `b_i` computations, which thereafter require as little as one compression function invocation (depending on the length of DST). This is cheaper than what we considered in #214,\r\n\r\n    b_i = H(b_0 || b_(i-1) || I2OSP(i, 1) || DST_prime)\r\n\r\nwhich would require at least two compression function invocations for every `b_i`.",
          "createdAt": "2020-03-20T17:39:42Z",
          "updatedAt": "2020-03-20T17:39:42Z"
        }
      ]
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWU1ODQwNTA2MDk=",
      "title": "feedback about sgn0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/225",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mike Scott sent me an email with several pieces of feedback on sgn0. Let's discuss if/how to handle these in this issue, and then I'll put together a PR.\r\n\r\nThe high-level message is that the sgn0 definitions are too complex, and may lead to implementation errors. Specific suggestions:\r\n\r\n1. Get rid of `sgn0_be` and only use `sgn0_le`.\r\n\r\n    - Pros: only one sgn0 variant would be great.\r\n    - Cons: this would mean that existing curves that use `sgn0_be` for point compression wouldn't be able to reuse that implementation for hashing. Also, it looks like the BLS12-381 community is pretty firmly entrenched at this point, which would make life hard for the BLS signatures draft.\r\n\r\n2. If sgn0 returns 0 for positive or zero, and 1 for negative, then it (at least, `sgn0_le`) could be much simpler, especially for the `m=1` case:\r\n\r\n        def sgn0_le(x):\r\n            return x mod 2\r\n\r\n    This could also be made quite simple for quadratic extensions:\r\n\r\n        def sgn0_le(x):   # x = (x_1, x_2)\r\n            p0 = x_1 == 0\r\n            p1 = x_1 mod 2\r\n            p2 = x_2 mod 2\r\n            return p1 | (p0 & p2)\r\n\r\n    - Pros: simplifies specifying `sgn0_le`. Not clear whether it simplifies `sgn0_be`, but it might.\r\n    - Cons: is (0, 1) less intuitive than (1, -1) for (positive, negative) respectively?\r\n\r\n3. Rather than specifying field extension sgn0 in terms of vector representations, specify it in terms of towering. That is, express sgn0 for Fp2 in terms of two calls to sgn0 for Fp; sgn0 for Fp4 in terms of two calls to sgn0 for Fp2; etc.\r\n\r\n    - Pros: may result in simpler constant-time implementations.\r\n    - Cons: requires us to define towering at sufficient detail in the document to actually specify this approach. Is not compatible with any existing point compression technique that I'm aware of.",
      "createdAt": "2020-03-18T22:54:42Z",
      "updatedAt": "2020-04-03T17:15:11Z",
      "closedAt": "2020-03-29T15:07:46Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my take.\r\n\r\nFirst, to address the complexity of the current spec, we could give simplified versions of `sgn0_le` and `sgn0_be` for the m=1 case, and maybe also for the m=2 case for `sgn0_be`.\r\n\r\nPoint-by-point for each of the above suggestions:\r\n\r\n1. It would be nice to get rid of `sgn0_be`, but it will make some implementations more complex, and it will definitely make the BLS signatures standard slightly more controversial (since the only suites right now are BLS12-381, and everyone there seems to prefer to use big-endian signedness).\r\n\r\n    So I'm not in favor of removing `sgn0_be`.\r\n\r\n2. I'm fine with (0,1) instead f (1,-1). It will make the specifications simpler (because we can use logical operators rather than CMOV). It will also require a careful consistency pass through the document, but that's not so hard.\r\n\r\n    So I'm slightly in favor of (0, 1), but could go either way.\r\n\r\n3. The towering suggestion is clever, but I think adding all the towering notation to this document will make it strictly harder to understand, and it would require us to totally give up on the idea of matching point compression for extension fields. (I suppose if we decide to get rid of `sgn0_be` then we're already breaking point compression compatibility, in which case the second argument doesn't apply.)\r\n\r\n    Also, it will probably require a whole bunch of different \"towering combinators\" that describe what to do for different degrees at each level of the tower (certainly we'll need degree 2 and 3, possibly others).\r\n\r\n    So: I'm against making the towering change.",
          "createdAt": "2020-03-18T22:55:38Z",
          "updatedAt": "2020-03-18T22:55:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh @chris-wood thoughts?",
          "createdAt": "2020-03-18T22:56:19Z",
          "updatedAt": "2020-03-18T22:56:19Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> it will definitely make the BLS signatures standard slightly more controversial (since the only suites right now are BLS12-381, and everyone there seems to prefer to use big-endian signedness).\r\n\r\nThe choice of sgn0 is particular to hash to curve, isn't it?. BLS signatures still can use big-endian sign for other purposes. As noted, verifying parity is easier to implement.\r\n\r\nMoving from (1,-1) to (0,1) is equivalent to move from `sgn` to `parity`. So, sgn can be defined in terms of parity.\r\n\r\nThe proposed sgn function is too specific to the tower used. However, how it is actually computed the sgn function in the current setting?\r\n\r\nFor example, if we have an element in Fp6, \r\nLet A \\in Fp6,  A = A1 x + A0. (as a quadratic extension over Fp3)\r\nA1 \\in Fp3,  A1 = a2 y^2 + a1 y + a0 ( a cubic extension over Fp)\r\n\r\n",
          "createdAt": "2020-03-19T22:24:10Z",
          "updatedAt": "2020-03-19T22:24:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The choice of sgn0 is particular to hash to curve, isn't it?. BLS signatures still can use big-endian sign for other purposes. As noted, verifying parity is easier to implement.\r\n\r\nYou're totally right, they could keep using the existing method for compression and only change sgn0 for hashing. This gives up on the hope that everyone could use the same sign method for both compression and hashing, but maybe that's OK.\r\n\r\n> Moving from (1,-1) to (0,1) is equivalent to move from `sgn` to `parity`. So, sgn can be defined in terms of parity.\r\n\r\nTrue.\r\n \r\n> The proposed sgn function is too specific to the tower used. However, how it is actually computed the sgn function in the current setting?\r\n> \r\n> For example, if we have an element in Fp6,\r\n> Let A \\in Fp6, A = A1 x + A0. (as a quadratic extension over Fp3)\r\n> A1 \\in Fp3, A1 = a2 y^2 + a1 y + a0 ( a cubic extension over Fp)\r\n\r\nIn the current version, I think we'd expect people to write down the element of Fp6 as a 6-vector over, say, the basis given by the Cartesian product {y^2, y, 1} x {x, 1} and then compute the sign using the existing method. Right?",
          "createdAt": "2020-03-19T23:10:07Z",
          "updatedAt": "2020-03-19T23:10:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> In the current version, I think we'd expect people to write down the element of Fp6 as a 6-vector over, say, the basis given by the Cartesian product {y^2, y, 1} x {x, 1} and then compute the sign using the existing method. Right?\r\n\r\nhence, it is equivalent to what is proposed by going trough the tower, or not?\r\nbecause, at the end, the sgn will be a function coefficients in the ground field.",
          "createdAt": "2020-03-20T00:09:39Z",
          "updatedAt": "2020-03-20T00:09:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, got it! (Sorry for being slow :smile:)\r\n\r\nI think you're right: it's possible, as long as the ground field elements have the \"right\" ordering, that the two methods would agree. This is a really good point :+1:",
          "createdAt": "2020-03-20T02:26:06Z",
          "updatedAt": "2020-03-20T02:26:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My $0.02:\r\n\r\n1. I'm OK removing the BE variant, given that it primarily benefits one use case.\r\n2. I don't think (0,1) would cause much confusion. As a plus, specifying sgn0 in terms of parity does seem to simplify things. \r\n3. I'm less comfortable with this proposal. @kwantam, does it depend on a particular basis representation for field elements? ",
          "createdAt": "2020-03-23T01:53:31Z",
          "updatedAt": "2020-03-23T01:53:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "ping @kwantam @armfazh!",
          "createdAt": "2020-03-25T20:08:20Z",
          "updatedAt": "2020-03-25T20:08:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "it seems we are all agree on  points 1 and 2.\r\nFor the point 3, we might need to specify the order in which the elements and sub-elements are evaluated. So, a sgn function that does not depend on the order of element will be ideal.\r\n",
          "createdAt": "2020-03-25T20:34:55Z",
          "updatedAt": "2020-03-25T20:34:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not obvious to me how to make sgn independent of the evaluation order (or that it's even possible), but it's a very cool idea...\r\n\r\nI'm still not super jazzed about killing sgn0_be, but I'll go along with it if both of you prefer it.\r\n\r\n(0,1) seems fine.\r\n\r\nI should have some time in the next couple days to put together edits for points 1 and 2, and then I guess we can re-evaluate whether we definitely want to remove sgn0_be.",
          "createdAt": "2020-03-25T23:26:37Z",
          "updatedAt": "2020-03-25T23:26:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've opened #230 to address issues (1) and (2).\r\n\r\nIf we really want to deal with the towering issue (issue (3)), we can add an appendix about it. As @armfazh pointed out, it's possible to implement the towering approach in a way that's compatible with the vector approach as currently specified.",
          "createdAt": "2020-03-27T05:31:10Z",
          "updatedAt": "2020-03-27T05:31:35Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "It is an interesting question whether there is a generalisation of the sign to an arbitrary extension field.\r\n\r\nWhat do we expect?\r\n\r\n* `sgn(-x) = -sgn(x)`\r\n* `sgn(T(x)) = sgn(x)` for any automorphism `T`\r\n\r\nSuch a `sgn` does not exist for `GF(p^2)` if `n:=(p-1)/2` is odd. Call an element `x` (strictly) positive if `sgn(x)=1`. `GP(p^2)` has two automorphisms: the trivial one and the Frobenius automorphism which sends `x` to `x^p`. There are exactly `n:=(p-1)/2` positive elements fixed by the Frobenius automorphism. This leaves `2(n^2+n)-n` positive elements that cannot be fixed by the automorphism/. As n is assumed to be odd, this number is odd.  But that cannot be as they have to pair up via the Frobenius automorphism!  Thus such `sgn` does not exist.\r\n\r\nThe existence of such a sign is actually equivalent to the problem of selecting a square root. Indeed, suppose there is a way we can pick a preferred square root irrespective of representation.  Then we can define such a `sgn` function as follows. Define `sgn(0) = 0`. Given a non-zero element `x`, check whether `sqrt(x^2)=x` where `sqrt` is our preferred square root.  Define `sgn(x)=1` if `sqrt(x^2)=x` and `-1` otherwise.  This `sgn` satisfies our assumptions.\r\n\r\nI'm now thinking about the general case for `F(p^n)`.",
          "createdAt": "2020-03-27T18:19:58Z",
          "updatedAt": "2020-03-27T18:21:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The existence of such a sign is actually equivalent to the problem of selecting a square root. Indeed, suppose there is a way we can pick a preferred square root irrespective of representation. Then we can define such a `sgn` function as follows. Define `sgn(0) = 0`. Given a non-zero element `x`, check whether `sqrt(x^2)=x` where `sqrt` is our preferred square root. Define `sgn(x)=1` if `sqrt(x^2)=x` and `-1` otherwise. This `sgn` satisfies our assumptions.\r\n\r\nThis is a good point! and in fact we're using this idea, but backwards, in the draft---we *don't* specify how to compute sqrt, and instead we always restrict `sgn0` of the result...",
          "createdAt": "2020-03-27T21:27:54Z",
          "updatedAt": "2020-03-27T21:27:54Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> * `sgn(T(x)) = sgn(x)` for any automorphism `T`\r\n\r\nAs you say, this appears to be problematic for the general case. So we give up on this, only requiring that `sgn0(x) = -sgn0(-x)` for `x != 0`. (Or, well, the moral equivalent if sgn0 outputs {0,1}.)",
          "createdAt": "2020-03-27T21:30:32Z",
          "updatedAt": "2020-03-27T21:32:45Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "I've thought a bit more about the existence of an automorphism invariant sign.  It cannot exist in `F(p^k)` with `k` even and `p` an odd prime.  Indeed, let `x` be an element of `F(p^k)` such that `x^2` is a quadratic-non residue of `F(p)`. Such a `x` exists because `k` is even and so `x^(p^k-1)/2 = x^{ (p-1)/2 (1 + p + ... + p^{k-1} ) } = ( ( x^{(p-1)/2} )^k = 1`.\r\n\r\nNote `(x^2)^{(p-1)/2} = -1` and so `x^p = -x`\r\n\r\nNote that `F(y)=y^p` is an automorphism and so `sign(x) = sign(x^p) = sign(-x) = -sign(x)`.  Contradiction!\r\n\r\nThis leaves the question open for odd `k\u22653`. ",
          "createdAt": "2020-04-03T17:04:26Z",
          "updatedAt": "2020-04-03T17:15:11Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "MDU6SXNzdWU1ODQ3NzUyODY=",
      "title": "a different way around the k issue",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/227",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm helping to implement hash-to-curve in RELIC, and as I'm doing this I'm realizing that the way we've specified `k` inherently requires a judgement call, which is annoying. This is related to @armfazh's issue with calling `k` the security parameter---that's subjective and will change over time, and even now people will disagree on how to define it.\r\n\r\nSo how could we do this in an objective way? One way would be to say\r\n\r\n    L = ceil(1.5 * ceil(log2(p)) / 8)\r\n\r\nin other words, we replace `k` with `ceil(log2(p)) / 2`. But this is too conservative for curves with large cofactors (like pairing-friendly curves).\r\n\r\nHow about this:\r\n\r\n    p_bits = ceil(log2(p))\r\n    r_bits = ceil(log2(r))  # the bit-length of the prime subgroup order\r\n    L = ceil((p_bits + ceil(r_bits / 2)) / 8)\r\n\r\nThis is essentially how we have been picking `k` already---in particular, I think this will not change any of the hash-to-field parameters in the Suites at all---but it's a totally objective measure, which is nice...\r\n\r\nI can put together a PR if this seems reasonable.",
      "createdAt": "2020-03-20T00:27:39Z",
      "updatedAt": "2020-03-20T23:33:14Z",
      "closedAt": "2020-03-20T23:33:14Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Rather than replace `k` entirely, perhaps we can note that `k` could be computed as you suggest? I think having a target security level will be important for folks looking to adopt one of these in their applications or protocols.",
          "createdAt": "2020-03-20T00:32:58Z",
          "updatedAt": "2020-03-20T00:32:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great point! We can add this in the \"defining new suites\" section, maybe.",
          "createdAt": "2020-03-20T00:34:31Z",
          "updatedAt": "2020-03-20T00:34:31Z"
        }
      ]
    },
    {
      "number": 235,
      "id": "MDU6SXNzdWU1OTA2MDk4NzE=",
      "title": "Too many suites?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/235",
      "state": "CLOSED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Congrats for the amazing work that has been and keeps being made on this document!\r\n\r\nJust a general observation: do so many suites have to be defined?\r\n\r\n`edwards25519_XMD:SHA-256_ELL2_RO_` is identical to `edwards25519_XMD:SHA_512_ELL2_RO_`, except that `H` is SHA-256 instead of SHA-512. Are both really needed?\r\n\r\nFor the same curve, should a new protocol opt for the suite using SVDW or its counterpart using Simplified SWU? It might be useful for the document to make a recommendation.\r\n\r\nIn order to facilitate interoperability, increase code reuse and provide guidance to protocol designers, would it make sense to slightly reduce the list, or make one recommendation per curve?\r\n\r\nPlease apologize if this has been discussed before. ",
      "createdAt": "2020-03-30T21:30:08Z",
      "updatedAt": "2020-05-21T22:04:09Z",
      "closedAt": "2020-05-21T22:04:09Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "iirc, the document does not enforce the implementation of all suites, instead it provides examples of suites and their parameters, and also gives guidance on how to generate a new suite.\r\n\r\nFor the authors: should the document must state which suites to implement? \r\n",
          "createdAt": "2020-04-02T20:18:01Z",
          "updatedAt": "2020-04-02T20:18:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "My take is that none of the suites should be must-implement, because that depends on the invoking protocol and because this document is more about helping higher-level protocols to make the right choices. But the point is well taken that having too many suites could make this difficult!\r\n\r\nRandom thoughts:\r\n\r\n- I really like the idea of recommending a particular suite for each curve. Or maybe, \"for best performance\" vs \"for simplicity of implementation\"?\r\n\r\n- I could see getting rid of the SHA-256 / curve25519 suite since ed25519 has pushed people towards combining SHA-512 with curve25519. But I suspect *someone* will really want to use SHA-256...\r\n\r\n- SvdW vs SSWU is a good question. For a library that just wants to implement *some* map, it makes sense to just support SvdW because it applies to any curve. But for a protocol that is worried about the cost of square roots, it makes sense to pick SSWU. (This goes doubly for curves that require an isogeny map to use SSWU.) So I suspect we'll see a tension between code reuse and optimality (as always, I suppose).",
          "createdAt": "2020-04-03T01:05:48Z",
          "updatedAt": "2020-04-03T01:08:31Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Or maybe, \"for best performance\" vs \"for simplicity of implementation\"?\r\n> For a library [...]  it makes sense to just support SvdW.  But for a protocol, it makes sense to pick SSWU.\r\n\r\nLibraries making a choice, and protocols making a different choice is a thing a standard can help avoid.\r\n\r\nRecommendations cannot be optimal for every case. The proposed suites may not be optimal anyway (ex: 384 vs 255 bit input for a 2^255-19 field size), so we can't prevent protocol designers from going off track if they really want to.\r\n\r\nBut having one recommended suite per curve can greatly limit fragmentation, and protocols that cannot be implemented due to incompatible libraries.",
          "createdAt": "2020-04-03T07:52:51Z",
          "updatedAt": "2020-04-03T07:52:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "As a library author who recently wrote an implementation, please default to [removing options](https://www.imperialviolet.org/2016/05/16/agility.html). The job of a specification is to make decisions so we have common primitives. Every choice point in the spec is a failure to make a decision. Sometimes that's necessary, but it usually isn't. Where it is, definitely include a recommended one, but that's a baseline expectation. The preferred option is to not define the extra ones in the first place.\r\n\r\nThe worst outcome would be for different systems to make different choices and implementations are forced to support many variations to cover them all. We should pick as few as possible so everyone's very limited cryptographic testing and implementation efforts can be concentrated on the things that matter.",
          "createdAt": "2020-04-09T01:12:16Z",
          "updatedAt": "2020-04-09T01:12:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well said, @davidben! We'd all benefit from more input from folks implementing and using these in protocols before nailing down a minimal set of options. I'll take this to the list to see if we can get some of that feedback!",
          "createdAt": "2020-04-14T22:33:09Z",
          "updatedAt": "2020-04-14T22:33:09Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This is my proposal for choosing a single suite per group.\r\n*Replace RO -> NU, if needed.\r\n\r\n| Group | Suites |\r\n|-----|----|\r\n| P-256 | P256_XMD:SHA-256_SSWU_RO_ |   \r\n| P-384 | P384_XMD:SHA-512_SSWU_RO_ |   \r\n| P-521 | P521_XMD:SHA-512_SSWU_RO_ |   \r\n| curve25519 | curve25519_XMD:SHA-512_ELL2_RO_ |   \r\n| edwards25519 | edwards25519_XMD:SHA-512_ELL2_RO_ |   \r\n| curve448 | curve448_XMD:SHA-512_ELL2_RO_ |   \r\n| edwards448 | edwards448_XMD:SHA-512_ELL2_RO_ |   \r\n| secp256k1 | secp256k1_XMD:SHA-256_SSWU_RO_  |\r\n| BLS12381-G1 | BLS12381G1_XMD:SHA-256_SSWU_RO_ |\r\n| BLS12381-G2 | BLS12381G2_XMD:SHA-256_SSWU_RO_ |\r\n\r\n",
          "createdAt": "2020-05-19T21:48:35Z",
          "updatedAt": "2020-05-20T18:08:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems like a reasonable set of choices to me. @kwantam, what do you think?",
          "createdAt": "2020-05-19T22:02:39Z",
          "updatedAt": "2020-05-19T22:02:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Generally these look good to me. Some people might wonder about SHA-512 with curve25519, so we may want to add a comment that this is because of Ed25519.\r\n\r\nOne small concern: VRF (which should be merging our PR soon, I hope!) is using NU rather than RO. If we remove the NU suites, they will have to add the suite description in their document, which is slightly unfortunate...\r\n\r\nThoughts on how to handle? Should we warn them about this preemptively and try to get them to add the suite definitions now? Should we keep the -NU suites defined for these cases? Something else?",
          "createdAt": "2020-05-19T23:51:32Z",
          "updatedAt": "2020-05-19T23:51:59Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, one other question: why SVDW for secp256k1? Is it so that we can remove the isogeny map in the appendix?\r\n\r\nMy guess is that most people who use secp256k1 are very speed sensitive (why else would one use \"riskier\" Koblitz curves?), so it might make sense to stick with SSWU here, too.",
          "createdAt": "2020-05-19T23:53:13Z",
          "updatedAt": "2020-05-19T23:53:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Does the VRF document *need* the NU variant? If not, I'd suggest they use the RO variant instead. ",
          "createdAt": "2020-05-19T23:53:55Z",
          "updatedAt": "2020-05-19T23:53:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think they're concerned about computational cost, and they don't need the RO for the security proof.\r\n\r\n@reyzin may be able to chime in here (or I can ping him offline)",
          "createdAt": "2020-05-19T23:54:19Z",
          "updatedAt": "2020-05-19T23:54:56Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps the intent of those suite parameters should be clarified?\r\nI don't mind having several suites as long as protocol designers are guided towards one suitable for their use case: i.e. if cryptography will be a bottleneck, choose a SSWU suite.\r\n\r\n> As a library author who recently wrote an implementation, please default to [removing options](https://www.imperialviolet.org/2016/05/16/agility.html). The job of a specification is to make decisions so we have common primitives. Every choice point in the spec is a failure to make a decision. Sometimes that's necessary, but it usually isn't. Where it is, definitely include a recommended one, but that's a baseline expectation. The preferred option is to not define the extra ones in the first place.\r\n\r\nThis is not a library though, it's a core building block of protocols. The risk is that if you don't provide recommendations that address the protocol needs, the designers might create their own assemblage.\r\n\r\n> The worst outcome would be for different systems to make different choices and implementations are forced to support many variations to cover them all. We should pick as few as possible so everyone's very limited cryptographic testing and implementation efforts can be concentrated on the things that matter.\r\n\r\nI agree with the last part but for me the worst would be that if none of the building blocks fit the needs (say SSWU was removed and cryptography was already a bottleneck) and designers have nothing vetted that fits their need.\r\n\r\nIf we really want to make sure we don't forget an use-case we need to start from the potential users or domains and not from our list of suites, i.e.:\r\n\r\n- I design a protocol for embedded device to do X, I cannot compromise on signature size, speed delay are not an issue\r\n  - User question: is there a suite that provides what I need?\r\n- I design a protocol for smart device with user interactivity, I cannot compromise on both signature size and speed, ...\r\n- I design a P2P protocol, I expect a lot of signing, ...\r\n- I design a remote access protocol, ...\r\n- I design a content delivery system (Cable TV ...) with ephemeral keys ...\r\n",
          "createdAt": "2020-05-20T12:34:51Z",
          "updatedAt": "2020-05-20T12:34:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "FWIW, if there are clear needs (protocols where the perf difference between NU and RO is very significant and RO's stronger properties are provably unnecessary), I think it's reasonable to have both NU and RO variations. The cost of supporting both NU and RO, from the code complexity side, is fairly low compared to, say, implementing both SSWU and SVDW for the same curve.\r\n\r\nI think the argument against NU would be that NU has more sharp edges than RO and having common primitives be consistently robust is worth some performance hit.\r\n\r\n> This is not a library though, it's a core building block of protocols. The risk is that if you don't provide recommendations that address the protocol needs, the designers might create their own assemblage.\r\n\r\nUltimately those protocols will call into functions implemented by the cryptographic libraries they use. Diversity in building blocks used by protocols is precisely what inflates a library's maintenance burden. If some variation is indeed necessary, it is necessary, but standards shouldn't include options for the sake of it. Variations must pull their weight.",
          "createdAt": "2020-05-20T17:46:40Z",
          "updatedAt": "2020-05-20T17:46:40Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ah, one other question: why SVDW for secp256k1? Is it so that we can remove the isogeny map in the appendix?\r\n\r\nYes, I think SSWU fits better for this curve if performance is a must. So I just update the list.\r\n",
          "createdAt": "2020-05-20T18:08:24Z",
          "updatedAt": "2020-05-20T18:08:24Z"
        },
        {
          "author": "reyzin",
          "authorAssociation": "NONE",
          "body": "\r\n> Does the VRF document _need_ the NU variant? If not, I'd suggest they use the RO variant instead.\r\n\r\n> I think they're concerned about computational cost, and they don't need the RO for the security proof.\r\n> \r\n> @reyzin may be able to chime in here (or I can ping him offline)\r\n\r\nRight, exactly. If I am not mistaken, the RO variants are twice as expensive as corresponding NU variants. In most applications I can think of (VRF included), NU is sufficient.\r\n\r\n",
          "createdAt": "2020-05-21T03:09:29Z",
          "updatedAt": "2020-05-21T03:09:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@reyzin the question here is not necessarily whether it's sufficient, but whether it's necessary. Is that the case for applications you're aware of? \r\n\r\nIf they're necessary, would you object to the VRF draft registering the NU ciphersuites? That would move them to the application where they're needed, without burdening the main hash-to-curve draft. (@kwantam, what do you think?)",
          "createdAt": "2020-05-21T03:23:24Z",
          "updatedAt": "2020-05-21T03:23:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "My general feeling is that if we have users for particular ciphersuites now, we define those ciphersuites in the document. As @davidben says, the difference code-wise between the two is very, very small.\r\n\r\n(And we can add further encouragement to pick RO if we're concerned that people will get this wrong.)",
          "createdAt": "2020-05-21T03:28:19Z",
          "updatedAt": "2020-05-21T03:28:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That\u2019s true, but why burden the document for one use case while risking future applications making the wrong choice? I\u2019m not sure any amount of text will be sufficient in deterring mistakes. \r\n\r\nIt seems better to have the default focus of this document be on RO encodings. Any application that can afford to relax this property can then define NU variants as needed. In this case, the VRF document would define a NU variant. This reduces risk of using the wrong variant when looking at only this document, satisfies the VRF use case, and exercises the effort we put into the registry. That seems like a win all around. What are the downsides?",
          "createdAt": "2020-05-21T03:38:59Z",
          "updatedAt": "2020-05-21T03:38:59Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "First, I fully admit that downsides depend on perspective! :smile:\r\n\r\nBut in my mind the document exists to serve upper-level protocols, and from that point of view it's sad to require the VRF folks to specify their own suites (and probably also their own hash-to-curve test vectors) when this is a known use-case and we have the machinery and text already in place to do it for them.\r\n\r\nMoreover, as @reyzin's comment indicates, I expect that the document *will* have plenty of \"client\" protocols in the future that prefer to use nonuniform hashing. In other words, I don't think it's likely to be just one use-case in the long run. If that's true, and if we leave out NU, those documents will likewise need to define their own suites, which may well end up causing unnecessary fragmentation.\r\n\r\nI'd be totally happy to have, in *every* suite subsection, a note saying something like\r\n\r\n> foo_RO_ is the RECOMMENDED suite for curve X. foo_NU_ MUST NOT be used in protocols whose security relies on a random oracle. Protocols using foo_NU_ SHOULD carefully analyze the security implications of using a nonuniform encoding.",
          "createdAt": "2020-05-21T04:36:36Z",
          "updatedAt": "2020-05-21T04:38:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we're both trying to predict the future with slightly different objectives. I'm not convinced scary advisory text is sufficient, though I'm not willing to lie down in the road over it either!\r\n\r\nSo, in the interest of moving forward, I'll add back one NU suite (in #254) for each curve, with the scary warning text, and then we can close out this issue. Sound good?\r\n\r\nEdit: #254 is now updated!",
          "createdAt": "2020-05-21T12:40:29Z",
          "updatedAt": "2020-05-21T12:52:58Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me.\r\n\r\nFor implementers, supporting NU and/or RO is pretty much the the same thing, and the scary warning is good enough to encourage protocol designers to use RO as a general recommendation.",
          "createdAt": "2020-05-21T13:16:19Z",
          "updatedAt": "2020-05-21T13:16:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "SGTM",
          "createdAt": "2020-05-21T13:50:55Z",
          "updatedAt": "2020-05-21T13:50:55Z"
        },
        {
          "author": "reyzin",
          "authorAssociation": "NONE",
          "body": "Curious: can anyone do a tally of uses of hash-to-curve that require RO vs the ones for which NU suffices? @chris-wood @kwantam -- I don't know who your potential users are besides VRF.",
          "createdAt": "2020-05-21T16:04:54Z",
          "updatedAt": "2020-05-21T16:04:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@reyzin great suggestion! I'll take a crack at that and share the results here.\r\n\r\nEdit: An initial list [is here](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/wiki/hash-to-curve-applications).",
          "createdAt": "2020-05-21T16:19:32Z",
          "updatedAt": "2020-05-21T16:39:35Z"
        }
      ]
    },
    {
      "number": 236,
      "id": "MDU6SXNzdWU1OTYxNDI0Mjg=",
      "title": "expand_message_xmd injectivity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/236",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As pointed out by David Benjamin, Step 6 of expand_message_xmd is not injective! Here are two inputs that will produce the same output (b_0 = H(Z_pad + [0, 16, 0, 4, 0, 16, 0, 0])): \r\n\r\nexpand_message_xmd(msg=[], DST=[0, 16, 0, 0], len_in_bytes=16)\r\nexpand_message_xmd(msg=[0, 16, 0, 4], DST=[], len_in_bytes=16) \r\n\r\nWe should probably address this, though it's not clear what is the best way.",
      "createdAt": "2020-04-07T20:47:49Z",
      "updatedAt": "2020-04-16T17:33:17Z",
      "closedAt": "2020-04-16T17:33:17Z",
      "comments": [
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`H(Z_pad || l_i_b_str || I2OSP(0, 1) || DST_prime || msg)`?",
          "createdAt": "2020-04-08T08:02:24Z",
          "updatedAt": "2020-04-08T08:02:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "(Out of curiosity, any reason not to use HKDF? Different requirements?)\r\n\r\nDoes `DST_prime` need to be in a matching location between `b_0` and `b_i` computations? Otherwise the `I2OSP(i, 1)` iteration number doesn't line up quite right. I assumed that was why the tail end of all the hash invocations matched.\r\n\r\nTo that end, if we're lining everything up at the tail end, I think it'd work to just redefine `DST_prime` to `DST || I2OSP(len(DST), 1)`.\r\n\r\nNB: I'm only guessing as to the requirements and am probably making wrong assumptions. I've only just started looking at this draft and have no context as to why any of it looks the way that it does.",
          "createdAt": "2020-04-08T17:43:54Z",
          "updatedAt": "2020-04-08T17:43:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "`expand_message_xof` seems to have the same issue in the computation of `msg_prime`. I think the same fix to `DST_prime` addresses it.\r\n\r\n~~It probably doesn't matter here, but this construction also has inconsistent block alignment of `msg` in `expand_message_xmd`. It sometimes follows a block-size prefix and sometimes a hash-sized prefix. (But it is injective with the `DST_prime` fix to align it all at the end rather than the start.) For comparison, HMAC (and thus HKDF-Extract) and the AD constructions in [AES-GCM](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf), [AES-GCM-SIV](https://tools.ietf.org/html/rfc8452#section-4), and [ChaCha20-Poly1305](https://tools.ietf.org/html/rfc7539#section-2.8) are all sensitive to the block size, with the AEADs even padding AD and ciphertext up so they both consistently start at block boundaries. (Then they add both lengths to be injective.) This is handy if, e.g., you've got `iovec`s floating around.~~\r\n\r\n~~But this probably doesn't matter here. Fiddling with unaligned or partial blocks is negligible compared to the cost of field operations and presumably you aren't hashing bulk data.~~\r\n\r\n(Ignore this; I missed that `msg` was not in the `b_i` calculations, only `b_0`.)",
          "createdAt": "2020-04-08T18:07:48Z",
          "updatedAt": "2020-04-09T00:48:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> (Out of curiosity, any reason not to use HKDF? Different requirements?)\r\n\r\nThis is a great question. We discussed at some length in #202.\r\n\r\n> Does `DST_prime` need to be in a matching location between `b_0` and `b_i` computations?\r\n\r\nNo, the alignment doesn't really matter per the CDMP05 analysis.\r\n\r\n> To that end, if we're lining everything up at the tail end, I think it'd work to just redefine `DST_prime` to `DST || I2OSP(len(DST), 1)`.\r\n\r\nThis is a great suggestion! Thank you.",
          "createdAt": "2020-04-09T00:27:34Z",
          "updatedAt": "2020-04-09T00:32:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> `H(Z_pad || l_i_b_str || I2OSP(0, 1) || DST_prime || msg)`?\r\n\r\nUnfortunately, this doesn't work. We're enforcing domain separation with a trailing DST, and this would break that.",
          "createdAt": "2020-04-09T00:32:43Z",
          "updatedAt": "2020-04-09T00:32:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "(I clearly didn't phrase \"Does `DST_prime` need to be in a matching location between `b_0` and `b_i` computations?\" very well. That was confirming whether DST needed to be consistently trailing, because the https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/236#issuecomment-610813374 suggestion broke this properly. Sounds like the answer is yes.)",
          "createdAt": "2020-04-09T00:40:35Z",
          "updatedAt": "2020-04-09T00:40:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It probably doesn't matter here, but this construction also has inconsistent block alignment of `msg` in `expand_message_xmd`\r\n\r\nWait, I don't get it. `msg` is only an input for the b_0 computation, and it's always exactly one block offset from the start, no? Do you mean block offset from the end? Or are you talking about the offset of b_0 in the b_i's? Sorry to be slow...\r\n\r\nIt occurs to me: we would have avoided the injectivity issue entirely if we'd encoded the length of the message in the hash. I suppose we might still consider doing this if we change the input for b_0 anyway (though we'd then have to decide what the longest `msg` we can support is... I worry that the embedded folks might complain if we add another 8 bytes to the input...)",
          "createdAt": "2020-04-09T00:44:53Z",
          "updatedAt": "2020-04-09T00:44:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "> Wait, I don't get it. msg is only an input for the b_0 computation, and it's always exactly one block offset from the start, no? Do you mean block offset from the end? Or are you talking about the offset of b_0 in the b_i's? Sorry to be slow...\r\n\r\nEr, yes. Ignore me, I can't read and missed that b_i's don't have msg in them.",
          "createdAt": "2020-04-09T00:47:08Z",
          "updatedAt": "2020-04-09T00:47:08Z"
        }
      ]
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWU1OTY3Njg1ODM=",
      "title": "P-521 suites have inconsistent L and k values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/237",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [
        "armfazh"
      ],
      "labels": [],
      "body": "The P-521 suites define `L` to be 96 and `k` to be 256. This is reflected in the reference implementation, which specifies both values.\r\nhttps://cfrg.github.io/draft-irtf-cfrg-hash-to-curve/draft-irtf-cfrg-hash-to-curve.html#name-suites-for-nist-p-521\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/poc/suite_p521.sage#L21\r\n\r\nHowever, `L` is a derived parameter in `hash_to_field`. It's computed as `L = ceil((ceil(log2(p)) + k) / 8)`.\r\nhttps://cfrg.github.io/draft-irtf-cfrg-hash-to-curve/draft-irtf-cfrg-hash-to-curve.html#name-hash_to_field-implementatio\r\n\r\nFor P-521 and `k` = 256, this gives `L = ceil((521 + 256) / 8) = ceil(777 / 8) = 98`, not 96. One would get 96 if 521 was misread as 512. Between this and wanting to specify enough bits beyond the prime[*], it seems we want L = 98 rather than L = 96? The reference implementation and test vectors appear to be computed based on `L` rather than `k`, so those too probably need to be updated.\r\n\r\n[*] Although, in the case of P-521, the prime is 1 below a power of two anyway...",
      "createdAt": "2020-04-08T18:20:53Z",
      "updatedAt": "2020-04-08T22:51:14Z",
      "closedAt": "2020-04-08T22:51:14Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for pointing out this inconsistency, I will prepare the changes to fix this. ",
          "createdAt": "2020-04-08T18:25:48Z",
          "updatedAt": "2020-04-08T18:26:14Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWU2MDI1NjA1MjA=",
      "title": "potential optimization for Edwards to Montgomery map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/243",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Michael Scott wrote to observe that the generic Edwards to Montgomery map can be simplified in some cases.\r\n\r\nConsider the Edwards curve\r\n\r\n    a * v^2 + w^2 = 1 + d * v^2 * w^2\r\n\r\nAssuming that there is no corresponding standardized Montgomery curve, the document currently suggests mapping to the following curve\r\n\r\n    K * t^2 = s^3 + J * s^2 + s\r\n    J = 2 * (a + d) / (a - d)\r\n    K = 4 / (a - d)\r\n\r\nand then mapping back to the Edwards curve via\r\n\r\n    v = s / t\r\n    w = (s - 1) / (s + 1)\r\n\r\nThe j-invariant of a Montgomery curve depends only on the J coefficient, meaning that for all Montgomery curves given above, the curve\r\n\r\n    t^2 = s^3 + J * s^2 + s\r\n\r\nis isomorphic to either the curve or its quadratic twist. Most interestingly, to us, when K is a quadratic residue, then the above two Montgomery curves are isomorphic via\r\n\r\n    (s, t) \u21a6 (s, t \u221aK)\r\n\r\nand therefore we can map back from the curve with K = 1 to the Edwards curve via\r\n\r\n    v = (s \u221aK) / t\r\n    w = (s - 1) / (s + 1)\r\n\r\nNote that this is exactly the map that RFC7748 specifies from edwards25519 to curve25519.\r\n\r\n(See https://eprint.iacr.org/2017/212.pdf for more info on the above.)\r\n\r\n---\r\n\r\nAlong the same lines, when K is non-square we could map from\r\n\r\n    Z * t^2 = s^3 + J * s^2 + s\r\n\r\nto the Edwards curve, where Z is the distinguished non-square in F used to map to Montgomery. The Montgomery to Edwards map would then be\r\n\r\n    v = (s \u221a(K/Z)) / t\r\n    w = (s - 1) / (s + 1)\r\n\r\nThe advantage is that this lets us use a very small value (Z) in place of K (which is likely much larger) when evaluating Elligator.\r\n\r\n---\r\n\r\nOK, so what does this mean to us? It means that we can, in principle, specify a somewhat better optimized map from Edwards to Montgomery. In particular, keeping the definitions above,\r\n\r\n    if is_square(K):\r\n        // map from t^2 = s^3 + J * s^2 + s\r\n    else:\r\n        // map from Z * t^2 = s^3 + J * s^2 + s\r\n\r\nSo: question: do we think this is would be a reasonable optimization to add?",
      "createdAt": "2020-04-18T21:55:37Z",
      "updatedAt": "2020-05-19T23:47:37Z",
      "closedAt": "2020-05-19T23:47:37Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "My two cents: the difference in cost among these options is pretty well spelled out in the latest optimized pseudocode. That difference is not huge---a few multiplications. So the upside is in my mind somewhat limited.\r\n\r\nOn the other hand, the downside is that we're adding additional complexity to the document. It's not a ton of complexity, but we have a lot of opportunities to add small extra bits of complexity and we've done a good job recently of avoiding them. I'm generally in favor of continuing that trend.\r\n\r\n(edit to add:)\r\n\r\nThe other upside of this change is that it eliminates the special case for edwards25519. Unfortunately, we still need a special case for edwards448. If it eliminated both I'd probably be more excited to make this change...",
          "createdAt": "2020-04-18T22:21:07Z",
          "updatedAt": "2020-04-18T22:33:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(cc @armfazh @chris-wood)",
          "createdAt": "2020-04-18T22:24:31Z",
          "updatedAt": "2020-04-18T22:24:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not inclined to take this change. Folks such as MIRACL and RELIC can implement it if they like, though pushing that complexity into the document feels like it'd do more harm than good. (We probably need to go through and ruthlessly trim unnecessary optimizations in the future before shipping, anyway.)",
          "createdAt": "2020-04-20T13:50:53Z",
          "updatedAt": "2020-04-20T13:50:53Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with you. Nice trick indeed. ",
          "createdAt": "2020-04-20T16:10:27Z",
          "updatedAt": "2020-04-20T16:10:27Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's an alternative: since the rational map is part of the suite definition, we don't have to make the generic mapping a MUST. Instead, we can make it a SHOULD, and add an appendix that spells out the optimized alternative. I'll write this up and we can decide whether we want to include it or not.",
          "createdAt": "2020-04-20T18:25:51Z",
          "updatedAt": "2020-04-20T18:25:51Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thoughts on #244 @armfazh @chris-wood ?",
          "createdAt": "2020-04-20T21:35:39Z",
          "updatedAt": "2020-04-20T21:35:39Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "PR:244 was merged, so this can be closed.",
          "createdAt": "2020-05-19T21:34:59Z",
          "updatedAt": "2020-05-19T21:34:59Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "agree with @armfazh: seems like whichever way we decide on #246, we can close this",
          "createdAt": "2020-05-19T23:47:31Z",
          "updatedAt": "2020-05-19T23:47:31Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWU2MDgxMzExMDY=",
      "title": "Request for release of v7",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/245",
      "state": "CLOSED",
      "author": "CarlBeek",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Many important changes have been made to this H2C curve spec since v6. As [the authors are well aware](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/230#issuecomment-604822461), Ethereum's eth2 is planning on launching soon, and we'd like to implement H2C v7.\r\n\r\nWe have reached the point where this spec is one of, if not the primary bottleneck to launch. What is the timeline for H2C v7 release and are there any expected changes further than #230, & #241?\r\n\r\nThanks in advance!",
      "createdAt": "2020-04-28T08:37:49Z",
      "updatedAt": "2020-04-28T20:34:40Z",
      "closedAt": "2020-04-28T15:48:25Z",
      "comments": [
        {
          "author": "nikkolasg",
          "authorAssociation": "NONE",
          "body": "Just want to highlight here that there are other projects that would like to align on the RFC but find it difficult due to the number of breaking changes in H2C over versions - so any stability & timelines on this would be very much appreciated !",
          "createdAt": "2020-04-28T13:21:48Z",
          "updatedAt": "2020-04-28T13:21:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "-07 came out yesterday! Closing.",
          "createdAt": "2020-04-28T15:48:25Z",
          "updatedAt": "2020-04-28T15:48:25Z"
        },
        {
          "author": "CarlBeek",
          "authorAssociation": "NONE",
          "body": "Apologies, @chris-wood, I missed that. Thanks for cutting the release!",
          "createdAt": "2020-04-28T16:07:16Z",
          "updatedAt": "2020-04-28T16:07:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No worries, @CarlBeek! I appreciate nudges towards forward progress. ",
          "createdAt": "2020-04-28T20:34:39Z",
          "updatedAt": "2020-04-28T20:34:39Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "MDU6SXNzdWU2MjA2MDkzNzM=",
      "title": "Remove SSWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/252",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Several folks noted that we might just remove SSWU on the list, in response to #235. I'm inclined to agree, given that SSWU is less friendly to implementations. If folks agree, I can prepare a PR to take it out.\r\n\r\n@kwantam, @armfazh: a penny for your thoughts? :-)",
      "createdAt": "2020-05-19T01:36:52Z",
      "updatedAt": "2020-05-20T23:11:52Z",
      "closedAt": "2020-05-20T23:11:52Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is a good idea, for a few reasons:\r\n\r\n1. If we remove SSWU, there is no \"fast\" option for any curve other than Montgomery/Edwards curves. Here, fast means \"hashing costs 1 square root.\" A constant-time Shallue and van de Woestijne costs roughly 3x as much, so this is a quite big performance hit.\r\n\r\n2. SvdW tempts the implementor to \"optimize\" by making the map non--constant-time, since this is potentially a 3x savings in hashing cost. For example, one can make SvdW go faster by using a fast quadratic residuosity test, but this test is inherently not constant time, and constant-time variants are complex.\r\n\r\n3. The only other option to make SvdW faster is randomized masking. This is hard to get right in practice and is subject to randomness failures, so it is (in my view) *not* something we should be describing or, by removing SSWU, implicitly endorsing as a way to hash quickly to non-Monty/Edwards curves.\r\n\r\n5. The BLS signatures standard is using SSWU to BLS12-381, and lots of folks have started implementing this already.\r\n\r\n6. The VRF standard looks like it's going to be reffing SSWU-to-NIST P-256. No one has implemented yet to my knowledge.\r\n\r\nI've been glad to remove more and more maps from the document, but in all cases these maps offered very little beyond the ones that we've kept. Removing SSWU takes away the best-performing option for most curves. My guess is that if we do this, people will go their own way and use SSWU anyway, which is kind of a failure outcome for the document.",
          "createdAt": "2020-05-19T02:57:00Z",
          "updatedAt": "2020-05-19T02:57:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not in favor to remove SSWU. \r\n\r\nIn fact, we would **promote its use**, since it's the fastest option for many curves as it requires only 1 exponentiation.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-05-19T21:27:53Z",
          "updatedAt": "2020-05-19T21:27:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My apologies -- I think caused confusion here! I meant to convey that we remove the *suites*, not the map itself. For several curves, we define suites for both SSWU and SWVD. I don't see a strong reason for doing this, other than library flexibility. But to David's credit in the other issue, that might just complicate things later on.",
          "createdAt": "2020-05-19T21:31:21Z",
          "updatedAt": "2020-05-19T21:31:21Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As someone who implemented SSWU for BLS12-381, I found the spec quite useful and easy to follow.\r\n\r\nI think it's OK to have 2 options, 1 for speed and 1 for generality.",
          "createdAt": "2020-05-20T12:14:55Z",
          "updatedAt": "2020-05-20T12:14:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, as we're discussing removing suites in #235.",
          "createdAt": "2020-05-20T23:11:50Z",
          "updatedAt": "2020-05-20T23:11:50Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWU2MjE0NTUyOTA=",
      "title": "xmd test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/253",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "nice-to-have"
      ],
      "body": "Should we include test vectors for XMD? This could help folks to implement...",
      "createdAt": "2020-05-20T04:44:34Z",
      "updatedAt": "2020-05-22T23:27:59Z",
      "closedAt": "2020-05-22T23:27:59Z",
      "comments": [
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "XMD is pretty straightforward. I'm not convinced that it is necessary.",
          "createdAt": "2020-05-20T05:10:41Z",
          "updatedAt": "2020-05-20T05:10:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's mark this as a \"nice to have\" issue?",
          "createdAt": "2020-05-20T23:10:26Z",
          "updatedAt": "2020-05-20T23:10:26Z"
        }
      ]
    },
    {
      "number": 256,
      "id": "MDU6SXNzdWU2MjI5NTE4Mzg=",
      "title": "expand domain separation discussion in Security Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/256",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After discussing with @reyzin today, it seems like we can go a little further with the domain separation discussion in Security Considerations.\r\n\r\nSpecifically: right now we append DST inside expand-message-xmd and expand-message-xof. For xof this isn't a problem because we expect it to be used with SHAKE-128 or a similar hash that has an indifferentiability proof. expand-message-xmd, on the other hand, has some subtleties that we should discuss further in how it interacts with domain separation in the invoking protocol.\r\n\r\nSpecifically, it's possible to use -xmd with either prefix or suffix domain separation, which is handy for protocols that prefer to use prefix domain separation (and there are reasons to do this; see below). Since -xmd prepends an all-zeros block to the front of the input to H when computing `b_0`, this is easy: just prepend some tag of length at most one block that's guaranteed to have a nonzero byte.\r\n\r\n(For the `b_i` computations (`i >= 1`), domain separation is automatic with overwhelming probability: the first output-block-length bytes is a random value ~that is never revealed to the adversary~ (EDIT: might not be this easy...), so it's infeasible for the adversary to generate a collision and thereby differentiate -xmd from a hash function.)\r\n\r\nSo: I think we ought to add a note in Security Considerations that calls attention to this fact, because it may help future implementors to avoid footguns when using SHA-2 and other M-D functions.\r\n\r\n---\r\n\r\nThe reason invoking protocols might wish to use prefix rather than suffix domain separation with Merkle-Damgaard hash functions is that some ways of turning M-D into an indifferentiable function are fragile when composed with other protocols, and in some cases this fragility can be avoided by prefixing rather than suffixing the DST. (To be clear: the way -xmd is constructed it is *not* fragile in the way I am about to describe.)\r\n\r\nConsider two different protocols, Px and Py, each of which uses a M-D hash as an indifferentiable function by fixing the length of the M-D input and appending a domain separation tag. Let's call these fixed lengths Lx and Ly, respectively. Notice that this rules out any length extension attack against either Px or Py, because there is precisely one length allowed for each protocol.\r\n\r\nNow consider the case that Ly > Lx such that we have\r\n\r\n- Inside Px: `H(input1 || DST1)`\r\n- Inside Py: `H(input2 || DST2)`, where `input2 = input1 || DST1 || padding || ...` (imagine `padding` is the standard padding that, say, SHA-2 would add to the end of Px's HASH invocation).\r\n\r\nOops! Now Py's use of H becomes differentiable: first we observe the output from Px's H invocation, then we do a length extension attack to predict the output of Py's invocation! This is subtle and unfortunate: we couldn't differentiate Py's random oracle on its own (because of the fixed-length input), but composed with Px we can differentiate Py's random oracle.\r\n\r\nOK, so why bother with this example? Because, as @reyzin pointed out to me, if DST had been in the front, there'd be no such attack.\r\n\r\n---\r\n\r\nTo be clear: I am not suggesting any change to -xmd! But I think we should point out to readers that it's flexible in the way that other protocols can domain separate from it.",
      "createdAt": "2020-05-22T05:03:09Z",
      "updatedAt": "2020-05-28T21:15:03Z",
      "closedAt": "2020-05-28T21:15:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a reasonable clarification. (Thanks, @reyzin!) Are you suggesting we add the example? I think noting prefix or suffix domain separation properties of -xmd is probably sufficient.",
          "createdAt": "2020-05-22T23:35:13Z",
          "updatedAt": "2020-05-22T23:35:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Not totally clear we need to add an example. So probably, as you say, just want to discuss considerations for domain separating from xmd in front and in back.",
          "createdAt": "2020-05-22T23:46:39Z",
          "updatedAt": "2020-05-22T23:46:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you mind if I took a crack at this?",
          "createdAt": "2020-05-23T00:03:29Z",
          "updatedAt": "2020-05-23T00:03:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm still thinking through one case trying to convince myself that prefix domain separation really works. (Pointed out by, who else? @reyzin :+1:).\r\n\r\nThe issue is that the adversary obviously *can* compute `b_0` on its own and try to somehow force a collision. For example, imagine that we have a protocol that calls hash_to_field on some (msg,dst) pair that the adversary knows, and in some other place in the protocol allows the adversary to generate a hash input, like `H(DST2 || msg2)`. If DST2 is short, the adversary can grind (msg,dst) pairs until he gets a b_0 value that collides with DST2 and then set msg2 to `b_0_remaining || I2OSP(1, 1) || DST_prime`. This will cause the H invocation to output exactly the same value as `b_1` inside of expand_message_xmd, which is bad if H is supposed to be an independent random oracle. (Here, let `b_0_remaining` be the string such that `b_0 = DST2 || b_0_remaining`.)\r\n\r\nThe way to handle this with the current xmd design is to make sure DST2 is reasonably long (preferably an entire block). Then the attacker has to break the hash function to cause b_0 to collide with DST2.\r\n\r\nAn alternative would be to slightly tweak the xmd design, in particular, doing something like\r\n\r\n    F_pad = 0xFF..FF   // one block long; any fixed value other than 0 works\r\n    b_1 = H(F_pad || b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(F_pad || strxor(b_0, b_(i-1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThen every invocation of H has a fixed (non-adversarially-controlled) block at the front, which trivially means that we get domain separation from any prefix DST not equal to the padding block. As now, implementors can optimize by precomputing h(IV, F_pad) and then using this value as the IV; so it's possible to avoid the cost of the extra padding.\r\n\r\nI don't love the idea of changing XMD again, though...",
          "createdAt": "2020-05-23T00:19:36Z",
          "updatedAt": "2020-05-23T00:21:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I thought about it some more. I don't think we should change xmd, because there's basically no way to make this completely foolproof with M-D hashes.\r\n\r\nI think the right thing to do is to split it into two cases:\r\n\r\n- suffix domain separation: this is fine. For M-D hashes, the calling protocol still has to be sure that length extension attacks are not a problem in their use of the hash. If in doubt, an easy and safe way to do this is simply to use `expand_message_xmd` with a different DST and the desired output length (presumably something like 1 hash output length).\r\n\r\n- prefix domain separation: this is fine as long as the length of the prefix domain separation tag used in the invoking protocol is at least k bits, for k the security parameter (e.g., 16 bytes for 128-bit security).",
          "createdAt": "2020-05-23T00:36:34Z",
          "updatedAt": "2020-05-23T00:37:08Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWU2MjM1MDQyOTc=",
      "title": "Why include nonuniform encodings at all?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/260",
      "state": "CLOSED",
      "author": "paulmillr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's unclear what's the benefit of NU encoding. The spec says \"you should use random oracle encoding when possible\". Why use NU at all? Perhaps someone could answer the q here, or clarify this in the spec...",
      "createdAt": "2020-05-22T22:25:37Z",
      "updatedAt": "2020-05-22T23:18:57Z",
      "closedAt": "2020-05-22T23:18:57Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "They are less computationally expensive, since they only require one evaluation of the mapping rather than two for -RO.",
          "createdAt": "2020-05-22T22:52:06Z",
          "updatedAt": "2020-05-22T22:52:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed -- and we have a number of protocols identified that need them. (This came up in the context of #235.) See this page for more details: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/wiki/Known-applications.",
          "createdAt": "2020-05-22T23:18:57Z",
          "updatedAt": "2020-05-22T23:18:57Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "MDU6SXNzdWU2MjM1MTk3NDM=",
      "title": "two small pieces of feedback",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/261",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Both from Leo as we were discussing VRF:\r\n\r\n1. `pseudo_random_bytes` is a bad name in `hash_to_field`, because the cryptographic notion of pseudorandomness involves a secret. Is there a better name we can use?\r\n\r\n2. Is it possible to remove line breaks from the test vectors in the document, to make copy-pasting easier?\r\n\r\nI *think* the answer to (2) is no because we're limited to some fixed line length. @chris-wood do you know for sure?\r\n\r\nAs to (1), I don't have any ideas but I'll think about it.",
      "createdAt": "2020-05-22T23:30:11Z",
      "updatedAt": "2020-05-23T18:30:38Z",
      "closedAt": "2020-05-23T18:30:38Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, our hands are somewhat tied by the RFC editor for (2). :-\\\r\n\r\nAs for (1), what do you mean by it \"involves a secret\"? ",
          "createdAt": "2020-05-22T23:31:35Z",
          "updatedAt": "2020-05-22T23:31:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Almost-formally, we say that a pseudorandom generator is a deterministic function G and some secret s such that G(s) is statistically indistinguishable from random to anyone who doesn't know s.\r\n\r\nHere, there's no secret---all inputs are public---so \"pseudorandom\" doesn't quite apply, so we're sort of watering down / confusing terminology by using it in this way.",
          "createdAt": "2020-05-22T23:44:57Z",
          "updatedAt": "2020-05-22T23:45:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I thought you meant that its output is secret, or something :)  I'm not sure folks will find this particularly confusing, though hedging against any risk is probably best. What about `uniform_bytes`?",
          "createdAt": "2020-05-22T23:48:45Z",
          "updatedAt": "2020-05-23T14:26:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "`uniform_bytes` sounds great!",
          "createdAt": "2020-05-22T23:52:59Z",
          "updatedAt": "2020-05-22T23:52:59Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(I suppose your life would have been easier if I'd mentioned this before you put all that work into #259!!!)",
          "createdAt": "2020-05-22T23:53:35Z",
          "updatedAt": "2020-05-22T23:53:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hah, no worries :-) I can submit a PR for this, unless you'd like to take a crack at it?",
          "createdAt": "2020-05-23T00:03:01Z",
          "updatedAt": "2020-05-23T00:03:01Z"
        }
      ]
    },
    {
      "number": 265,
      "id": "MDU6SXNzdWU2MjQ5MzE3MDg=",
      "title": "Padding in expand_message_xmd test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/265",
      "state": "CLOSED",
      "author": "mratsim",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I may be missing something obvious but from the https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/259 vectors (great idea) I have an issue with msg_prime padding:\r\n\r\nVector:\r\n```\r\nname    = expand_message_xmd\r\nDST     = QUUX-V01-CS02-with-expander\r\nhash    = SHA256\r\nsecurity_param = 128\r\n\r\nmsg     =\r\nDST_prime = 515555582d5630312d435330322d776974682d657870616e646572\r\n          1b\r\nmsg_prime = 000000000000000000000000000000000000000000000000000000\r\n          000000000000000000000000000000000000000000000000000000\r\n          000000000000000000000000000000000000000000000000000000\r\n          000000000000000000000000000000000000000000000000000000\r\n          000000000000000000000000000000000000000000200051555558\r\n          2d5630312d435330322d776974682d657870616e6465721b\r\nuniform_bytes = 2eaa1f7b5715f4736e6a5dbe288257abf1faa028680c1d938cd62a\r\n          c699ead642\r\n```\r\n\r\nSpec:\r\n```\r\nexpand_message_xmd(msg, DST, len_in_bytes)\r\n\r\nParameters:\r\n- H, a hash function (see requirements above).\r\n- b_in_bytes, ceil(b / 8) for b the output size of H in bits.\r\n  For example, for b = 256, b_in_bytes = 32.\r\n- r_in_bytes, the input block size of H, measured in bytes.\r\n  For example, for SHA-256, r_in_bytes = 64.\r\n\r\nInput:\r\n- msg, a byte string.\r\n- DST, a byte string of at most 255 bytes.\r\n  See below for information on using longer DSTs.\r\n- len_in_bytes, the length of the requested output in bytes.\r\n\r\nOutput:\r\n- uniform_bytes, a byte string\r\n\r\nSteps:\r\n1.  ell = ceil(len_in_bytes / b_in_bytes)\r\n2.  ABORT if ell > 255\r\n3.  DST_prime = DST || I2OSP(len(DST), 1)\r\n4.  Z_pad = I2OSP(0, r_in_bytes)\r\n5.  l_i_b_str = I2OSP(len_in_bytes, 2)\r\n6.  msg_prime = Z_pad || msg || l_i_b_str || I2OSP(0, 1) || DST_prime\r\n7.  b_0 = H(msg_prime)\r\n8.  b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)\r\n9.  for i in (2, ..., ell):\r\n10.    b_i = H(strxor(b_0, b_(i - 1)) || I2OSP(i, 1) || DST_prime)\r\n11. uniform_bytes = b_1 || ... || b_ell\r\n12. return substr(uniform_bytes, 0, len_in_bytes)\r\n~~~\r\n```\r\n\r\n1. We can clearly see at the end of the `msg_prime` this part `l_i_b_str || I2OSP(0, 1) || DST_prime`\r\n`002000515555582d5630312d435330322d776974682d657870616e6465721b`\r\n2. However preceding this `0020...` we have 4*54+40 zeros for a total of 256.\r\n3. As the msg is empty, those come from Z_pad.\r\n4. Z_pad uses the hash block size, for SHA256 (the test vector config), it's 64 bytes.\r\n5. In hex 64 zero bytes would lead to 128 zeros\r\n6. We have 256 zeros, was z_pad mistakenly duplicated?",
      "createdAt": "2020-05-26T14:33:54Z",
      "updatedAt": "2020-05-26T17:47:01Z",
      "closedAt": "2020-05-26T17:47:01Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. I just checked that the code does the right thing, so I am guessing the disconnect is in the way things are getting translated into the test vectors (which is good---much worse if the code is broken!).\r\n\r\nI may not have time to look into this until tomorrow afternoon or Thursday, but I'll get back to you asap.\r\n\r\nThanks for the report!",
          "createdAt": "2020-05-26T15:13:13Z",
          "updatedAt": "2020-05-26T15:13:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, well, here's an obvious issue: the SHA-256 and SHA-512 test vectors are identical. I'm guessing this means what we're listing as SHA-256 test vectors are not.",
          "createdAt": "2020-05-26T15:20:05Z",
          "updatedAt": "2020-05-26T15:20:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Aha! found it. I'll open a PR now.",
          "createdAt": "2020-05-26T15:28:58Z",
          "updatedAt": "2020-05-26T15:28:58Z"
        }
      ]
    },
    {
      "number": 271,
      "id": "MDU6SXNzdWU2Mjc1NjgwNjg=",
      "title": "Compliance with draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/271",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Is there some part in the document that talks about what a library needs to implement in order to be compliant or compatible with the document?\r\n\r\n",
      "createdAt": "2020-05-29T22:00:08Z",
      "updatedAt": "2020-06-01T16:37:31Z",
      "closedAt": "2020-06-01T16:37:31Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I might be misunderstanding the question, but: does {{suites-howto}} do this?",
          "createdAt": "2020-05-29T22:13:22Z",
          "updatedAt": "2020-05-29T22:13:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The section {{suites-howto}} tells the pieces that a library needs to implement. And this section is **useful**.\r\n\r\nHowever, my question is regarding the following situation;\r\nSuppose a library XX claims that has _compatible_  methods for hashing to curves. \r\nThen, what is the minimal functionality an auditor of XX must look for in order to approve or disprove the claim?\r\n\r\n-- I consider that the implementation of suites must be enough, and this should be pointed somewhere in the document. \r\n\r\nNothing prevents that a library YY only implements part of the suite, say e.g. only the SSWU map, but without implementing the full suite (which could or not violate the security guarantees we provide with the full suite). Hence, does library YY is _compatible_ with the document?\r\n",
          "createdAt": "2020-05-29T22:26:12Z",
          "updatedAt": "2020-05-29T22:26:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, anything that implements a suite according to the guidelines in section 8 should be considered compatible.",
          "createdAt": "2020-05-30T00:14:38Z",
          "updatedAt": "2020-05-30T00:14:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I don't think we ought to specify any sort of \"mandatory to implement\" suites. If an application implements any one of the suites (per the spec), it's compatible.",
          "createdAt": "2020-05-30T00:37:38Z",
          "updatedAt": "2020-05-30T00:37:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as no action is required.",
          "createdAt": "2020-06-01T16:37:31Z",
          "updatedAt": "2020-06-01T16:37:31Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "MDU6SXNzdWU2Mjc2MTkxMzQ=",
      "title": "protocol vs application",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/273",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@grittygrease and @chris-wood have both pointed out that we are not consistent on protocol vs application. We should decide one one and then do a consistency sweep.",
      "createdAt": "2020-05-30T01:13:27Z",
      "updatedAt": "2020-06-01T01:03:29Z",
      "closedAt": "2020-06-01T01:03:29Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/272/files#r432791682",
          "createdAt": "2020-05-30T01:14:04Z",
          "updatedAt": "2020-05-30T01:14:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd go with application since it's more generic. ",
          "createdAt": "2020-05-30T01:31:08Z",
          "updatedAt": "2020-05-30T01:31:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I did a sweep through the document and pushed a commit in #272 that tries to address this.\r\n\r\nMy take is that there are clear cases where \"protocol\" is the right word (i.e., where we mean \"cryptographic protocol\" in an abstract sense---so, when we're talking about a security analysis, etc.), and there are clear cases where \"application\" is the right word (i.e., where we mean a concrete instantiation). I looked at each instance of each word and tweaked where it seemed appropriate.\r\n\r\nAt this point I can imagine disagreements over individual uess of the words---and I certainly don't think I got them all \"right\"!---but I think a blanket search-and-replace in either direction would reduce clarity / precision.",
          "createdAt": "2020-05-30T05:30:24Z",
          "updatedAt": "2020-05-30T05:30:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can close this with #272 now merged, right?",
          "createdAt": "2020-06-01T00:59:12Z",
          "updatedAt": "2020-06-01T00:59:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Anyone who disagrees should feel free to reopen :)",
          "createdAt": "2020-06-01T01:03:29Z",
          "updatedAt": "2020-06-01T01:03:29Z"
        }
      ]
    },
    {
      "number": 279,
      "id": "MDU6SXNzdWU2MzkwNzExNjA=",
      "title": "Clean up Table 1 formatting",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/279",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From the list:\r\n\r\n> a. I think Table 1 (Sec. 2.1) could be better formatted, using less \r\n> line breaks. Please consider redistributing the widths of the columns.\r\n",
      "createdAt": "2020-06-15T19:02:50Z",
      "updatedAt": "2020-06-16T03:51:43Z",
      "closedAt": "2020-06-16T03:51:43Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Probably this means editing the text file that results from running kramdown, right?",
          "createdAt": "2020-06-15T19:35:55Z",
          "updatedAt": "2020-06-15T19:35:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think so. We might close this if we think that's too much work. :-)",
          "createdAt": "2020-06-15T19:52:31Z",
          "updatedAt": "2020-06-15T19:52:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Easy enough to tweak before submitting the text file to datatracker... just have to remember to do it with every update.\r\n\r\nI wonder if eventually the RFC Editor might not touch up the table anyhow...",
          "createdAt": "2020-06-15T19:59:35Z",
          "updatedAt": "2020-06-15T19:59:59Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "MDU6SXNzdWU2MzkwNzI3MzA=",
      "title": "Consider NOT RECOMMENDing protocol versions in DSTs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/280",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For the sake of backwards compatibility. From the list:\r\n\r\n> e. Domain separation (Sec. 3.1): I believe that if needed for backwards \r\n> compatibility, it is not a disaster if we omit the version number from \r\n> the Tag. Maybe it is worth a \"NOT RECOMMENDED\".",
      "createdAt": "2020-06-15T19:05:43Z",
      "updatedAt": "2020-06-19T22:48:51Z",
      "closedAt": "2020-06-19T22:48:50Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I didn't feel strongly about this, and @kwantam's comment over in #283 seemed similar. So, closing.",
          "createdAt": "2020-06-19T22:48:50Z",
          "updatedAt": "2020-06-19T22:48:50Z"
        }
      ]
    },
    {
      "number": 281,
      "id": "MDU6SXNzdWU2MzkwNzQyNTY=",
      "title": "s/MUST/SHOULD for rejection sampling",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/281",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We discourage non-constant-time implementations with a SHOULD, yet prohibit rejection sampling with a MUST. This is somewhat inconsistent, and probably worth unifying. From the list:\r\n\r\n> f. It says that expand_message MUST NOT use rejection sampling (5.3.4). \r\n> To the best of my understanding, rejection sampling is to be avoided \r\n> for the sole purpose of mitigating side channel attacks; this is \r\n> defined (Sec. 4) as a SHOULD, so I believe this SHOULD should (no pun \r\n> intended :-) propagate there.",
      "createdAt": "2020-06-15T19:08:22Z",
      "updatedAt": "2020-06-17T00:13:21Z",
      "closedAt": "2020-06-17T00:13:21Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I do not think this is an inconsistency.\r\n\r\nAs background (and as we all know), different hash_to_field methods are mutually incompatible in general. This means that any h2c suite that specifies rejection sampling *must* be implemented that way for compatibility's sake. \r\n\r\nMeanwhile, as we say in the document, implementing constant-time rejection sampling is fraught, meaning that any h2c suite that's defined to use rejection sampling should be regarded as essentially incompatible with constant-time implementation. So the reason to say MUST NOT here isn't because all implementations must be c-t, but because all suites should be reasonable to implement in c-t. This isn't true for any suite that specifies rejection sampling.\r\n\r\nI was planning to open a PR later today that clarifies the reasoning here. We can, of course, continue to edit and debate :)",
          "createdAt": "2020-06-15T19:33:36Z",
          "updatedAt": "2020-06-15T19:34:11Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Another argument to avoid the use of rejection sampling is because it is not guaranteed that ends after a deterministic number of steps.\r\nIt's clear that, in average, two guesses are needed to end up with a valid x-coordinate.\r\nHowever, there remain the case that the x-coordinate be randomly generated using, for example a bad random number generator or an attacker could alter the random generator causing the rejection sampling never ends. \r\n\r\nSo, rejection sampling is not avoided because it's difficult to implement in constant-time, but also there exist other ways to attack an implementation. ",
          "createdAt": "2020-06-15T23:39:32Z",
          "updatedAt": "2020-06-15T23:39:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "For example, one can implement a constant-time version of rejection sampling by iterating `k` times and conditionally selecting the first x that is the x-coordinate of a point, and discarding the other values. This fails suceeds with probablity 2^-k, but still relies on generating x from a (possible corrupted) PRGN.",
          "createdAt": "2020-06-15T23:43:02Z",
          "updatedAt": "2020-06-15T23:43:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this was settled by an updated in #282 that clarifies why it's a MUST NOT. Are we OK to close?",
          "createdAt": "2020-06-16T23:34:31Z",
          "updatedAt": "2020-06-16T23:34:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, let's do it!",
          "createdAt": "2020-06-17T00:13:21Z",
          "updatedAt": "2020-06-17T00:13:21Z"
        }
      ]
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWU2MzkyOTY3NDE=",
      "title": "Unify hash_to_field for small primes modulus.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/284",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I consider we can do only a slight modification on hash_to_field to support prime modulus.\r\nNamely modifying the amount of bytes requested to the `expand_message` function.\r\nSo we can avoid the use of an alternate method.\r\n\r\n\r\n",
      "createdAt": "2020-06-16T01:13:56Z",
      "updatedAt": "2020-06-29T16:55:54Z",
      "closedAt": "2020-06-29T16:55:54Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a great idea, but we have to be careful for a couple reasons:\r\n\r\n1. Any change we make to address this issue really really shouldn't change hash_to_field unless absolutely necessary, because we'd be breaking existing implementations (of which there are a bunch at this point!) just to address a corner case.\r\n\r\n2. It's not totally clear to me that it's possible to address this satisfactorily by requesting fewer bits from expand_message. The rest of my message discusses. (Some of this rehashes what I wrote in an email a few days ago.)\r\n\r\nTL;DR: I don't see a good way to give a unified hash_to_field that conveniently handles both small- and large-characteristic extension fields.\r\n\r\n---\r\n\r\nWe can regard hashing to GF(p^m), m >= 1 as selecting a random integer in the half-open range [0, p^m). When discussing uniformity, it's handy to think of this integer as comprising m digits in base p.\r\n\r\nTo sample an integer in [0, p^m) with statistical distance from uniform roughly 2^-k for arbitrary p without rejection sampling, we have a few choices:\r\n\r\n1. Select m values in [0, p) with statistical distance from uniform roughly 2^-k. At least for small m, this gives an integer in [0, p^m) with statistical distance roughly 2^-k. This is the approach that hash_to_field uses: reduce a bunch of (k + log p)-bit integers mod p.\r\n\r\n2. Select one value in [0, p^m) with statistical distance from uniform roughly 2^-k. This is the approach that hash_to_field_divrem (formerly proposed in #282) uses: reduce a (k + m log p)-bit integer mod p^m.\r\n\r\n3. Some interpolation between the above approaches. For example, we might select n integers in [0, p^(m/n)) with statistical distance from uniform roughly 2^-k, then regard each as comprising m/n digits in base p. This would require reducing (k + (m/n) log p)-bit integers mod p^(m/n).\r\n\r\nIt's also worth mentioning a class of approaches that *do not* work. It's tempting to think, for example, that since (k + m log p) bits is enough, we can hash to m digits by reducing m, (k/m + log p)-bit integers mod p. But this doesn't work---we get statistical distance upper bounded by 2^-(k/m) for each digit, which is *far* too big!\r\n\r\n---\r\n\r\nOf the above approaches, option (2) is the most efficient from a hashing standpoint---it only requires k + m log p bits, which is k * (m - 1) fewer bits than option (1).\r\n\r\nOn the other hand, when log p >= k, option (1) is *far* easier to implement. The reason is, multiplying two (log p)-bit integers requires reducing a (2 log p)-bit intermediate value mod p---so we can reuse the same modular reduction code when log p >= k, i.e., when 2 log p >= k + log p.\r\n\r\nWhen k is much greater than log p, option (1)'s simplicity advantage vanishes, because k + log p is significantly bigger than 2 log p, which means we'd need to implement a special modular reduction routine anyway. At this point, it seems like option (2) is better. (Note that I'm making the simplifying assumption that options (1) and (2) require similarly difficult implementations, which is not strictly true. But I don't see how to make finer distinctions without getting bogged down in details.)\r\n\r\n---\r\n\r\nSo it seems like, for curves over high-degree extensions of small-ish characteristic (e.g., GF(9767^19)---which is a pretty extreme example), we want a fundamentally different approach than for curves over low-degree extensions of large-ish characteristic. I don't see another way to reconcile this, because option (2) makes implementation *really* ugly when log p is big. For example, when hashing to GF((2^581)^8) (which one would do when hashing to G2 of BLS48-581), option (2) requires DIVREM to handle roughly 4900-bit integers (!!!), which seems like a non-starter.\r\n\r\n---\r\n\r\nIf we write down option (2) in the appendix as I've proposed in #282, we could add a subsection discussing option (3), which is easily implemented using option (2) as a subroutine. For the case of GF(9767^19), for example, one could hash to 2 elements of GF(9767^10) and convert that into an element of GF(9767^19) simply by concatenating the vector representations and throwing one vectory entry away.\r\n\r\nThe reason to consider this approach is that it limits the size of the input that DIVREM needs to handle, which *may* make implementing DIVREM easier. For hashing to an element of GF(9767^19) in one shot, DIVREM needs to handle 394-bit inputs. By instead hashing to two elements of GF(9767^10), DIVREM only needs to handle 268-bit integers.\r\n\r\n(Note that I haven't thought carefully about how to implement DIVREM nicely, though, so maybe the difference between 268 bits and 394 bits is not worth the extra 140ish bits of hash output that it requires.)",
          "createdAt": "2020-06-16T03:31:03Z",
          "updatedAt": "2020-06-16T06:13:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I opened #286 to make the proposed alternative method concrete. We can continue discussing here or discuss there as you like! @chris-wood @armfazh ",
          "createdAt": "2020-06-16T19:24:42Z",
          "updatedAt": "2020-06-16T19:24:42Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in #287 ",
          "createdAt": "2020-06-29T16:55:54Z",
          "updatedAt": "2020-06-29T16:55:54Z"
        }
      ]
    },
    {
      "number": 288,
      "id": "MDU6SXNzdWU2NDg0MjAyNDk=",
      "title": "feedback from Dan",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/288",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A couple points of feedback from Dan:\r\n\r\n1. Should include suites for more pairing-friendly curves, since BLS signatures are one of the common use cases. We've also heard this from Michael Scott. Probably makes sense to define suites for all of the curves in the pairing-friendly curves document.\r\n\r\n2. \"Nonuniform encoding\" vs \"random-oracle encoding\" is the wrong terminology. The reason is, the \"nonuniform encoding\" is *also* a random oracle---it's just one that has a nonuniform output distribution. This is important because the current text does not communicate the security properties of the encoding in a way that is useful to people specifying future documents. We've also heard this feedback from Leo Reyzin; we made some tweaks to the text in response, but probably not enough.\r\n\r\nFor the first one, the action is pretty simple: just write down suites for the extra curves!\r\n\r\nFor the second one, the edits will be more extensive but the main change would be to the names we use in Section 3 (most of the edits will be propagating this terminology elsewhere).\r\n\r\nDan proposed \"nonuniform encoding\" and \"uniform encoding\" for NU and RO, respectively. Then we can add text in Section 3 and maybe Section 10 discussing the specific properties we get from each.\r\n\r\nThoughts?",
      "createdAt": "2020-06-30T18:59:28Z",
      "updatedAt": "2020-07-13T20:50:21Z",
      "closedAt": "2020-07-13T20:50:21Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree, note that adding suites in the pf-draft will exemplify how to create a suite following the recommendations given in the h2c draft.\r\n\r\nFor the second, is there a way to make a conection with the term `hashing`? Both encodings are deterministic hash functions, one of them is indiferentiable from a random oracle. Does the terms proposed are closely related to standard definitions, e.g. https://eprint.iacr.org/2003/161 ? \r\n",
          "createdAt": "2020-07-01T19:04:53Z",
          "updatedAt": "2020-07-01T19:05:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Agree, note that adding suites in the pf-draft will exemplify how to create a suite following the recommendations given in the h2c draft.\r\n\r\nAh, sorry that my initial statement was ambiguous. I think it would be good to define suites for those curves in h2c, since the pairing-friendly curves draft is nearing completion.\r\n\r\n> For the second, is there a way to make a conection with the term `hashing`? Both encodings are deterministic hash functions, one of them is indiferentiable from a random oracle.\r\n\r\nThe issue is, the term \"hashing\" is not really a well-defined technical term. For example, both of them are resistant to collisions and preimages, but they have other properties, too, e.g., it's infeasible to find inputs s.t. the output points satisfy any algebraic relation. And indeed *both* are indifferentiable from random oracles (as long as hash_to_field works correctly), it's just that one of the oracles has a nonuniform output distribution (but this is still a perfectly valid random oracle!).\r\n\r\nI will take a look at the paper you referenced and post another reply soon.",
          "createdAt": "2020-07-02T04:32:27Z",
          "updatedAt": "2020-07-02T04:32:27Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right, I'm familiar with MRH03. So I think what's going on is as stated above---both are indifferentiable.\r\n\r\n----\r\n\r\nSketching the simulator for encode_to_curve (this is nearly the same as the simulator from BCIMRT10): suppose that we have an ideal algorithm H that on input msg in `{0,1}^*` selects a point in the image of map_to_curve with an output distribution matching the one induced by map_to_curve when inputs range uniformly over F. The simulator's job is, roughly, to \"explain\" how this point came from h, the hash_to_field random oracle.\r\n\r\nOn a fresh query msg in `{0,1}^*`, the simulator queries H(msg) and gets a point P that is in the image of map_to_curve. It then computes the preimages of P under map_to_curve---these are elements u of F such that map_to_curve(u) == P---picks one at random, and simulates h(msg) by replying with that value. Since H(msg) chooses P from the distribution induced by map_to_curve, this value of h(msg) is satistically close to uniform as required.\r\n\r\nThe only question remaining is, can the simulator invert map_to_curve efficiently? The answer is yes in all cases: Elligator 2 is easy to invert, and Tibouchi shows in [Elligator Squared](https://eprint.iacr.org/2014/043/) that both SvdW and SWU can be inverted efficiently.\r\n\r\n(Note that I'm implicitly using composition of indifferentiability above: we know that hash_to_field is indifferentiable, so this means the simulated value h(msg) can itself be simulated in terms of the underlying random oracle, e.g., the SHA-2 compression function.)",
          "createdAt": "2020-07-02T05:09:20Z",
          "updatedAt": "2020-07-02T05:11:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Dan proposed \"nonuniform encoding\" and \"uniform encoding\" for NU and RO, respectively. Then we can add text in Section 3 and maybe Section 10 discussing the specific properties we get from each.\r\n\r\nI like this change, even though it is a bit more invasive. The notion of a uniform distribution is probably easier to understand than Random Oracle, which might make choosing the right encoding less error-prone.",
          "createdAt": "2020-07-03T00:15:11Z",
          "updatedAt": "2020-07-03T00:15:11Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "After going through the papers, I think the key point on the distinction betwen encode_to_curve and hash_to_curve is that one of them is constructed using an admissible encoding (under Def 4 of BCIMRT10).\r\nDef 4 augments the previous definition by requiring the `Regular` property. This property ensures that the output distributions are unifom. So, being more technical, we can say that hash_to_curve is constructed with an admissible encoding function. However, just saying that the encoding is uniform, it seems to have the same meaning. So I am in favor to replace the names.\r\n\r\nAlso the important fact is not whether encode_to_curve and hash_to_curve are random-oracles (yes, both are), but instead we must communicate in the draft that the distinction is on whether or not they can be used to replace an ideal primitive of a hash function in the random oracle model.\r\n\r\nFinally, the indifferentiability property seems to follow easily, as it does not take into account the probability distribution of outputs. So this argument is orthogonal, and we might not require an explicit proof of indifferentiability in the document.\r\n\r\nI left some suggestions in the PR too.\r\n\r\n",
          "createdAt": "2020-07-09T23:02:14Z",
          "updatedAt": "2020-07-09T23:02:14Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "MDU6SXNzdWU2NTYxNjkzNzI=",
      "title": "suites for pairing-friendly curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/290",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per recent discussion on the CFRG mailing list, either this draft or pairing-friendly curves will want to add suites for all of the curves in the p-f-c document.\r\n\r\nProbably BLS12-381 should live wherever the other suites do.\r\n\r\nI'm happy adding them all here, but I'm curious what @armfazh and @chris-wood think.",
      "createdAt": "2020-07-13T21:52:04Z",
      "updatedAt": "2021-09-14T01:34:34Z",
      "closedAt": "2021-09-14T01:34:34Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be good to have the suites in h2c, however it seems to me that the pfc-draft still needs more work to be done until reaching to a final set of curves.\r\nWe probably do not want the pfc be a dependency of the h2c draft.\r\nI am ok with having the bls12-381 suite in h2c, as serves as an example on how to specify suite for future specifications of pairing friendly curves.\r\nThe suites for the remainder pf curves can be included in the pfc draft. \r\n",
          "createdAt": "2020-07-13T22:09:49Z",
          "updatedAt": "2020-07-13T22:09:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am ok with having the bls12-381 suite in h2c, as serves as an example on how to specify suite for future specifications of pairing friendly curves. The suites for the remainder pf curves can be included in the pfc draft.\r\n\r\nAgreed.",
          "createdAt": "2020-07-14T16:56:39Z",
          "updatedAt": "2020-07-14T16:56:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam do we still need this, or should we close this out?",
          "createdAt": "2020-10-17T23:09:52Z",
          "updatedAt": "2020-10-17T23:09:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think both documents are at or near RGLC, so maybe the question of where to put the suites is a good one to pose on the mailing list. Maybe close this issue after it's decided for sure?",
          "createdAt": "2020-10-18T18:44:06Z",
          "updatedAt": "2020-10-18T18:44:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds good! Do you want to pose this question to the list (in the context of the BLS draft)?",
          "createdAt": "2020-10-21T17:24:17Z",
          "updatedAt": "2020-10-21T17:24:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I propose we close this out. We have BLS-381 in the draft now. Suites for BN curves can go in the p-f-c draft. ",
          "createdAt": "2021-09-13T22:29:26Z",
          "updatedAt": "2021-09-13T22:29:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me!",
          "createdAt": "2021-09-14T01:34:34Z",
          "updatedAt": "2021-09-14T01:34:34Z"
        }
      ]
    },
    {
      "number": 291,
      "id": "MDU6SXNzdWU2NzIyNTE5MzY=",
      "title": "suggest way of composing expand_message with ristretto's FROM_UNIFORM_BYTES?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/291",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I know this is something we've discussed before (certainly @chris-wood and I have), but:\r\n\r\nWould it make sense for us to add (say, in an appendix) a suggested way of composing the h2c primitives with the Ristretto FROM_UNIFORM_BYTES API? I've gotten a few questions about this from folks implementing VOPRFs on ristretto255, and my impression is that the Ristretto authors are adamant about wanting no mention of hash functions in their document.\r\n\r\nThe obvious suggestion for ristretto255 is to pick a DST and call `FROM_UNIFORM_BYTES(expand_message_XXX(msg, DST, 64))`. Honestly, I'd even be OK mentioning this in the Suites section...",
      "createdAt": "2020-08-03T18:07:37Z",
      "updatedAt": "2020-08-23T17:12:02Z",
      "closedAt": "2020-08-23T17:12:02Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @armfazh @grittygrease @chris-wood",
          "createdAt": "2020-08-03T18:08:06Z",
          "updatedAt": "2020-08-03T18:08:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think this makes sense. It likely needs to be written down somewhere, and I really don't have a strong feeling as to where it goes. The only oddity about making this a suite is that the document's title is \"hash to curve,\" whereas Ristretto isn't \"really\" a curve. ",
          "createdAt": "2020-08-03T23:36:25Z",
          "updatedAt": "2020-08-03T23:36:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Hot take: Ristretto really *is* a curve, it's just dressed up in a funny way :smile:\r\n\r\nI can write something down later today or tomorrow. I think it'll be in an appx since it won't follow the required format of a suite, but we can play around with it and see what works best once we have some text.",
          "createdAt": "2020-08-04T19:07:46Z",
          "updatedAt": "2020-08-04T19:08:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Hot take: Ristretto really is a curve, it's just dressed up in a funny way \ud83d\ude04\r\n\r\nHah, okay, fine. I was speaking in terms of the API. ",
          "createdAt": "2020-08-04T19:44:50Z",
          "updatedAt": "2020-08-04T19:44:50Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "An alternative way is to describe how the output of one of the h2c ciphersuites can actually be used to generate a ristretto element.\r\nFor example:\r\n\r\n```python\r\ndef h2c_ristretto(msg,dst):\r\n    P = edwards25519_XMD:SHA-512_ELL2_RO_(msg, DST)\r\n    return P as ristrettoPoint\r\n```",
          "createdAt": "2020-08-06T18:27:21Z",
          "updatedAt": "2020-08-06T18:27:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems completely possible. I worry that the Ristretto authors would get annoyed by this since it completely sidesteps the \"this is not a curve\" abstraction they're trying to build. (And in fact when I've spoken with them about ~exactly~ something like this proposal in the past they were explicitly not happy about it for that reason.)",
          "createdAt": "2020-08-06T19:19:07Z",
          "updatedAt": "2020-08-06T19:19:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way, apologies that I have not yet written this down---trying to push something else towards completion. I will aim to have it done in the next couple days, and certainly before the end of the weekend.",
          "createdAt": "2020-08-06T19:20:36Z",
          "updatedAt": "2020-08-06T19:20:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I think we should not break that abstraction, even if it may be correct. ",
          "createdAt": "2020-08-06T19:20:49Z",
          "updatedAt": "2020-08-06T19:20:49Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a contentious enough point that it should be discussed on-list.\n\nOn Thu, Aug 6, 2020 at 12:21 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Agreed. I think we should not break that abstraction, even if it may be\n> correct.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/291#issuecomment-670145784>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ2MPXRYW6UEHJRQ2IDR7L7B7ANCNFSM4PTSWOCA>\n> .\n>\n",
          "createdAt": "2020-08-06T22:40:17Z",
          "updatedAt": "2020-08-06T22:40:17Z"
        }
      ]
    },
    {
      "number": 292,
      "id": "MDU6SXNzdWU2NzI5Mjc4ODY=",
      "title": "Thomas' nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/292",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " * In section 4 (page 12): \"all arithmetic, comparisons, and assignments MUST...\" -> I think it lacks a word after \"arithmetic\". Maybe \"all arithmetic operations\"?\r\n * In section I.3, the renaming \"SHAKE-128\" -> \"SHAKE128\" has been applied, but the section still contains \"hash = SHAKE_128\" (I suppose that the underscore character evaded the search&replace).\r\n \r\nAlso, some pseudocode blocks have been moved left by three characters (i.e. the three-space margin was removed). This is not systematic; e.g. sgn0() was moved left (section 4.1), but not sgn0_m_eq_1() (in the same section!). Pseudocode blocks that lost their margin are:\r\n\r\n * sgn0() (4.1)\r\n * sgn0_m_eq_2() (4.1)\r\n * map_to_curve_svdw() (D.1)\r\n * map_to_curve_simple_swu() (D.2)\r\n * map_to_curve_elligator2() (D.3)\r\n * map_to_curve_simple_swu_3mod4() (E.2.1)\r\n * map_to_curve_elligator2_curve25519() (E.3.1)\r\n * map_to_curve_elligator2_edwards25519() (E.3.2)\r\n * map_to_curve_elligator2_3mod4() (E.3.5)\r\n * map_to_curve_elligator2_5mod8() (E.3.6)\r\nAdditionally, the map_to_curve_elligator2_curve448() pseudocode (E.3.3) has a reduced margin with a single space instead of three.",
      "createdAt": "2020-08-04T16:38:33Z",
      "updatedAt": "2020-08-08T19:11:20Z",
      "closedAt": "2020-08-08T19:11:20Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam after we land these, we can spin a new version for RGLC (per instruction from the chairs). Do we also want to land the ristretto255 change, too?",
          "createdAt": "2020-08-04T16:43:32Z",
          "updatedAt": "2020-08-04T16:43:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood yes, let's land both.\r\n\r\nSome responses:\r\n\r\n- \"all arithmetic\" seems fine to me---it's a noun in this context.\r\n- oh sorry, must have missed the SHAKE_128 last time around\r\n- agreed that we should make the margins consistent where possible.",
          "createdAt": "2020-08-04T19:04:16Z",
          "updatedAt": "2020-08-04T19:04:50Z"
        }
      ]
    },
    {
      "number": 296,
      "id": "MDU6SXNzdWU3MjQwNzEwMDg=",
      "title": "collecting rglc comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/296",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Greg Hudson: https://mailarchive.ietf.org/arch/msg/cfrg/o1y2Ue3wY_w2_IQEUEtPi92wifg/\r\n\r\nWatson Ladd: https://mailarchive.ietf.org/arch/msg/cfrg/x14oafwcQ26rM_XJVzgMFLeSRsM/\r\n(see also Hal Murray's followup) \r\n\r\nDaira Hopwood: https://mailarchive.ietf.org/arch/msg/cfrg/ZYlKNd4JJiJxNTYSwrY-ZFb4LeI/",
      "createdAt": "2020-10-18T18:43:08Z",
      "updatedAt": "2021-09-14T01:35:20Z",
      "closedAt": "2021-09-14T01:35:20Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I think the only remaining issue to resolve here is Greg's point of feedback. Given that we don't yet have a better term besides \"random,\" I propose we keep things as they are.",
          "createdAt": "2021-09-13T22:30:42Z",
          "updatedAt": "2021-09-13T22:30:42Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree. Closing.",
          "createdAt": "2021-09-14T01:35:20Z",
          "updatedAt": "2021-09-14T01:35:20Z"
        }
      ]
    },
    {
      "number": 298,
      "id": "MDU6SXNzdWU3NTQ1MzQ4MzM=",
      "title": "Wishlist topic: Please cover the number of Pre-images per point and mapping algorithm more in depth.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/298",
      "state": "CLOSED",
      "author": "BjoernMHaase",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello, H2C team.\r\n\r\nMichel, Julia and I (Bj\u00f6rn) are currently working on a security proof for CPace, where the main complexity is to properly deal with the different flavours of mapping and their specific properties. I.e. this is strongly related to your work in the H2C team.\r\n\r\nI promised to give you a first feedback regarding the present draft. I will go through the draft more in depth soon and keep you synchronized.\r\n\r\nOne of the objectives is to dig a bit more into the details of the mappings instead of just considering them to be some form of random oracle hashing to the group.\r\n\r\nInterrestingly for the security analysis, one of the key features of the mappings actually seems to be the property of *invertability*.\r\n\r\nTo give you an idea regarding the properties of the maps that I believe to be important from a theoretical point of view, find enclosed the features that seem to be necessary/helpful for formally reducing the diffie-hellman problems. I'd suggest to name the property \"probabilistic invertability\".\r\n\r\n![grafik](https://user-images.githubusercontent.com/14183424/100763887-0a237780-33f6-11eb-8c2e-675aba25dbe9.png)\r\n![grafik](https://user-images.githubusercontent.com/14183424/100763965-1f98a180-33f6-11eb-95cb-55fce2922218.png)\r\n\r\n![grafik](https://user-images.githubusercontent.com/14183424/100764088-422aba80-33f6-11eb-8d0a-25ecc56fa6af.png)\r\n![grafik](https://user-images.githubusercontent.com/14183424/100764192-5cfd2f00-33f6-11eb-9a5a-b0fe1e6036c3.png)\r\n\r\nIMO, all of the maps from the current RFC draft seem to fulfill this requirement set. Essentially, it must be efficient to predetermine the max. numbers of pre-images for any single point on the group. Secondly, there needs to be an efficient function for obtaining all pre-images.\r\n\r\nIt is my intuition that this invertability guarantees to some extend that no DLP-related structure can be exposed or exploitable by points generated by the map, as long as DLP remains hard. For mappings that employ exponentiations (such as used in TBPEKE or SPAKE2) and which are, thus, not efficiently invertable, some attacks could exist that allow to use some structure in the mapping-generated points for attacking the DLP / DH-style protocols that use the points. (e.g. N,M in SPAKE2 with known DL). Invertible maps could not generate such structure.\r\n\r\n(Actually, we will be able to prove security for CPace also for the H2C curve with more uniform distribution, however this will most proably require slightly more work than using the generic encodings with non-uniform distribution.)\r\n\r\nInvertability and the structure or the images and the distributions does not presently play an important role in the H2C draft. This is a good idea, when keeping a h2c-user-centric view. Still I think that it might be helpful to add more explicit information on the max. number of pre-images for the different mapping algorithms (SWU, SSWU, Elligator2, ...), as the security bounds seem to depend on this value, at least for CPace.\r\n\r\nBj\u00f6rn",
      "createdAt": "2020-12-01T16:19:07Z",
      "updatedAt": "2021-09-14T01:38:57Z",
      "closedAt": "2021-09-14T01:38:57Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Bj\u00f6rn! Thanks for the very detailed suggestion.\r\n\r\nThere is a very small discussion of this in the \"Security Considerations\" section: https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-10#section-10.1\r\n\r\nAm I correctly interpreting your message as requesting even more detail? I think the papers cited in that section give the information you're looking for. Is the idea that you'd prefer to see all of this in one place?",
          "createdAt": "2020-12-02T01:45:00Z",
          "updatedAt": "2020-12-02T01:45:00Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Basically, what I am looking for is firstly to keep you synchronized with our findings.\r\n\r\nThe main point might be, that I'd like to suggest to slightly switch the focus of the RFC.\r\n\r\nAfter reading the draft, I understand that the focus of the team is \"let's provide a monolithic black-box construction that could be used as a random oracle hashing directly to group elements such that protocol designers and implementers don't need to dig into the details\".\r\n\r\nIn the course, you provide a construction which basically consists of three (or four) independent substeps:  (1) Encode to field, (2) map, (3) (optionally) add two map-generated points and (4) co-factor clearing.\r\n\r\nWhat I'd like to suggest is that there might actually be applications that don't need or want the \"big black box\" of the full construction but often the big benefit of your work might be the carefully analyzed and well-designed sub-blocks.\r\n\r\nIn my opinion, this might already be the case of ristretto and decaf, which might happily be using the encode-to-field block and possibly the map but might differ in details for other points.\r\n\r\nFor CPace, I probably would like to use everything except for the co-factor clearing.\r\n\r\nAlso for the OPRF, I am convinced that what you actually need for proving security is not a uniform hash2curve but only a well-designed mapping to the curve. As a consequence, by requiring a black-box construction with a uniformly distributed hash, you will in practice be ruling out OPRF constructions using X25519 / X448 and might even have bigger difficulties for proving security when not considering the H2C as a random oracle.\r\n\r\nSo what I'd like to suggest in practice is: In addition to the black-box approach which I also support, I'd appreciate if you embraced a bit more the \"well designed substep\" perspective of users.\r\n\r\nAnd for this, it might be helpful to have a bit more (not much more) text and pointers regarding the inner components, e.g. regarding the invertability and known information on the maximum number of pre-images per map.\r\n\r\nIn fact the information from 10.1 is already very helpful and possibly enough for proving security. Still, if it actually comes out that this small section captures the essence of what is actually needed, a bit more information on the individual mappings might be worth the effort. E.g. I currently don't know whether there is invertability also for plain SWU. For  SSWU I did review it already.\r\n\r\nOne option might be to have the information from section 10.1 regarding the different mappings transferred to the respective mapping sections for Elligator2, SWU, SSWU, etc. with 2-3 short sentences for the different maps (Elligator, SWU, SSWU, ...) regarding the respective limits on the number of preimages and the invertability.?\r\n\r\nYours,\r\n\r\nBj\u00f6rn",
          "createdAt": "2020-12-02T07:50:59Z",
          "updatedAt": "2020-12-02T07:50:59Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the detailed clarification!\r\n\r\nAt a really high level: I'm a bit concerned about shifting the focus of the document, since it's currently in last call. Also, it's not totally clear to me what shifting the focus would entail---your message suggests that it might be enough to just move some text around, but I'm not sure if I've interpreted it correctly.\r\n\r\nOne possibility might be to add a pointer to papers that discuss the relevant properties in the Security Considerations section (if they're not already---but I think they are, in Section 10.1, no?). I think this is much more likely to fly, because adding detailed technical discussion is probably outside the scope of an RFC: this document is not intended to specify all possible properties of the components, only to describe how to use them in a way that is both secure and compatible with others' usage. Other relevant properties---especially ones covered thoroughly in other documents---probably are out of scope.\r\n\r\nFinally: your message above mentions SWU. Do you mean SvdW? The document does not cover SWU, and that seems almost certain to remain true.\r\n\r\nI'm curious to hear what other folks think here. @chris-wood? @armfazh?",
          "createdAt": "2020-12-02T22:04:15Z",
          "updatedAt": "2020-12-02T22:05:01Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Do you mean SvdW. Yes.\r\n\r\nActually I misread it and thought that plain SWU is still in the draft, but obviously you have removed plain SWU some revisions ago.\r\n\r\nRight now I am trying to dig through the properties of SvdW. (Kind of difficult again, if you don't have access to springer journals, except for IACR publications, and university libraries have shut down access completely to people extern to the university ...).\r\n \r\nDo you have at hand, whether the SvdW map is also invertible, i.e. you can efficiently obtain all preimages?",
          "createdAt": "2020-12-02T23:16:26Z",
          "updatedAt": "2020-12-02T23:16:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the original paper discusses at least the number of points in the image:\r\n\r\nhttps://works.bepress.com/andrew_shallue/1/download/\r\n\r\nFouque and Tibouchi look at SvdW at Latincrypt 2012:\r\n\r\nhttps://hal.inria.fr/hal-01094321/document\r\n\r\nProbably there will be a bit of tweak necessary for the specific formulation of SvdW that we use, but I'd guess it wouldn't be so bad...",
          "createdAt": "2020-12-02T23:22:36Z",
          "updatedAt": "2020-12-02T23:22:36Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Thank you for the pointers!\r\n\r\nAs you said, limits for the size of the image are provided in the original paper and as I understand it from a first look, also invertability is available, but I will have to re-read it with a bit more time. (Actually its again about Skalba's equation and inverting will most surely involve a couple of square roots, just as for the other maps.) \r\n\r\nIn the latincrypt paper, I had the impression that this probably only covers the special case of Barreto\u2013Naehrig Curves.?\r\n\r\nThanks.\r\n\r\nYours,\r\n\r\nBj\u00f6rn.",
          "createdAt": "2020-12-03T11:48:38Z",
          "updatedAt": "2020-12-03T11:48:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "[EDITED]\r\n\r\nFWIW, I'm opposed to changing the fundamental abstraction in this document.\r\n\r\nI'd like to follow up on one comment @BjoernMHaase made above:\r\n\r\n> Also for the OPRF, I am convinced that what you actually need for proving security is not a uniform hash2curve but only a well-designed mapping to the curve. As a consequence, by requiring a black-box construction with a uniformly distributed hash, you will in practice be ruling out OPRF constructions using X25519 / X448 and might even have bigger difficulties for proving security when not considering the H2C as a random oracle.\r\n\r\nIndeed, a random oracle is not needed for the OPRF, though that's [what the draft currently uses for NIST curves](https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html#name-oprfp-256-sha-256). We probably could use the non-uniform variant (`encode_to_curve`) abstraction, though I think certain analyses may need to be updated as a result.",
          "createdAt": "2020-12-05T00:47:53Z",
          "updatedAt": "2020-12-05T00:53:53Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hello Christopher,\r\n\r\nI just was about to comment about clearing the co-factor in the map for CPace, which now seems to have been removed/edited.\r\n\r\nI believe generally, that any protocol working on a group with co-factor will have to carefully analyze the design regarding this complexity. I don't see, how a co-factor cleared mapping could avoid that analysis. It might rather create a false sense of security to believe that the co-factor complexity was already handled by the hash2curve construction and become harmful.\r\n\r\nIt is my experience that it's always best to clearly attribute the responsibilities for solving a specific problem to exactly one individual or team. If you split responsibilities to two or more parties, each of them might falsely believe that the other partner already has resolved the problem.\r\n\r\nAs such, I believe that, as Hash2Curve could not comprehensively deal with the co-factor issues, it should also not try at providing a partial mitigation. In my opinion it should not include any co-factor clearing except for a strong statement in the security section: \"We porpousefully did not consider this important aspect because we could not take off this load from your sholders and stress, that it will be necessary for you as a user to carefully analyze the implications for your protocol.\"\r\n\r\n",
          "createdAt": "2020-12-05T09:53:45Z",
          "updatedAt": "2020-12-05T10:00:04Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "There is a second aspect in Christopher's reply which deals whether uniform or non-uniform constructions should be preferred.\r\n\r\nI believe, regarding the OPRF construction for instance, that it might be worth considering is that definitions that allow for single-coordinate algorithms (such as X-coordinate only scalar multiplication on NIST curves or X25519/X448) might be an easier starting point for side-channel protected implementations. Often this approach might also be preferable from an implementation-security point of view for NIST curves. \r\n\r\nIf I recall correctly, many protocols, such as TLS only use the x  coordinate of the DH results for the session key generation and I believe this is specifically in order to also encourage single-coordinate scalar multiplication implementations.\r\n\r\nWhen using protocols using points generated by the non-uniform mappings, the \"Map twice and add\" procedure might actually be the only substep of the whole protocol that requires the full group structure. As a result single-coordinate algorithms would be ruled out for this protocol. This is most probably not a severe issue in practice for the NIST curves, as I believe that most implementations actually use full group elements anyway. \r\n\r\nHowever requiring the \"map twice and add\" effectively rules out simple X22519 and X448-based implementations.\r\n\r\nFor the security analysis, on the other hand, it might be worth having the same construction on all of the curves (i.e. no difference between NIST/Brainpool and Edwards/Montgomery) ...\r\n\r\nThis draws me to the conclusion that preferring the non-uniform maps might be the preferrable strategy.\r\n\r\nMoreover at least regarding reduction of the Diffie-Hellman problems to the standard prime-order problems I come to the conclusion that the security bounds for the non-uniform mappings will actually be tighter than for the \"map twice and add\" hash2curve constructions.\r\n\r\nBTW, I'd be willing to contribute to the security analysis of OPRF constructions with non-uniform mappings, which I believe to be straight-forward with the definition of the inverse probabilistic map above.",
          "createdAt": "2020-12-05T09:54:26Z",
          "updatedAt": "2020-12-05T09:54:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@BjoernMHaase given lack of activity on this issue, I think we should close this out. I don't think providing a possibly-unsafe abstraction (without cofactor clearing) is pragmatic. Unless there is some reason that CPace cannot use the encode_to_curve abstraction, I suggest we close this issue with no action. (I'll note that it seems plausible for CPace implementations to \"clear\" the cofactor with `h_eff = 1`, which is a no-op.) \r\n\r\n@kwantam, how much would you dislike this? :-) ",
          "createdAt": "2021-03-23T22:55:00Z",
          "updatedAt": "2021-03-23T22:55:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping @kwantam :)",
          "createdAt": "2021-09-13T22:32:08Z",
          "updatedAt": "2021-09-13T22:32:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it would be better if this h2c document gave a totally safe abstraction. Another document might give a possibly-unsafe abstraction, with lots of warnings to implementors and a pointer to the h2c doc as suited for most applications, but I worry that with the document as complex as it is, adding possibly-unsafe constructions would be dangerous.",
          "createdAt": "2021-09-14T01:37:35Z",
          "updatedAt": "2021-09-14T01:37:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good. Closing as a result. ",
          "createdAt": "2021-09-14T01:38:53Z",
          "updatedAt": "2021-09-14T01:38:53Z"
        }
      ]
    },
    {
      "number": 299,
      "id": "MDU6SXNzdWU3NTU2MTA4NDg=",
      "title": "Add Mike Hamburg's analysis regarding the close-to-uniform hash2curve construction using elligator2 to the list of references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/299",
      "state": "CLOSED",
      "author": "BjoernMHaase",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There was presently no detailed analysis regarding indifferentiable hashing for the elligator2 construction in the reference list. Mike Hamburg has provided a corresponding analysis complementing the one from [BCIMRT10] for the case of Elligator2. \r\n\r\nThe Paper is currently available at  https://www.shiftleft.org/papers/indifferentiable/ but Mike announced that he will be submitting it to the eprints.\r\n\r\n",
      "createdAt": "2020-12-02T21:08:23Z",
      "updatedAt": "2021-03-24T15:50:44Z",
      "closedAt": "2021-03-24T15:50:44Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: ePrint is up at https://eprint.iacr.org/2020/1513",
          "createdAt": "2020-12-02T22:06:54Z",
          "updatedAt": "2020-12-02T22:06:54Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU4MDk3ODQ1ODA=",
      "title": "Comparison to \"naive\" hashToCurve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/300",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "Disclaimer: I know very little about elliptic curves.\r\n\r\nThe draft gives many long and complex algorithms for hashing arbitrary bits to a curve point. However, this much simpler algorithm seems to work for any curve as well:\r\n\r\n- Pick a public point G\r\n- Pick a public hash function H (or perhaps HKDF if you need additional bits)\r\n- Hash a `byte[] x` to a curve point via `H(x)*G`\r\n\r\nThis seems to be an efficient algorithm, and results in a uniformly random curve point. Is this a valid alternative to the algorithms proposed in this draft? It's not clear from the draft what properties the algorithms in the draft have that my proposal does not.",
      "createdAt": "2021-02-17T01:50:56Z",
      "updatedAt": "2021-09-16T21:25:12Z",
      "closedAt": "2021-09-16T21:25:12Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This approach is basically covered in Appendix A.\r\n\r\n```\r\n   A naive but generally insecure method of mapping a string msg to a\r\n   point on an elliptic curve E having n points is to first fix a point\r\n   P that generates the elliptic curve group, and a hash function Hn\r\n   from bit strings to integers less than n; then compute Hn(msg) * P,\r\n   where the * operator represents scalar multiplication.  The reason\r\n   this approach is insecure is that the resulting point has a known\r\n   discrete log relationship to P.  Thus, except in cases where this\r\n   method is specified by the protocol, it must not be used; doing so\r\n   risks catastrophic security failures.\r\n```",
          "createdAt": "2021-02-17T01:54:07Z",
          "updatedAt": "2021-02-17T01:54:07Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "I see, thanks for that pointer. Do you know of a reference that discusses \"known discrete log relationships\" (or this naive approach) in more depth?",
          "createdAt": "2021-02-17T02:03:04Z",
          "updatedAt": "2021-02-17T02:03:17Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "It's inverted scalar multiplication by definition, `H(x)` is the discrete divisor aka discrete log of `H(x)*G` over `G`.  \r\n\r\nActually \"risks catastrophic security failures\" is an understatement:  All protocols that require hash-to-curve becomes trivially insecure when one makes this blunder. ",
          "createdAt": "2021-02-17T11:55:10Z",
          "updatedAt": "2021-02-17T11:55:53Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "> All protocols that require hash-to-curve\r\n\r\nHow do you know when a protocol requires hash-to-curve? I'm looking for the property (a requirement on the hash function itself, perhaps?). It's not clear to me when a protocol needs hash-to-curve, and moreover, how that requirement might be stated. There doesn't seem to be a corresponding property claimed in this draft, either.",
          "createdAt": "2021-02-17T16:38:51Z",
          "updatedAt": "2021-02-17T16:38:57Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "It depends what \"hash\" means..\r\n\r\nAlthough not a hash-to-curve, `x -> H(x)*G` provides a preimage and second-preimage resistant \"hash\" that yields a curve element.  I've only seen applications like Merkle proofs inside zkSNARKs, in which we say Pedersen hash, or in [backdooring random number generators](https://www.schneier.com/blog/archives/2007/11/the_strange_sto.html), so really they map from the Z/qZ to Z/pZ.  We do generate nonces this way in derandomized signatures like Ed25519 but then we care about the scalar, not just the point. \r\n\r\nWe say hash-to-curve anytime one makes stronger assumptions about a function `H' : {0,1}^* -> E` where `E` is the curve, like that `H'` is a random oracle or a PRF.  If `H'(x) = H(x)*G` even with `H` a random oracle then `H` belies `H'` being a PRF, meaning the adversary who queries `H` first knows what your doing.  You might instantiate `H'` similarly inside a security reduction of course, just not if the adversary can access `H`. \r\n\r\nAnything like BLS, IBE, PAKEs, VRF, and some VDF becomes trivially insecure.  You'll never \"hash\" this way, even the zkSNARKs uses are being replaced.  Also `x -> H(x)*G` has about the worst performance imaginable for a hash function. ",
          "createdAt": "2021-02-18T01:24:50Z",
          "updatedAt": "2021-02-18T01:28:04Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "@burdges That's very helpful, thanks!\r\n\r\nGetting back to the draft: I think it would be useful to explain some of this in the draft. The intro only says:\r\n> Many cryptographic protocols require a procedure that encodes an\r\n   arbitrary input, e.g., a password, to a point on an elliptic curve.\r\n   This procedure is known as hashing to an elliptic curve.\r\n\r\nIt seems to me that the naive algorithm also achieves this goal. I think it would be good to emphasize the applications which require `hash-to-curve`.",
          "createdAt": "2021-02-18T16:28:49Z",
          "updatedAt": "2021-02-18T16:28:49Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Note that scalar multiplication ( s * G ) is considered expensive, and tends to be avoided if possible. If that helps :)",
          "createdAt": "2021-02-18T18:12:47Z",
          "updatedAt": "2021-02-18T18:13:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@crockeea the draft discusses this [in Section 8](https://cfrg.github.io/draft-irtf-cfrg-hash-to-curve/draft-irtf-cfrg-hash-to-curve.html#name-suites-for-hashing):\r\n\r\n> Applications instantiating cryptographic protocols whose security analysis relies on a random oracle that outputs points with a uniform distribution MUST NOT use a nonuniform encoding. Moreover, applications that use a nonuniform encoding SHOULD carefully analyze the security implications of nonuniformity. When the required encoding is not clear, applications SHOULD use a uniform encoding for security.\r\n\r\nPerhaps this could be made more prominent in the draft. But the gist is: use hash-to-curve if you don't know what you're doing.",
          "createdAt": "2021-02-18T23:21:32Z",
          "updatedAt": "2021-02-18T23:21:32Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "@chris-wood Doesn't the naive algorithm also achieve a uniform distribution? I think I'm beginning to understand that the difference is not the _distribution_, rather it's the \"random oracle\" part: the naive algorithm cannot be used in a protocol that requires a random oracle, but hash-to-curve can (as stated in section 2.2.3). Is that right?",
          "createdAt": "2021-02-23T18:10:09Z",
          "updatedAt": "2021-02-23T18:10:09Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "It's called the Pedersen hash.  And one usually interprets it as mapping to the base field, not the group.  A group action like `x -> H(x)*G` is not an algorithm for anything discussed in this repo.\r\n\r\nI said random oracle only to exposes the issue simply, but random oracle does not characterize the problem, a hash-to-curve need not be a random oracle, other formulations exist, and nobody knows if random oracles exist.\r\n\r\nIt's actually `x -> H(x)*G` that describes the problem:  All hash assumptions discuss the absence of structure.  All \"hashes\" with algebraic structure like Pedersen hash, SWIFFT, etc. require you carefully check the assumptions you require against whatever properties folks proved the hash provides.\r\n\r\nAs an aside, ZCash shall [deprecate Pederson hash for Sinsemilla](https://twitter.com/reldev/status/1336897651925610496), which provides similar security more efficiently in Plonk.\r\n\r\nI'd close this issue honestly..",
          "createdAt": "2021-02-27T11:42:45Z",
          "updatedAt": "2021-02-27T11:42:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> the naive algorithm cannot be used in a protocol that requires a random oracle, but hash-to-curve can (as stated in section 2.2.3). Is that right?\r\n\r\nCorrect! And we clarify that in the text quoted above. Would further clarifications help? If so, could you please send a PR? I'd also be happy closing this without any action. ",
          "createdAt": "2021-03-23T22:35:51Z",
          "updatedAt": "2021-03-23T22:35:51Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "> Would further clarifications help?\r\n\r\nI do think further clarification would help, especially in the abstract and intro. What's missing for me is _why_ I should use the algorithms in this RFC. The intro says\r\n> Unfortunately for implementors, the precise hash function that is\r\n   suitable for a given protocol implemented using a given elliptic\r\n   curve is often unclear from the protocol's description.  Meanwhile,\r\n   an incorrect choice of hash function can have disastrous consequences\r\n   for security.\r\n   This document aims to bridge this gap by providing a comprehensive\r\n   set of recommended algorithms for a range of curve types.\r\n\r\nbut it does not explain what specific cryptographic property is satisfied by the algorithms in this draft that is needed by \"many protocols\". My understanding now is that the algorithms in the draft can be used as a hash function in a protocol which is proven in the RO model. Currently, neither the abstract nor the intro make any mention of random oracles, but they should.\r\n\r\nFurther down:\r\n> The reason\r\n   this approach is insecure is that the resulting point has a known\r\n   discrete log relationship to P.  Thus, except in cases where this\r\n   method is specified by the protocol, it must not be used; doing so\r\n   risks catastrophic security failures.\r\n\r\nI'm having to read between the lines here. The unstated implication (seems to be)\r\n> The reason\r\n   this approach is insecure is that the resulting point has a known\r\n   discrete log relationship to P _and therefore cannot be used in protocols that require a random oracle_.\r\n\r\nUnfortunately, I do not know enough about the details, especially around the language of random oracles, to provide text for you.",
          "createdAt": "2021-03-24T23:12:45Z",
          "updatedAt": "2021-03-24T23:12:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback. This is super useful.\r\n\r\nBut I want to push back slightly on the idea of describing the relevant property in terms of \"random oracles\" in the intro, for two reasons. First, \"random oracle\" doesn't seem like the right abstraction for the introductory material. Second, it's not actually the relevant property, as @burdges says. There are plenty of protocols that are secure without resorting to the random oracle model, but insecure with hash-to-exponent/Pedersen hash. BLS signatures are one example.\r\n\r\nThe object we need is called a hash function to an elliptic curve in the cryptographic literature. Hash-to-exponent is just not such a function. It may make sense to explain that fact in the intro, but it shouldn't be done with shorthand that is subtly wrong (which would be the case if we were talking about random oracles), because that shorthand might convince a literal-minded reader that they don't need a hash to curve when they actually do.\r\n\r\nWe could define it more precisely, presumably by saying something about collision resistance and infeasibility of computing discrete log of the resulting point (provided that discrete log is hard in the target curve). We might have to handwave a tiny bit to avoid having to write down a security game, but to me that's preferable to saying something that is clearly wrong.",
          "createdAt": "2021-03-25T01:12:31Z",
          "updatedAt": "2021-04-23T18:59:39Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "MDU6SXNzdWU4MTE1ODY4MTI=",
      "title": "Define hashing to scalar",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/301",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just like hash_to_curve, maybe a function for hashing to a scalar (e.g. \"hash_to_scalar\") could be defined, that would be an alias of hash_to_field.\r\n\r\nhttps://github.com/armfazh/h2c-go-ref implements such a functions",
      "createdAt": "2021-02-19T00:41:15Z",
      "updatedAt": "2023-02-23T21:39:11Z",
      "closedAt": "2021-02-20T01:19:24Z",
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "NONE",
          "body": "I think 'hash_to_field' should work for this. \r\n\r\n```\r\nThe hash_to_field function is also suitable for securely hashing to scalars. For example, when hashing to scalars for an elliptic curve (sub)group with prime order r, it suffices to instantiate hash_to_curve with target field GF(r).\r\n```",
          "createdAt": "2021-02-20T00:39:26Z",
          "updatedAt": "2021-02-20T00:39:26Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "NONE",
          "body": "Sorry, my comment was going to be: not sure how different hash_to_scalar is from hash_to_field, as it seems like the last one is used for hashing to scalars.",
          "createdAt": "2021-02-20T00:40:41Z",
          "updatedAt": "2021-02-20T00:40:41Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Indeed, you're right, I totally missed that paragraph. Thank you for spotting it!\r\n\r\nI wasn't thinking of anything different between the two: HashToScalar() would simply be an API naming convenience. So there would be HashToCurve() for points, and HashToScalar() for scalars, instead of HashToField().\r\n\r\nBut maybe this is totally irrelevant and not in the scope of the document.",
          "createdAt": "2021-02-20T00:47:40Z",
          "updatedAt": "2021-02-20T00:47:40Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "We used hashToField because this is a generic function that can be instantiated in, for example, hashToScalar. However, other applications can also use hashToField for their own purposes.",
          "createdAt": "2021-02-20T00:52:27Z",
          "updatedAt": "2021-02-20T00:52:27Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Yup, clear :) thank you both!",
          "createdAt": "2021-02-20T01:19:20Z",
          "updatedAt": "2021-02-20T01:19:20Z"
        },
        {
          "author": "paulmillr",
          "authorAssociation": "NONE",
          "body": "See caveat https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/343#issuecomment-1442462295: hash_to_scalar produces 0..p-1 while scalars usually must be 1..p-1",
          "createdAt": "2023-02-23T21:39:10Z",
          "updatedAt": "2023-02-23T21:39:10Z"
        }
      ]
    },
    {
      "number": 302,
      "id": "MDU6SXNzdWU4MTM5NTUzNTg=",
      "title": "Potential mistake in `hash_to_field` pseudocode ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/302",
      "state": "CLOSED",
      "author": "forgetfulmorphism",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From [this](https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-10#section-5.3) section, In the pseudocode below:\r\n\r\n```\r\n   Steps:\r\n   1. len_in_bytes = count * m * L\r\n   2. uniform_bytes = expand_message(msg, DST, len_in_bytes)\r\n   3. for i in (0, ..., count - 1):\r\n   4.   for j in (0, ..., m - 1):\r\n   5.     elm_offset = L * (j + i * m)\r\n   6.     tv = substr(uniform_bytes, elm_offset, L)\r\n   7.     e_j = OS2IP(tv) mod p\r\n   8.   u_i = (e_0, ..., e_(m - 1))\r\n   9. return (u_0, ..., u_(count - 1))\r\n```\r\n\r\nGiven `count=2` and `m=1`, the second assignment of `elm_offset` will be `L*(0 + 1 * 1)=L` which makes `tv=substr(uniform_bytes, L, L)` therefore `len(tv) != L`.  If we proceed as follows, we will get the current length for each `tv`:\r\n\r\n```\r\nelm_offset = L * (j + i * m)\r\nnext_elm_offset = L * ((j + 1) + i * m)\r\ntv = substr(uniform_bytes, elm_offset, next_elm_offset)\r\n```",
      "createdAt": "2021-02-22T23:31:42Z",
      "updatedAt": "2021-02-23T02:12:59Z",
      "closedAt": "2021-02-23T02:12:59Z",
      "comments": [
        {
          "author": "forgetfulmorphism",
          "authorAssociation": "NONE",
          "body": "Just reread the definition of `substr` and it makes sense!",
          "createdAt": "2021-02-23T02:12:59Z",
          "updatedAt": "2021-02-23T02:12:59Z"
        }
      ]
    },
    {
      "number": 304,
      "id": "MDU6SXNzdWU4MjEzMDEyNTM=",
      "title": "hash-to-field test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/304",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some protocols need to implement hash-to-field described here, but there are no test vectors to verify the implementations. \r\n\r\nWould it be possible to add reference test vectors for hash-to-field?\r\n\r\ncc @chris-wood ",
      "createdAt": "2021-03-03T16:59:09Z",
      "updatedAt": "2021-03-06T18:36:19Z",
      "closedAt": "2021-03-06T18:36:19Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kevinlewi",
          "createdAt": "2021-03-03T20:33:51Z",
          "updatedAt": "2021-03-03T20:33:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "NONE",
          "body": "An example:\r\n\r\nhash_to_field for:\r\n- ristretto255, sha512, expand_message_xmd\r\n\r\nmessage: \"abcdef0123456789\"\r\ndst: \"dst\"\r\nnumber of scalars: 1\r\noutput (serialized scalar in bytes): c34102c5c90ef745e01dd94d30454ba7e7395b45483318b7b6ba297e1424040d",
          "createdAt": "2021-03-05T20:57:31Z",
          "updatedAt": "2021-03-05T20:57:31Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Closing?",
          "createdAt": "2021-03-06T02:07:59Z",
          "updatedAt": "2021-03-06T02:07:59Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "MDU6SXNzdWU5MzA2MjU3MTA=",
      "title": "test vectors for expander should cover dst larger than 255",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/314",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "armfazh"
      ],
      "labels": [],
      "body": "Add a couple of test vectors for expander that cover longer dst (larger than 255)",
      "createdAt": "2021-06-26T06:08:00Z",
      "updatedAt": "2021-09-16T12:56:51Z",
      "closedAt": "2021-09-16T12:56:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "DST is at most 255 bytes long, as its length must fit in a single octet. Adding test vectors for DSTs longer than this doesn't seem useful. Can we close this?",
          "createdAt": "2021-09-14T15:39:38Z",
          "updatedAt": "2021-09-14T15:39:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Don't we have a provision to prehash a longer DST? I think that's what this is referring to.",
          "createdAt": "2021-09-14T16:34:43Z",
          "updatedAt": "2021-09-14T16:34:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right, [this section](https://cfrg.github.io/draft-irtf-cfrg-hash-to-curve/draft-irtf-cfrg-hash-to-curve.html#name-using-dsts-longer-than-255-).",
          "createdAt": "2021-09-14T16:36:56Z",
          "updatedAt": "2021-09-14T16:36:56Z"
        }
      ]
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWU5MzIzNDEyNDI=",
      "title": "proposal: remove k and a set fixed size",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/315",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 5.4.3 shows a method to reduce long DST to short strings.\r\n\r\nFor the MD expander, the new DST gets as large as the underlying hash function. However, for the XOF expander the output depends on `k` (the security parameter).\r\n\r\nIt is no clear what value for `k` must be chosen, so I propose to remove it and always generate a DST of the maximum allowed size (255 bytes) only for the XOF expander.\r\n\r\nHere is my proposal:\r\n\r\n```patch\r\n5.4.3.  Using DSTs longer than 255 bytes\r\n  o  For expand_message_xof using extensible-output function H, DST is\r\n      computed as\r\n\r\n-   DST = H(\"H2C-OVERSIZE-DST-\" || a_very_long_DST, ceil(2 * k / 8))\r\n+   DST = H(\"H2C-OVERSIZE-DST-\" || a_very_long_DST, 255)\r\n   \r\n  Here, a_very_long_DST is the DST whose length is greater than 255\r\n-  bytes, \"H2C-OVERSIZE-DST-\" is a 17-byte ASCII string literal, and k\r\n-  is the target security level in bits.\r\n+  bytes, \"H2C-OVERSIZE-DST-\" is a 17-byte ASCII string literal.\r\n```\r\n",
      "createdAt": "2021-06-29T08:04:29Z",
      "updatedAt": "2021-07-06T18:17:40Z",
      "closedAt": "2021-07-06T18:17:40Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "On other point of view, each suite fully specifies the parameter `k`. So, the change I proposed may not needed.",
          "createdAt": "2021-06-29T17:20:37Z",
          "updatedAt": "2021-06-29T17:20:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My vote is that we leave this as-is given that `k` is specified. @kwantam?",
          "createdAt": "2021-07-06T16:05:06Z",
          "updatedAt": "2021-07-06T16:05:06Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed!",
          "createdAt": "2021-07-06T17:42:35Z",
          "updatedAt": "2021-07-06T17:42:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of the current status.",
          "createdAt": "2021-07-06T18:17:40Z",
          "updatedAt": "2021-07-06T18:17:40Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "MDU6SXNzdWU5Mzc5ODI1NTA=",
      "title": "New faster indifferentiable hash functions to elliptic curves, including BLS12-381",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/316",
      "state": "OPEN",
      "author": "Dimitri-Koshelev",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello, H2C team.\r\n\r\nMy name is Dimitri Koshelev. I am a post-doc in Paris in the field of elliptic cryptography.\r\n\r\nBased on quite complicated interesting mathematics, I constructed new faster hash functions to elliptic curves (indifferentiable from a random oracle). Some of my works have already been checked and published. For example, in [this one](https://link.springer.com/article/10.1007/s12095-021-00478-y) I extend the simplified SWU encoding to all elliptic curves of j-invariant 1728. Recently, I also wrote new texts dedicated to faster hashing to some elliptic curves of j-invariant 0, including BLS12-381. Let me give here the links: [hashing to the group G1](https://eprint.iacr.org/2021/301) and [hashing to the group G2](https://eprint.iacr.org/2021/678). These texts are under review in some scientific journals at the moment. However, I verified all my formulas in the computer algebra system Magma.\r\n\r\nI would be very grateful to you, if you could read at least abstracts of my articles and give your opinion. Is this useful for your draft ?\r\n\r\nThanks in advance.\r\nBest regards, Dimitri.",
      "createdAt": "2021-07-06T14:52:51Z",
      "updatedAt": "2022-02-02T09:11:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing this issue, @dishport! This seems like a great contribution to the field. I think we can pursue adding suites that use your new hashing algorithms without blocking this document. \r\n\r\n@kwantam. what do you think? (Tagging @daira for some eyes, too.)\r\n\r\n",
          "createdAt": "2021-09-14T15:54:45Z",
          "updatedAt": "2021-09-14T15:54:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Is the idea that there would be a separate document that specifies the new mapping algorithms?",
          "createdAt": "2021-09-14T16:36:59Z",
          "updatedAt": "2021-09-14T16:36:59Z"
        },
        {
          "author": "Dimitri-Koshelev",
          "authorAssociation": "NONE",
          "body": "You are welcome, @chris-wood!\r\n\r\nFor the sake of completeness, let me add. Recently, I also wrote several texts ([https://eprint.iacr.org/2021/1034](https://eprint.iacr.org/2021/1034) and [https://eprint.iacr.org/2021/1082](https://eprint.iacr.org/2021/1082)) improving my previous results even more.\r\n\r\nBest regards.",
          "createdAt": "2021-09-14T16:38:16Z",
          "updatedAt": "2021-11-02T20:42:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam yeah, that's what I'm thinking.",
          "createdAt": "2021-09-14T17:06:54Z",
          "updatedAt": "2021-09-14T17:06:54Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "@dishport could you please clarify whether your method improves over the ones currently described in the draft, e.g. reduces the number of operations, or it covers more curves with a unified implementation. Those details will be great to better assess the method.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-14T17:26:41Z",
          "updatedAt": "2021-09-14T17:26:41Z"
        },
        {
          "author": "Dimitri-Koshelev",
          "authorAssociation": "NONE",
          "body": "@armfazh, yes, the new methods improve the ones currently described in the draft if j-invariant of an elliptic curve equals 0 or 1728. All the new methods require fewer exponentiations in the basic (prime) field Fp. More precisely, I constructed\r\n\r\n1. a hash function H to any elliptic curve of j-invariant 1728 (i.e., y^2 = x^3 + ax) with the cost of 1 square root in Fp (resp. 2 square roots to make H indifferentiable). The same is true for elliptic curves of j-invariant 0 (i.e., y^2 = x^3 + b) having a small divisor of the Frobenius trace (e.g., the curves BN512 and BN638 from some international standards of pairing-based cryptography). By the way, the smallest degree of an Fp-isogeny to BN512 (resp. BN638) is equal to 1291 (resp. 1523);\r\n\r\n2. an indifferentiable hash function to elliptic curves of j-invariant 0 whose the coefficient b is a quadratic residue in Fp (e.g., BLS12-381 E1 whose b = 4) with the cost of 1 cubic root in Fp (instead of 2 square roots). Moreover, I checked that the sliding window method (at least for BLS12-381) gives a quite small addition chain to compute a cubic root. Its length is even slightly smaller than the length of [the addition chain](https://github.com/supranational/blst/blob/c76b5ac69a0044432d16cfd2cce60c93c8b01872/src/sqrt-addchain.h) for a square root in Fp.",
          "createdAt": "2021-09-14T21:46:04Z",
          "updatedAt": "2021-11-02T20:41:38Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 2. Its length is even slightly smaller than the length of [the addition chain](https://github.com/supranational/blst/blob/c76b5ac69a0044432d16cfd2cce60c93c8b01872/src/sqrt-addchain.h) for a square root in Fp;\r\n\r\nNitpick for @dot-asm, I have an addition-chain of length [449 operations for sqrt](https://github.com/mratsim/constantine/blob/f5c0b6245d8a7eeda8a2190b085819f7c2270754/constantine/curves/bls12_381_sqrt.nim#L221-L223) instead of 457 operations in BLST.",
          "createdAt": "2021-10-01T14:01:33Z",
          "updatedAt": "2021-10-01T14:01:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Nitpick for @dot-asm, I have an addition-chain of length [449 operations for sqrt](https://github.com/mratsim/constantine/blob/f5c0b6245d8a7eeda8a2190b085819f7c2270754/constantine/curves/bls12_381_sqrt.nim#L221-L223) instead of 457 operations in BLST.\r\n\r\nNice! Did you find this manually, or did you use a tool (and if so: is it public?)?",
          "createdAt": "2021-10-01T15:28:35Z",
          "updatedAt": "2021-10-01T15:28:35Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I used @mmcloughlin addchain package https://github.com/mmcloughlin/addchain\r\n\r\n",
          "createdAt": "2021-10-04T09:16:45Z",
          "updatedAt": "2021-10-04T09:16:45Z"
        },
        {
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This seems like a great contribution to the field. I think we can pursue adding suites that use your new hashing algorithms without blocking this document.\r\n\r\nI agree.",
          "createdAt": "2021-10-04T13:41:45Z",
          "updatedAt": "2021-10-04T13:41:45Z"
        },
        {
          "author": "Dimitri-Koshelev",
          "authorAssociation": "NONE",
          "body": "https://link.springer.com/article/10.1007/s10623-022-01012-8\r\nHi. My article about hashing to the subgroup G1 is published since yesterday in Designs, Codes and Cryptography.",
          "createdAt": "2022-02-02T09:11:53Z",
          "updatedAt": "2022-02-02T09:11:53Z"
        }
      ]
    },
    {
      "number": 323,
      "id": "I_kwDOBtBsGM47yhOe",
      "title": "curve448 with shake?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/323",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "question"
      ],
      "body": "We paired decaf with SHAKE, so must curve448 suite use shake too?",
      "createdAt": "2021-09-21T19:07:59Z",
      "updatedAt": "2021-12-28T16:16:36Z",
      "closedAt": "2021-12-28T16:16:36Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on RFC8032, this seems like a sensible change to make. Unless @kwantam has objections, I'll send a PR.",
          "createdAt": "2021-12-09T13:44:24Z",
          "updatedAt": "2021-12-09T13:44:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Wait, so just to make sure I'm understanding: deployed ed448 implementations use shake?",
          "createdAt": "2021-12-09T15:29:39Z",
          "updatedAt": "2021-12-09T15:29:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that\u2019s my understanding, since SHAKE is required per the RFC (https://datatracker.ietf.org/doc/html/rfc8032#section-5.2).\n\nOn Thu, Dec 9, 2021, at 7:29 AM, Riad S. Wahby wrote:\n> Wait, so just to make sure I'm understanding: deployed ed448 \n> implementations use shake?\n>\n> \u2014\n> You are receiving this because you were assigned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/323#issuecomment-989958847>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/AAQSJEHWI3YVBBHHH7VVCHLUQDDO5ANCNFSM5EPM427A>.\n",
          "createdAt": "2021-12-09T15:48:10Z",
          "updatedAt": "2021-12-09T15:48:10Z"
        }
      ]
    },
    {
      "number": 328,
      "id": "I_kwDOBtBsGM49y3vi",
      "title": "RGLC feedback",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/328",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "section 4.1 sgn0 function\r\n   the definition is also dependent on how elements in the base/prime field are represented. \r\n   for example for the field GF(5), sgn0(-3) = -3 mod 2 = 1 = sgn0(3) which is not the desired effect \r\n   (but then sgn0(2) = 0).  maybe this could lead to u,y pairs whose signs disagree in a clumsy\r\n   implementation that doesn't always represent prime field elements as non-negative ints.\r\n\r\nsection 5.3 hash_to_field function\r\n  step 2 may fail as expand_message_xmd aborts when len_in_bytes exceeds a certain size\r\n \r\nsection 5.4.1 expand_message_xmd\r\n  second paragraph recommends use of sha-2 and sha-3.  consider providing a table of input\r\n  block sizes for these functions rather than mentioning the value for sha-512 and sha3-512\r\n  in the subsequent paragraph\r\n\r\n  the bound 255*b_in_bytes is checked in step 2 whereas the bound 2^16-1 is not checked\r\n\r\n  unclear why there is a bound on len_in_bytes for expand_message_xmd but not for expand_message_xof\r\n\r\nsection 6.6.1 Shallue-van de Woestjine method\r\n  step 6 multiplies tv4 by -1 if sgn(tv4)==1.  is this really necessary as the values -/+ tv5 are used\r\n  in steps 9 and 10?",
      "createdAt": "2021-10-26T21:12:48Z",
      "updatedAt": "2021-12-28T18:11:43Z",
      "closedAt": "2021-12-28T18:11:43Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> section 4.1 sgn0 function the definition is also dependent on how elements in the base/prime field are represented.\r\n\r\nIsn't this explicitly stated? I don't seen an obvious way to make this not the case for extension fields.\r\n\r\n> for example for the field GF(5), sgn0(-3) = -3 mod 2 = 1 = sgn0(3) which is not the desired effect (but then sgn0(2) = 0). maybe this could lead to u,y pairs whose signs disagree in a clumsy implementation that doesn't always represent prime field elements as non-negative ints.\r\n\r\nThis seems false. For GF(5), -3 mod 5 = 2, so sgn0(-3) != sgn0(3). I don't know why mod 2 is discussed here, but it seems like that's the source of the confusion. Unless I'm missing something, no correct implementation of sgn0 as defined in the document can have this issue.",
          "createdAt": "2021-10-27T18:29:41Z",
          "updatedAt": "2021-10-27T18:29:41Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> section 5.3 hash_to_field function step 2 may fail as expand_message_xmd aborts when len_in_bytes exceeds a certain size\r\n\r\nI suppose we could add a failure check, but it seems pretty silly to do so in pseudocode. It seems 100% clear what should happen if a subroutine call aborts in this context.\r\n\r\n> section 5.4.1 expand_message_xmd second paragraph recommends use of sha-2 and sha-3. consider providing a table of input block sizes for these functions rather than mentioning the value for sha-512 and sha3-512 in the subsequent paragraph\r\n\r\nListing facts about hash functions does not seem related to the core function of this document. I'm pretty strongly against adding this table for this reason.\r\n\r\n(Giving examples for clarity is a different matter, of course.)\r\n\r\n> the bound 255*b_in_bytes is checked in step 2 whereas the bound 2^16-1 is not checked\r\n\r\nSure, we can add this check on line 2.\r\n\r\n> unclear why there is a bound on len_in_bytes for expand_message_xmd but not for expand_message_xof\r\n\r\nexpand_message_xof is bounded by what the XOF can do. The bound in _xmd comes from the construction. I'm not sure what more can be clarified here.\r\n\r\n> section 6.6.1 Shallue-van de Woestjine method step 6 multiplies tv4 by -1 if sgn(tv4)==1. is this really necessary as the values -/+ tv5 are used in steps 9 and 10?\r\n\r\nI haven't looked at this in detail. Seems like the suggestion could be an optimization; I'd prefer clarity if they're in tension.",
          "createdAt": "2021-10-27T18:42:55Z",
          "updatedAt": "2021-10-27T18:42:55Z"
        }
      ]
    },
    {
      "number": 329,
      "id": "I_kwDOBtBsGM4-dWSm",
      "title": "elligator 2 description improvement",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/329",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Elligator 2 says:\r\n\r\n```\r\n   6.  If is_square(gx1), set x = x1, y = sqrt(gx1), and sgn0(y) == 1.\r\n   7.  Else set x = x2, y = sqrt(gx2), and sgn0(y) == 0.\r\n```\r\n\r\nThe use of `==` here seems incorrect, since it's setting rather than checking.\r\n\r\n(Reported by @iquerejeta)\r\n",
      "createdAt": "2021-11-08T20:19:09Z",
      "updatedAt": "2021-11-08T20:29:47Z",
      "closedAt": "2021-11-08T20:29:47Z",
      "comments": []
    },
    {
      "number": 331,
      "id": "I_kwDOBtBsGM5AG5a3",
      "title": "Formal methods",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/331",
      "state": "OPEN",
      "author": "spitters",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We describe our approach to formal methods here:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/47\r\n\r\nA hacspec specification of the slow algorithm for hashing to curve is now available [here](https://github.com/hacspec/hacspec/pull/200).\r\n\r\nAny suggestions on how to best interact with the standardization process would be welcome.",
      "createdAt": "2021-12-09T13:03:54Z",
      "updatedAt": "2021-12-10T08:31:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing this issue! This draft [previously had hacspec specifications](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#appendix-C.2) of some algorithms, back before hacspec moved to Rust. We abandoned this and reverted to the current algorithm descriptions and formulations since hacspec didn't appear to be well maintained at the time. Has that changed? Perhaps @franziskuskiefer knows the latest here.",
          "createdAt": "2021-12-09T13:40:45Z",
          "updatedAt": "2021-12-09T13:46:18Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "NONE",
          "body": "Right there has been some downtime after abandoning the Python version.\r\nThe new (Rust) hacspec is well and alive and I hope we can keep it that way.\r\n@spitters and his team is actively using it with the coq backend and we are using it as frontend for more and more for F* things.\r\n\r\nFor the hacspec specification @spitters links we have an open PR https://github.com/hacspec/hacspec/pull/200\r\nI'd appreciate a review of the PR with respect to correctness of the spec. Some feedback would also be interesting in terms of esthetics, e.g. is the code readable for someone unfamiliar with hacspec etc.",
          "createdAt": "2021-12-09T14:03:18Z",
          "updatedAt": "2021-12-09T14:03:18Z"
        },
        {
          "author": "spitters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see that @kasserne has meanwhile also implemented the optimized algorithm :tada: \r\nIndeed, it would be great to get feedback on how faithful hacspec is wrt the informal specification in the standard.",
          "createdAt": "2021-12-09T14:52:28Z",
          "updatedAt": "2021-12-09T14:52:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@spitters we can review the hacspec implementation. @franziskuskiefer, is there interest in hacspec implementations of the other algorithms in this spec? ",
          "createdAt": "2021-12-09T15:54:18Z",
          "updatedAt": "2021-12-09T15:54:18Z"
        },
        {
          "author": "spitters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is, we'd like to experiment with testing efficient implementations against the spec.",
          "createdAt": "2021-12-09T16:05:40Z",
          "updatedAt": "2021-12-09T16:05:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@spitters how should we go about adding them? Would one of us send PRs to hacspec, for example? ",
          "createdAt": "2021-12-09T16:06:24Z",
          "updatedAt": "2021-12-09T16:06:24Z"
        },
        {
          "author": "spitters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, a PR to hacspec seems like the canonical way. Feel free to come and discuss with us on the hacspec zulip.",
          "createdAt": "2021-12-09T16:12:29Z",
          "updatedAt": "2021-12-09T16:12:29Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "NONE",
          "body": "> @franziskuskiefer, is there interest in hacspec implementations of the other algorithms in this spec?\r\n\r\nThere certainly is :)",
          "createdAt": "2021-12-10T08:31:14Z",
          "updatedAt": "2021-12-10T08:31:14Z"
        }
      ]
    },
    {
      "number": 335,
      "id": "I_kwDOBtBsGM5C9QG0",
      "title": "why not use hkdf instead of expand_message",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/335",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "i found this https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/137 previous issue, and i'm confused was it already used for the expand message part, or was this something else?",
      "createdAt": "2022-02-03T17:17:15Z",
      "updatedAt": "2022-02-03T19:55:43Z",
      "closedAt": "2022-02-03T19:55:43Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the question! (FYI, we discussed this in #202.) The high-level summary is:\r\n\r\n- efficiency on embedded systems, and\r\n- paranoia about domain separation of the underlying hash functions.\r\n\r\nNote that it may be possible to specify expand_message in terms of HKDF (though it would require some assumptions and/or care for domain separation) and, once that's done, build a suite on top of it.",
          "createdAt": "2022-02-03T17:30:02Z",
          "updatedAt": "2022-02-03T17:30:02Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "aah. thank you i did look for hkdf while searching the issues, but this issue i missed. my question is answered!",
          "createdAt": "2022-02-03T19:55:43Z",
          "updatedAt": "2022-02-03T19:55:43Z"
        }
      ]
    },
    {
      "number": 336,
      "id": "I_kwDOBtBsGM5DI-V4",
      "title": "Input limits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/336",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The document currently doesn't note input limits for `hash_to_field`, and I'm wondering if we should consider adding these limits. HPKE [has similar limits for some of its functions](https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#kdf-input-length). \r\n\r\nThe limit is ultimately defined by the underlying hash function, which, for `hash_to_field` built on `expand_message_xmd` is an MD-style hash with an explicit limit, but for `hash_to_field` built on `expand_message_xof` is a XOF-based construction [with no explicit limit](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf#page=31). (FIPS 202 says that the message is a \"bit string of any length that is the input to a SHA-3 function.\")\r\n\r\nIn practice, hitting these limits is unlikely to happen, since SHA-256 and SHA-512 (and SHA-384) have limits of 2^61 and 2^125 (2^125), respectively. However, I wonder if we should note this for `expand_message_xmd`. \r\n\r\nHere's the definition of `expand_message_xmd`:\r\n\r\n~~~\r\n1.  ell = ceil(len_in_bytes / b_in_bytes)\r\n2.  ABORT if ell > 255 or len_in_bytes > 65535 or len(DST) > 255\r\n3.  DST_prime = DST || I2OSP(len(DST), 1)\r\n4.  Z_pad = I2OSP(0, s_in_bytes)\r\n5.  l_i_b_str = I2OSP(len_in_bytes, 2)\r\n6.  msg_prime = Z_pad || msg || l_i_b_str || I2OSP(0, 1) || DST_prime\r\n7.  b_0 = H(msg_prime)\r\n... snip ....\r\n~~~\r\n\r\nBased on this, the length of the input to `H`, denoted `msg_prime`, is computed as:\r\n\r\n~~~\r\nlen(msg_prime) = r_in_bytes (* r_in_bytes *) + 2 (* l_i_b_str *) + 1 (* I2OSP(0, 1) *) + 1 (* I2OSP(len(DST), 1) *) + len(DST) + len(msg)\r\n~~~ \r\n\r\nBased on the limit of `H`, denoted `H_limit`, we could say that the limit of inputs to expand_message_xmd for suites that use this limit is:\r\n\r\n~~~\r\nH_limit - r_in_bytes + 4 + len(DST) + len(msg)\r\n~~~\r\n\r\n@kwantam, what do you think?",
      "createdAt": "2022-02-07T19:49:00Z",
      "updatedAt": "2022-03-05T16:46:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the bounds are enormous, maybe it makes sense just to put in a quick reminder that one should respect the input size limit, but not go so far as to give an expression for it. Or maybe not. Not clear to me...",
          "createdAt": "2022-02-18T04:24:24Z",
          "updatedAt": "2022-02-18T04:24:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, at a minimum, noting the limit exists seems necessary. We can ask the list to see if folks think an expression quantifying it would be additionally helpful (or harmful).",
          "createdAt": "2022-03-05T16:46:22Z",
          "updatedAt": "2022-03-05T16:46:22Z"
        }
      ]
    },
    {
      "number": 343,
      "id": "I_kwDOBtBsGM5GHO-1",
      "title": "Test vectors for `hash_to_scalar`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/343",
      "state": "OPEN",
      "author": "daxpedda",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Technically `hash_to_scalar` is not defined, but specified as an \"alias\" of `hash_to_field`. Would it still be in scope to provide test vectors for it?\r\n\r\nSee #301.",
      "createdAt": "2022-03-22T05:55:10Z",
      "updatedAt": "2023-02-24T22:27:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kayabaNerve",
          "authorAssociation": "NONE",
          "body": "This would be greatly appreciated to ensure implementations are complaint. While EXPAND can be tested on its own, the reduction cannot be.",
          "createdAt": "2023-01-01T07:06:34Z",
          "updatedAt": "2023-01-01T07:06:34Z"
        },
        {
          "author": "paulmillr",
          "authorAssociation": "NONE",
          "body": "Keep in mind `hash_to_field` produces numbers is in range [0, p-1].\r\n\r\nScalars, however, most of the time should be [1, p-1], that is, without 0.\r\n\r\nThere are 2 ways to handle this:\r\n\r\n1. Set `p=p-1`, generate field element, increment the result by `+1`\r\n2. Rejection sampling, which is commonly non-constant-time, and messy\r\n\r\nI think the spec should at least mention it.",
          "createdAt": "2023-02-23T21:35:35Z",
          "updatedAt": "2023-02-23T21:35:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "For a field of reasonable size, the probability that the result is 0 is negligible. (For example, if p is 128 bits, the probability that you hash to 0 is the same as the probability that you guess someone's AES key on the first try. *This will never happen.*)\r\n\r\nReducing mod `p-1` will, in most instances, require implementing specialized arithmetic mod `p-1`, which could easily be a large amount of extra code that will need to be audited, maintained, etc. (No production implementation uses generic multi-precision arithmetic. For one, it's almost impossible to make it constant time.)\r\n\r\nIn sum: in almost all cases, it's much more dangerous to try and prevent hashing to zero than it is to assume that it will never happen. Because it will never happen!",
          "createdAt": "2023-02-24T03:03:04Z",
          "updatedAt": "2023-02-24T03:06:21Z"
        },
        {
          "author": "paulmillr",
          "authorAssociation": "NONE",
          "body": "@kwantam fault attacks do happen. So it's not negligible, I would think it's pretty likely.",
          "createdAt": "2023-02-24T10:57:43Z",
          "updatedAt": "2023-02-24T10:57:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm curious about this security model. You're saying that fault attacks *specifically designed to induce a zero output* are a serious threat? That's the only kind of fault attack this would prevent against.\r\n\r\n(EDIT: to be clear, I do not find this argument persuasive in the least, absent some kind of evidence that zero-inducing fault attacks are a thing.)",
          "createdAt": "2023-02-24T14:01:12Z",
          "updatedAt": "2023-02-24T14:02:01Z"
        },
        {
          "author": "paulmillr",
          "authorAssociation": "NONE",
          "body": "> You're saying that fault attacks specifically designed to induce a zero output are a serious threat\r\n\r\nNot serious, but a threat.\r\n\r\nI'm simply saying it needs to be kept in mind that this could happen, meaning at least CT rejection sampling should be put in place. Not that it would happen. The chance of a fault attack is much higher than selecting 1 element from all group elements",
          "createdAt": "2023-02-24T18:24:05Z",
          "updatedAt": "2023-02-24T18:27:42Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not saying fault attacks don't matter. But fault attacks can do *lots* of different things, and I strongly suspect that among all the fault attacks one has to worry about, fault attacks that are specifically designed to induce zero outputs are a tiny fraction, if they even exist.\r\n\r\nDepending on your threat model, you might need to defend against fault attacks or you might not. If you aren't worried about fault attacks, preventing zero outputs from hash_to_field isn't necessary. If you are worried about fault attacks, preventing zero outputs from hash_to_field isn't sufficient.\r\n\r\nThere is no case where \"prevent zero output from hash_to_field\" defends against a meaningful threat. But it *does* add complexity. The cure is worse than the disease.\r\n\r\n---\r\n\r\nBy the way: if \"force hash_to_field output to be zero\" is a meaningful fault attack, then the idea of hashing to the range 0..p-1 and then adding 1 is probably not helping because the attacker has just caused you generate the value 1, which is just as bad in most cases.",
          "createdAt": "2023-02-24T22:27:02Z",
          "updatedAt": "2023-02-24T22:27:02Z"
        }
      ]
    },
    {
      "number": 344,
      "id": "I_kwDOBtBsGM5Ijpnq",
      "title": "Generic monty to twisted edw map issue",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/344",
      "state": "CLOSED",
      "author": "malteafg",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We believe that there is an error in the following section:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/main/draft-irtf-cfrg-hash-to-curve.md#generic-montgomery-to-twisted-edwards-map-appx-rational-map-edw\r\nInstead of v=s/t, we think it should be v=(s/t)*sqrt(-486664), as suggested by https://en.wikipedia.org/wiki/EdDSA#Ed25519. In our code we have generated points on Curve25519, and when mapping them to Ed25519, we get Ed25519 points when using v=(s/t)*sqrt(-486664), and we do not get Ed25519 points when using v=s/t. In our implementation of edw_to_monty_generic we must multiply v by sqrt(-486664) at last to get an Ed25519 point.\r\nAlso, the name of the algorithm edw_to_monty_generic is inconsistent with the parameter and return type, and should be monty_to_edw_generic instead, in accordance with the header.",
      "createdAt": "2022-04-27T12:46:38Z",
      "updatedAt": "2022-04-27T15:29:38Z",
      "closedAt": "2022-04-27T15:29:38Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your report! :+1:\r\n\r\nWith regard to naming: you're totally right, it should be `monty_to_edw_generic`. We'll be sure to fix this.\r\n\r\nWith regard to the map: please see the text of [Section 6.8.1](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-6.8.1).\r\n\r\nThe upshot is: there are many different valid mappings from an Edwards curve to the birationally equivalent Montgomery curve. Sometimes, as in Curve25519, that mapping is given explicitly in the standard, in which case the standardized mapping should be used. For Curve25519, this is the mapping you're referring to, which includes the sqrt(-486664) factor.\r\n\r\nOther times, there is no explicit mapping given in a standard, and for these cases Appendix D.1 gives a generic construction. The reason that Section 6.8.1 explicitly states that the standardized mapping should be used when available is that the construction in Appendix D.1 is not guaranteed to agree with that standardized mapping. As you point out, this is the case with Curve25519.\r\n\r\nTo be clear: it is not possible for us to give a construction in Appendix D.1 that will agree with all possible standards. What's provided in Appendix D.1 is correct modulo the naming issue, which we'll fix---thanks again for pointing it out!",
          "createdAt": "2022-04-27T14:58:42Z",
          "updatedAt": "2022-04-27T14:58:42Z"
        }
      ]
    },
    {
      "number": 347,
      "id": "I_kwDOBtBsGM5L-lNM",
      "title": "Generalized fast cofactor clearing for all curves with endomorphisms",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/347",
      "state": "OPEN",
      "author": "mratsim",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/52\r\n\r\nPaper\r\n\r\n- Co-factor clearing and subgroup membership testing on pairing-friendly curves\\\r\n  Youssef El Housni, Aurore Guillevic, and Thomas Piellard\\\r\n  https://eprint.iacr.org/2022/352.pdf\r\n\r\nextends fast cofactor clearing to all pairing-friendly curves including BN and BW curves that are becoming popular in zero-knowledge protocols. \r\n",
      "createdAt": "2022-06-17T07:51:23Z",
      "updatedAt": "2022-06-17T07:51:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 348,
      "id": "I_kwDOBtBsGM5O2Gm-",
      "title": "python support and minimum working example in python?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/348",
      "state": "CLOSED",
      "author": "davejakenic",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nwould you be willing to give assistance in utilizing your module in python?\r\n\r\nParticularly, I wish to have a hash function H that maps a byte string to a point on an elliptic curve. A minimum working example in python would be nice.\r\n\r\nAnd the particular curve matters of course, since obviously the hash cannot be linearly dependent on the generator.\r\nHow about brainpoolP256r1 ?\r\n\r\nCan you give a list of all the curves for which your hash can be used?\r\n\r\nSorry, I am a practitioner. I am sure you wrote wonderful papers.",
      "createdAt": "2022-07-29T23:48:24Z",
      "updatedAt": "2022-07-30T15:20:14Z",
      "closedAt": "2022-07-30T15:20:14Z",
      "comments": [
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The parts that don't involve elliptic curve cryptography are in Python, like https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/main/poc/hash_to_field.py\r\n\r\nThose that involve ECC are in SageMath like https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/main/poc/svdw_generic.sage which is basically Python with extras.\r\n\r\nFor full Python PoC, you need to look into external repos like:\r\n\r\n- https://github.com/kwantam/bls_sigs_ref/tree/master/python-impl\r\n- https://github.com/ethereum/py_ecc/tree/master/py_ecc/optimized_bls12_381\r\n\r\nbut those need to reimplement field and elliptic curve arithmetic from scratch.\r\n\r\n> brainpoolP256r1\r\n\r\nI don't think many are interested in that curve but you can always create a suite based on Generic SVDW.\r\n\r\n> Can you give a list of all the curves for which your hash can be used?\r\n\r\nThe generic fallback is SVDW",
          "createdAt": "2022-07-30T11:12:09Z",
          "updatedAt": "2022-07-30T11:12:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that brainpoolP256r1 can be used with the optimized SSWU construction, since its j-invariant is nonzero. That would give better performance than SVDW. See section 6.6.2 of the hash-to-curve document for more information on this mapping.\r\n\r\nIf you're happy using Sage, not just Python, then you can pretty easily implement such a mapping using the OptimizedSSWU implementation in poc/sswu_optimized.sage. That would be as simple as\r\n\r\n```sage\r\n# parameters for brainpoolP256r1 per https://neuromancer.sk/std/brainpool/brainpoolP256r1\r\np = 0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377\r\na = 0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9\r\nb = 0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6\r\n\r\nF = GF(p)\r\nmap = OptimizedSSWU(F, a, b)\r\n```\r\n\r\nTo turn this into a proper hash-to-curve suite, you can use the BasicH2CSuite implementation in poc/h2c_suite.sage. For examples of use, see poc/suite_p256.sage (and others).\r\n\r\nAs @mratsim says, if you want to use Python you will first need to implement your curve operations in Python. I'm not sure why you want to use brainpoolP256r1, but in any case I'm not aware of any Python implementations that I can recommend as well tested, etc.\r\n\r\nGood luck!",
          "createdAt": "2022-07-30T15:19:16Z",
          "updatedAt": "2022-07-30T15:19:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this issue as answered. Please feel free to reopen if there are other questions we can help with.",
          "createdAt": "2022-07-30T15:20:14Z",
          "updatedAt": "2022-07-30T15:20:14Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "I_kwDOBtBsGM5QPAeC",
      "title": "Q: expand_message output len limit",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/349",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello everyone! Sorry for the naive question. I'm trying to understand the reasons behind the upper limit of `expand_message` output length. Are there security reasons for it? or it is only for efficiency??\r\n\r\nFor context, we are working on a [bbs-signatures draft](https://identity.foundation/bbs-signature/draft-looker-cfrg-bbs-signatures.html), and this limit has caused an [issue](https://github.com/decentralized-identity/bbs-signature/issues/212) that we are currently discussing.\r\n\r\nAny hints will be greatly appreciated.",
      "createdAt": "2022-08-22T09:37:30Z",
      "updatedAt": "2022-08-23T19:42:32Z",
      "closedAt": "2022-08-23T19:42:32Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Mechanically, the reason for the limit is that we encode `len_in_bytes` in two bytes as part of the input to the hash function, which limits the representable value to 2^16 - 1. (But I'm sure you noticed this already! \ud83d\ude04)\r\n\r\nAs to why only two bytes: that's already far beyond what we need, so we didn't allocate more space in the input for it.\r\n\r\nSecondarily: if you're using expand_message_xmd, the counter in the expand loop (steps 9 and 10) is only 1 byte, which will also limit reachable output length. No trouble of this type if you're using expand_message_xof.\r\n\r\nIf you want to support longer outputs, one easy possibility is to allocate more bytes to the len_in_bytes encoding. For example, replacing step 3 of expand_message_xof with\r\n\r\n    3. msg_prime = msg || I2OSP(len_in_bytes, 8) || DST_prime\r\n\r\nwould support messages up to 2^64-1 in length.\r\n\r\nexpand_message_xmd would take more surgery---at least, increasing the bit width of the encoding of `i` on lines 8 and 10. I *think* that would suffice and would be secure, but I haven't thought about it enough to be sure.",
          "createdAt": "2022-08-22T14:53:50Z",
          "updatedAt": "2022-08-22T14:54:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "As an alternative that would let you treat expand_message (either variant) as a black-box, you could chain together a bunch of expand_message invocations. Something like this probably works (but do some more analysis to be sure!):\r\n\r\n    # assume total_output_length, msg, and DST are defined in the obvious way\r\n    numexp = ceil(total_output_length / 65284)\r\n    ABORT if numexp >= 2^32\r\n    DST_next = I2OSP(0, 4) || DST\r\n    for j in (1, ..., numexp):\r\n        tmp = expand_message(msg, DST_c, 65535)\r\n        out_j = substr(tmp, 0, 65284)\r\n        DST_next = I2OSP(j, 4) || substr(tmp, 65284, 251)\r\n    result = out_1 || ... || out_numexp\r\n    return substr(result, 0, total_output_length)\r\n\r\nThis lets you produce nearly 2^48 bytes.",
          "createdAt": "2022-08-22T15:38:49Z",
          "updatedAt": "2022-08-22T15:38:49Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "NONE",
          "body": "Great! Thank you! That\u2019s a very interesting solution. Thanks for taking the time for this.\r\n\r\nClosing since my question was thoroughly answered! Thanks again!",
          "createdAt": "2022-08-23T19:42:30Z",
          "updatedAt": "2022-08-23T19:42:30Z"
        }
      ]
    },
    {
      "number": 351,
      "id": "I_kwDOBtBsGM5aVoS_",
      "title": "Test suite for BLS12-377",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/351",
      "state": "OPEN",
      "author": "mmagician",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While helping with h2c for BLS12-377 in arkworks, I wanted to test the results against some vectors. AFAIK, there isn't any test suite published for BLS12-377 yet?\r\n\r\nIs there any interest in adding a test suite for another curve from the same family to the draft?\r\nRight now I have a fork with the new suites [here](https://github.com/mmagician/draft-irtf-cfrg-hash-to-curve/tree/bls12-377) generating the tests using the isogenies found by @drskalman, and I'll happily make a PR to include these if desirable.\r\n\r\nArkworks PR for reference: https://github.com/arkworks-rs/curves/pull/138",
      "createdAt": "2023-01-01T14:53:32Z",
      "updatedAt": "2023-02-10T14:06:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 352,
      "id": "I_kwDOBtBsGM5eGeiA",
      "title": "Should empty DST values be rejected?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/352",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/264 added some text to 3.1:\r\n\r\n> Tags MUST have nonzero length. A minimum length of 16 bytes is RECOMMENDED to reduce the chance of collisions with other applications.\r\n\r\nHowever, it did not update any of the actual procedures, notably `expand_message_xmd`, leaving the text inconsistent. Was the intention that implementations reject empty DST values, or not? If yes, the actual procedures should be updated. If no, I'm not sure what that text is meant to prescribe... just instructions for callers but the underlying function tolerates zero length?",
      "createdAt": "2023-02-09T23:18:22Z",
      "updatedAt": "2023-08-15T02:30:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an oversight. I suppose one could assume the pseudocode implicitly rejects zero-length tags, but it doesn't hurt to add that to be explicit. We should do this.",
          "createdAt": "2023-02-10T14:00:17Z",
          "updatedAt": "2023-02-10T14:00:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed! Thanks @davidben for spotting this.",
          "createdAt": "2023-02-10T16:15:35Z",
          "updatedAt": "2023-02-10T16:15:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "Whoops, looks like this might have slipped through.",
          "createdAt": "2023-08-15T00:45:22Z",
          "updatedAt": "2023-08-15T00:45:22Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Argh. I'm very sorry about this.",
          "createdAt": "2023-08-15T02:30:23Z",
          "updatedAt": "2023-08-15T02:30:23Z"
        }
      ]
    },
    {
      "number": 353,
      "id": "I_kwDOBtBsGM5eLMPS",
      "title": "Clarification in 6.6.3: if no isogeny exists, this method does not work",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/353",
      "state": "OPEN",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I got a note from someone using the draft that they thought the wording in Section 6.6.3 could be clearer about the fact that the curve E' isogenous to E may not exist. Maybe one clarifying sentence at the end of the 3rd paragraph, roughly:\r\n\r\n    Note that it may not be possible to find a curve E' meeting these requirements, in which case this method does not apply.\r\n\r\nPer @chris-wood we should be able to make this change (right?)\r\n\r\n(note: stashing this conversation as an issue so that we don't lose track of it!)",
      "createdAt": "2023-02-10T16:25:24Z",
      "updatedAt": "2023-02-10T16:25:48Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMzE0MjIx",
      "title": "Expand introduction and add background material.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/18",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " - Expand out the introduction to include discussion of encoding\r\n   functions and their application to creating random oracles\r\n   on curves.\r\n - Add some background information on elliptic curve encoding\r\n   methods, with some theoretical background.\r\n\r\n----\r\n\r\nI appreciate a lot of this might be a little off-tone for the document. But I thought it was important to get it down. I would be happy to push the theoretical parts to later/the appendix.\r\n\r\nWith this in place, Chapter 3 could be even more informative. For example:\r\n\r\nUse case: Encoding bitstring to curve point (for use as group generator):\r\n`m -> H(m) * G`\r\n\r\nUse case: Hashing to curve point (for use in CDH/DDH-like protocol):\r\n`m -> F(H(m))`, given additional proof and for F in {Icart, SWU, etc} by parameters.\r\n (This is the existing table, maybe add some info for supersingular and x-only scalar mult).\r\n\r\nUse case: Hashing to curve point (default, all, gives random oracle):\r\n`m -> F(H1(m)) + F(H2(m))` for F in {...} \r\n\r\nand so on. So then this becomes a useful lookup from application to function.\r\n\r\nI'll keep writing some stuff for review, but happy to take any comments in the meantime.\r\n",
      "createdAt": "2018-04-12T20:17:36Z",
      "updatedAt": "2018-04-12T22:14:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "0fcf998b873399dfdd0474eb264f0c4a3ec8fdca",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "changes",
      "headRefOid": "793d6cf4bbfb50ef0189204ef347abe5ef4bd200",
      "closedAt": "2018-04-12T22:11:15Z",
      "mergedAt": "2018-04-12T22:11:15Z",
      "mergedBy": "samscott89",
      "mergeCommit": {
        "oid": "a492404a93965af4d67fcb654a6a3216af968cb1"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Agreed that this is definitely useful text. Thanks for writing it down!",
          "createdAt": "2018-04-12T20:55:19Z",
          "updatedAt": "2018-04-12T20:55:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Feel free to merge, since I added you as a contributor. I wonder if we should further split this document into two parts: one describing encoding/serialization functions, and the other describing hashing functions. What do you think?",
          "createdAt": "2018-04-12T20:56:45Z",
          "updatedAt": "2018-04-12T20:56:45Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "> I wonder if we should further split this document into two parts: one describing encoding/serialization functions, and the other describing hashing functions. What do you think?\r\n\r\nI think that might be the clearest way to go about it. I was trying to keep to the original structure in an attempt to make my changes purely additive, but it might be worth breaking in up a bit more.\r\n\r\nOk, I'll merge this for now, and look at playing with the structure a little.",
          "createdAt": "2018-04-12T22:07:39Z",
          "updatedAt": "2018-04-12T22:07:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Sounds great, thanks!",
          "createdAt": "2018-04-12T22:14:13Z",
          "updatedAt": "2018-04-12T22:14:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg4MTcy",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:49:33Z",
          "updatedAt": "2018-04-12T20:49:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-04-12T20:49:33Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg4Njc1",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:50:53Z",
          "updatedAt": "2018-04-12T20:50:53Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "s/outputting/which outputs",
              "createdAt": "2018-04-12T20:50:53Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg5MzI1",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:52:41Z",
          "updatedAt": "2018-04-12T20:52:41Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Should we mention and reference Hasse's Theorem?",
              "createdAt": "2018-04-12T20:52:41Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg5NzQ4",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:53:50Z",
          "updatedAt": "2018-04-12T20:53:50Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "s/an EC/a curve",
              "createdAt": "2018-04-12T20:53:50Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNjE2NjIx",
      "title": "Re-structuring effort.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/19",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Proposed new structure changes the emphasis to \"mapping-to-curve\" algorithms. Has a very brief background chapter introducing encoding/serialization/hash-to-curve(aka random oracles).\r\nTechnical details/related work pushed to appendix for relevant info.",
      "createdAt": "2018-04-18T22:10:25Z",
      "updatedAt": "2018-04-29T21:25:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a492404a93965af4d67fcb654a6a3216af968cb1",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "changes",
      "headRefOid": "fa253299371aecbe4b980e30a51838c1dd2cb2b9",
      "closedAt": "2018-04-29T21:25:11Z",
      "mergedAt": "2018-04-29T21:25:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "88b8084365e8126c0d0efac9ec622c59b8394df1"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Thought I'd get this proposed structure down early so we can iterate on the content quicker. Language needs improvements, and I think it's worth clarifying that generally you need an encoding mapping to elements `mod #E(GF(p))`, which is often prime q, with  `p = rq + 1`.",
          "createdAt": "2018-04-18T22:13:21Z",
          "updatedAt": "2018-04-18T22:13:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Feel free to merge. Or, if you prefer, we can add the table first. I'd be happy to add that text to lessen your load. Let me know your preference.",
          "createdAt": "2018-04-23T23:49:12Z",
          "updatedAt": "2018-04-23T23:49:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk0NjEx",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:09:35Z",
          "updatedAt": "2018-04-19T22:09:36Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Isn't the interface: {0,1}^* \\to E, rather than GF(p) \\to E?",
              "createdAt": "2018-04-19T22:09:36Z",
              "updatedAt": "2018-04-19T22:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk1ODEy",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:14:47Z",
          "updatedAt": "2018-04-19T22:14:47Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Typo in \"performance\"",
              "createdAt": "2018-04-19T22:14:47Z",
              "updatedAt": "2018-04-19T22:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk2NjY0",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:18:38Z",
          "updatedAt": "2018-04-19T22:18:38Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "It's not clear to me whether or not we will have separate sections on encoding and hashing algorithms, or if we will have one section for all algorithms, with each variant annotated with its properties. Is it the latter? If so, we should consider adding a properties column to our recommendation table. Or, perhaps we should make two tables: one for encoding, and one for hashing. Our recommendations may vary based on the application. @samscott89, what do you think?",
              "createdAt": "2018-04-19T22:18:38Z",
              "updatedAt": "2018-04-19T22:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk2OTU5",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:19:49Z",
          "updatedAt": "2018-04-19T22:19:49Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Can (or should?) we merge this with the try-and-increment section below? The content overlap is substantial.",
              "createdAt": "2018-04-19T22:19:49Z",
              "updatedAt": "2018-04-19T22:19:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MTgwNjMz",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-21T18:59:53Z",
          "updatedAt": "2018-04-21T18:59:53Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I was thinking of adding tables to the recommendations along these lines:\r\n\r\nThe following table lists algorithms recommended by use-case:\r\n\r\n| Application       | Requirement   | Additional Details\r\n|-------------------|---------------|---------|\r\n| SPEKE {{Jablon96}}| Naive         | y = H(x)*G |\r\n| PAKE  {{BMP00}}   | Random Oracle |   -    | \r\n| BLS {{BLS01}}     | RO            |    -   |\r\n| IBE {{BF01}}      | RO | Supersingular, pairing-friendly curve |\r\n\r\nTo find the suitable algorithm, lookup the requirement from above, with \r\nthe chosen curve in the below:\r\n\r\n\r\n| Curve  | Inj. Encoding | RO |\r\n|--------|---------------|------|\r\n| P-256 | SWU {{simple-swu}} | FFSTV(SWU)\r\n| P-384 | Icart {{icart}} | FFSTV(Icart)\r\n| Curve25519 | Elligator2 {{elligator2}} | ...\r\n| Curve448 | Elligator2 {{elligator2}} | ...\r\n\r\n----",
              "createdAt": "2018-04-21T18:59:53Z",
              "updatedAt": "2018-04-21T19:05:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MTgwNzIy",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-21T19:04:28Z",
          "updatedAt": "2018-04-21T19:04:28Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Which will hopefully be more obviously useful when expanding the list of applications to tease out the subtle requirements (functional and security). For example, I think we can show that the x-only Montgomery mechanism (which gives you an injective encoding) is useful for many applications where you need a PRF-like thing (potentially relevant to @grittygrease in fact).",
              "createdAt": "2018-04-21T19:04:28Z",
              "updatedAt": "2018-04-21T19:04:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MTgwODMw",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-21T19:09:00Z",
          "updatedAt": "2018-04-21T19:09:00Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "As for the structure of encoding & hashing vs all algorithms. I don't think there will be a huge difference, since AFAICT all mechanism to do RO properly are generic methods using some existing injective encoding. So I would present all encoding mechanism and mention their specific properties, and then list the methods to achieve random oracles by combining them.",
              "createdAt": "2018-04-21T19:09:00Z",
              "updatedAt": "2018-04-21T19:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0NTkzNDM2",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-23T23:48:35Z",
          "updatedAt": "2018-04-23T23:48:35Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "+1 to all of the above. :-)\r\n",
              "createdAt": "2018-04-23T23:48:35Z",
              "updatedAt": "2018-04-23T23:48:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NDQ5NTEy",
      "title": "Hashing to pairing-friendly curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/20",
      "state": "CLOSED",
      "author": "Ela-BLee",
      "authorAssociation": "NONE",
      "assignees": [
        "samscott89"
      ],
      "labels": [],
      "body": "Added a section on hashing onto BN curves, which are pairing-friendly.\r\nIncludes a brief introduction to BN curves, the FT-encoding function, and steps for the overall hash function.",
      "createdAt": "2018-05-11T12:25:10Z",
      "updatedAt": "2019-03-01T16:18:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "2fee72ad1787b65c988382ffa0fd61fbe777ba95",
      "headRepository": "Ela-BLee/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "changes",
      "headRefOid": "edc1d037df73ebbc6aeab2be990016743ff85365",
      "closedAt": "2019-03-01T16:18:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "wrt the Legendre symbol stuff. Might be simpler to just always replace it by the exponentiation computation? ",
          "createdAt": "2018-05-25T19:42:11Z",
          "updatedAt": "2018-05-25T19:42:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 that works for me. @Ela-BLee, can you please try to replace the Legendre symbol with the explicit formula?",
          "createdAt": "2018-05-25T20:13:52Z",
          "updatedAt": "2018-05-25T20:13:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@Ela-BLee will you be able to update this PR by the end of next week?",
          "createdAt": "2018-06-13T23:13:27Z",
          "updatedAt": "2018-06-13T23:13:27Z"
        },
        {
          "author": "Ela-BLee",
          "authorAssociation": "NONE",
          "body": "Updated - apologies for the delay",
          "createdAt": "2018-06-21T20:30:34Z",
          "updatedAt": "2018-06-21T20:30:34Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you mind also adding a ciphersuite in the ciphersuites section for a common curve, say bn256?",
          "createdAt": "2018-10-22T21:22:03Z",
          "updatedAt": "2018-10-22T21:22:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@Ela-BLee this extended and updated in #86. Thank you for your changes!",
          "createdAt": "2019-03-01T16:18:04Z",
          "updatedAt": "2019-03-01T16:18:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NDMwODQw",
          "commit": {
            "abbreviatedOid": "5c755fe"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T13:22:59Z",
          "updatedAt": "2018-05-11T13:22:59Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "At the moment we've pushed a lot of the more technical background to the end. [This](https://github.com/chris-wood/draft-sullivan-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#supersingular-curves) would probably be the appropriate section for that.\r\n\r\nThat section might get pushed up later, but for now it seems like a good place to keep it all together.",
              "createdAt": "2018-05-11T13:22:59Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NDY0NDky",
          "commit": {
            "abbreviatedOid": "5c755fe"
          },
          "author": "Ela-BLee",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T14:53:37Z",
          "updatedAt": "2018-05-11T14:53:37Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Thanks Sam - missed the section move when resolving the merge conflict.\r\nFixing now.",
              "createdAt": "2018-05-11T14:53:37Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NTM3Mzg4",
          "commit": {
            "abbreviatedOid": "90bcf5c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T18:33:39Z",
          "updatedAt": "2018-05-11T18:33:39Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "If we're using Xp() for the Legendre symbol, which is fine by me, we should re-write the other algorithms to make use of this notation.",
              "createdAt": "2018-05-11T18:33:39Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NTM3ODkw",
          "commit": {
            "abbreviatedOid": "90bcf5c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T18:35:13Z",
          "updatedAt": "2018-05-11T18:35:13Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "We should re-write this conditional selection to make it constant time, too, right?",
              "createdAt": "2018-05-11T18:35:13Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMTg5MjM5",
          "commit": {
            "abbreviatedOid": "a203fa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The latest changes look good to me. @samscott89 what do you think about unifying the Legendre symbol notation?",
          "createdAt": "2018-05-17T19:46:06Z",
          "updatedAt": "2018-05-17T19:46:58Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Missing comma between \"1 + b\" and \"b nonzero\"",
              "createdAt": "2018-05-17T19:46:06Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDU3OTYy",
          "commit": {
            "abbreviatedOid": "961e1a1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The new encoding scheme is great. We should make sure to implement it in hacspec. Is that something you could do? The actual hashing routine is not new, and we have text for it in the draft. Can you simply cite that section?",
          "createdAt": "2018-06-22T03:36:26Z",
          "updatedAt": "2018-06-22T03:47:38Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "This should be rewritten as map2curve_BN(t), as this is a generic encoding mechanism for BN curves.",
              "createdAt": "2018-06-22T03:36:26Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 212,
              "body": "Please align this with the text above.",
              "createdAt": "2018-06-22T03:36:39Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 207,
              "body": "Please add a space after \"-\":\r\n```\r\ns1 = (f(x1) ^ ((p - 1) / 2)) \r\n```\r\nAnd please do the same for the following lines.\r\n",
              "createdAt": "2018-06-22T03:37:04Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 228,
              "body": "This RO construction is not specific to BN curves, and in fact is already described in the Random Oracles section. I think we should remove it and keep only the BN encoding function.",
              "createdAt": "2018-06-22T03:37:56Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 141,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-06-22T03:44:12Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMzY5NTY4",
          "commit": {
            "abbreviatedOid": "eb50b45"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for these changes!",
          "createdAt": "2018-06-22T23:08:03Z",
          "updatedAt": "2018-06-22T23:11:19Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "Extra space between where and H1",
              "createdAt": "2018-06-22T23:08:03Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTA2MjQx",
          "commit": {
            "abbreviatedOid": "46872d1"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-22T20:57:28Z",
          "updatedAt": "2018-10-22T21:05:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think this is a latent conflict from when the names were re-ordered to be alphabetic.",
              "createdAt": "2018-10-22T20:57:28Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 118,
              "body": "This should ideally be addressed, something like:\r\n```\r\n8.  x = x3\r\n9.  x = CMOV(x2 ,x, 2)\r\n10. x = CMOV(x1, x, s1)\r\n```",
              "createdAt": "2018-10-22T21:00:34Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 205,
              "body": "```suggestion\r\nF(H2(m)) as explained in {{#ffstv}}, which will be indifferentiable from a random oracle.\r\n```",
              "createdAt": "2018-10-22T21:05:11Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTQzMjc4",
          "commit": {
            "abbreviatedOid": "43143b4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-22T22:55:06Z",
          "updatedAt": "2018-10-22T22:58:40Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "I think this section was written already -- can you please check and remove if so?",
              "createdAt": "2018-10-22T22:55:06Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 195,
              "body": "In #68, we removed (mod p) from each step. Should we do the same here?",
              "createdAt": "2018-10-22T22:55:37Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 185,
              "body": "Can we use alpha for consistency? And also include HashToBase to map it to `t`?",
              "createdAt": "2018-10-22T22:58:14Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NDcwMTMw",
      "title": "Start adding recommendations table.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/21",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WIP on new recommendations table.\r\n\r\nCan use this to start filling out with any applications we want to cover?",
      "createdAt": "2018-05-11T13:51:35Z",
      "updatedAt": "2019-01-25T17:03:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "34f43482de044ddfba5ebdde0f3a8a3cc89cb873",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "changes",
      "headRefOid": "8f82b214b548665704444d5c6972cf9642fd3467",
      "closedAt": "2018-05-14T22:46:21Z",
      "mergedAt": "2018-05-14T22:46:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b662ba0f2432be946bb1c0e9f42f72a4c8393de2"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe to add:\r\nCONIKS [(PDF)](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-melara.pdf).\r\n\r\nUses H(m)^k as VRF with H modelled as random oracle. But probably okay as inj encoding.",
          "createdAt": "2018-05-11T14:11:43Z",
          "updatedAt": "2018-05-11T14:11:43Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Multipurpose identity-based signcryption [(PDF)](https://iacr.org/archive/crypto2003/27290382/27290382.pdf) by Xavier Boyen.\r\nMuch like all the identity-based stuff, random oracle onto pairing-friendly curve.",
          "createdAt": "2018-05-11T14:17:41Z",
          "updatedAt": "2018-05-11T14:17:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Both recommendations are good. The more, the merrier. ",
          "createdAt": "2018-05-11T18:31:15Z",
          "updatedAt": "2018-05-11T18:31:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NTM2NDM2",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T18:30:39Z",
          "updatedAt": "2018-05-11T18:30:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Is Naive supposed to be the same as injective encoding?",
              "createdAt": "2018-05-11T18:30:39Z",
              "updatedAt": "2018-05-11T18:30:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDE5ODg4",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T21:38:31Z",
          "updatedAt": "2018-05-14T21:38:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@samscott89 Looks good pending this comment. Feel free to merge when ACK'd!",
              "createdAt": "2018-05-14T21:38:31Z",
              "updatedAt": "2018-05-14T21:38:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM1NTgw",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T22:43:05Z",
          "updatedAt": "2018-05-14T22:43:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Not quite. `H(x)*G` is the naive method of hashing to the curve (technically a surjective encoding), with the significant downside that the discrete logarithm of the point (with base G) is known. Which breaks many protocols but is okay for SPEKE.",
              "createdAt": "2018-05-14T22:43:05Z",
              "updatedAt": "2018-05-14T22:44:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM1ODM3",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T22:44:25Z",
          "updatedAt": "2018-05-14T22:44:25Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Although my assumption was that this would be the most performant, which may not even be true, in which case it doesn't need to be included at all. Need to investigate when doing an overview of the approximate runtimes.",
              "createdAt": "2018-05-14T22:44:25Z",
              "updatedAt": "2018-05-14T22:44:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM2MTcy",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T22:46:10Z",
          "updatedAt": "2018-05-14T22:46:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Oops. I failed to see the Injective Encoding application at the bottom of this table, and forgot about the entire section at the end of the document. I presumed this was a typo. Thanks for clearing it up! ",
              "createdAt": "2018-05-14T22:46:10Z",
              "updatedAt": "2018-05-14T22:46:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM2MTk3",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T22:46:15Z",
          "updatedAt": "2018-05-14T22:46:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5ODQ2MDQ5",
      "title": "Add first draft of generic RO construction, and separate encoding and hashing functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/24",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a first cut at #23. It doesn't go into details regarding what is a suitable encoding for the construction, although all those considered (except Elligator2) were shown to work. (@samscott89, we should do the math and figure out if Elligator2 works.)",
      "createdAt": "2018-05-23T03:17:37Z",
      "updatedAt": "2022-02-18T16:41:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "b662ba0f2432be946bb1c0e9f42f72a4c8393de2",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/ro",
      "headRefOid": "20e524b862dbb357ce32dcc40c9934a491ca7126",
      "closedAt": "2018-05-25T23:32:43Z",
      "mergedAt": "2018-05-25T23:32:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f9d3bca1c9d6dd83c5597204b9b60732412afd1e"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89, what do you think?",
          "createdAt": "2018-05-25T18:20:16Z",
          "updatedAt": "2018-05-25T18:20:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDg3Nzcw",
          "commit": {
            "abbreviatedOid": "b2a1e72"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like how this is all coming together. Looking good.\r\n\r\nMy only comments are more for follow on things to do, as opposed to PR-specific changes:\r\n\r\n - Section 9 (security recommendations) is a bit redundant now, since the whole piece is shaped around that comment.\r\n - We should probably cite Brier et al. https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13 as the primary reference for the general construction (they proved it for Icart function only though). And also can use the other generalized construction H(m) = f(h1(m)) + h2(m)G which you can show holds for Elligator \r\n - Should double check the algorithm recommendations against table 1 in FFSTV13.",
          "createdAt": "2018-05-25T19:22:01Z",
          "updatedAt": "2018-05-25T19:38:30Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "H0 and H1",
              "createdAt": "2018-05-25T19:22:01Z",
              "updatedAt": "2018-05-25T23:32:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTMxMzQy",
          "commit": {
            "abbreviatedOid": "b2a1e72"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T22:51:13Z",
          "updatedAt": "2018-05-25T22:51:13Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": ">Section 9 (security recommendations) is a bit redundant now, since the whole piece is shaped around that comment.\r\n\r\nIndeed. We can clean it up in a future PR.\r\n\r\n> We should probably cite Brier et al. https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13 as the primary reference for the general construction (they proved it for Icart function only though). And also can use the other generalized construction H(m) = f(h1(m)) + h2(m)G which you can show holds for Elligator\r\n\r\nDo we really want to specify two generic mechanisms when one would suffice?\r\n\r\n> Should double check the algorithm recommendations against table 1 in FFSTV13.\r\n\r\nYep, will do post-merge.",
              "createdAt": "2018-05-25T22:51:13Z",
              "updatedAt": "2018-05-25T23:32:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwODAzODUy",
      "title": "POC implementation and description of SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/25",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-27T19:45:12Z",
      "updatedAt": "2022-02-18T16:41:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f9d3bca1c9d6dd83c5597204b9b60732412afd1e",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/pocs",
      "headRefOid": "4bee51df43ce1ae54cd6ef54ba567a29bcfa672e",
      "closedAt": "2018-05-31T19:45:54Z",
      "mergedAt": "2018-05-31T19:45:54Z",
      "mergedBy": "samscott89",
      "mergeCommit": {
        "oid": "da1f7b2679c7516522119c9e3d6e8d13fa2eb02d"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, the code is (partially?) from [2009/340](https://eprint.iacr.org/2009/340.pdf) I take it?",
          "createdAt": "2018-05-28T03:04:55Z",
          "updatedAt": "2018-05-28T03:04:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, I just implemented that algorithm. ",
          "createdAt": "2018-05-28T03:36:55Z",
          "updatedAt": "2018-05-28T03:36:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjExMjQ2",
          "commit": {
            "abbreviatedOid": "ab66c9d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good so far. Out of interest, what's the source of the code/algorithm used here (i.e., is it lifted from the paper directly, or have you interpreted it?). ",
          "createdAt": "2018-05-28T02:48:10Z",
          "updatedAt": "2018-05-28T03:01:16Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This notation for X1 etc. is a bit confusing. These are effectively inline function definitions, right? I think it might be clearer to just write `X1 = u` and so on. ",
              "createdAt": "2018-05-28T02:48:10Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            },
            {
              "originalPosition": 72,
              "body": "I think these details are a little too much. I think it is sufficient to say something like \"The algorithm computes three candidate points, constructed such that at least one of them lies on the curve\".",
              "createdAt": "2018-05-28T02:56:17Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            },
            {
              "originalPosition": 125,
              "body": "Should there be CMOVs here?",
              "createdAt": "2018-05-28T02:57:34Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjE1MTQw",
          "commit": {
            "abbreviatedOid": "ab66c9d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T03:35:41Z",
          "updatedAt": "2018-05-28T03:35:42Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Yeah, they are. I\u2019ll fix it per your suggestion!",
              "createdAt": "2018-05-28T03:35:41Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjE1MTg5",
          "commit": {
            "abbreviatedOid": "ab66c9d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T03:36:17Z",
          "updatedAt": "2018-05-28T03:36:17Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Yeah, but I was going to do that for all algorithms in one swoop, in a different PR.",
              "createdAt": "2018-05-28T03:36:17Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MDUwNzg0",
          "commit": {
            "abbreviatedOid": "acf0ed5"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T15:36:36Z",
          "updatedAt": "2018-05-29T15:36:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I guess we should clarify (for this, and for the others) that it only works for any Weierstrauss curve? Or maybe \"curve in Weierstrauss form\"? Although I expect you could lift the encoding by just applying the suitable transformation?",
              "createdAt": "2018-05-29T15:36:37Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MTQxNTc4",
          "commit": {
            "abbreviatedOid": "acf0ed5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T19:38:21Z",
          "updatedAt": "2018-05-29T19:38:21Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Right -- the Weierstrauss requirement applies for all (?) the algorithms in the document. I think it's easier to keep that pattern, and then later -- in the TODO section -- describe how to transform from one form to another.",
              "createdAt": "2018-05-29T19:38:21Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MTQyMDY1",
          "commit": {
            "abbreviatedOid": "acf0ed5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T19:39:43Z",
          "updatedAt": "2018-05-29T19:39:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Doh, scratch that. Elligator2 is given for Montgomery curves.",
              "createdAt": "2018-05-29T19:39:43Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NDk3ODYy",
          "commit": {
            "abbreviatedOid": "4bee51d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T16:56:07Z",
          "updatedAt": "2018-05-30T16:56:07Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "@samscott89 Are the latest changes good to go?",
              "createdAt": "2018-05-30T16:56:07Z",
              "updatedAt": "2018-05-30T16:56:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NDU2OTgw",
      "title": "hacspec implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/31",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Elligator2 and SWU are incomplete since there is no square root function defined for each respective curve. I'll work with the hacspec folks to get that fixed.",
      "createdAt": "2018-06-13T02:43:15Z",
      "updatedAt": "2022-02-18T16:41:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "da1f7b2679c7516522119c9e3d6e8d13fa2eb02d",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/hacspec",
      "headRefOid": "adc1f15b270decf8ec10e5ba8e373f19b39a49a6",
      "closedAt": "2018-06-19T20:36:04Z",
      "mergedAt": "2018-06-19T20:36:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "781b3ab570539ed3cc0a0b4a97c2f931ee439012"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review, @franziskuskiefer!",
          "createdAt": "2018-06-13T23:08:33Z",
          "updatedAt": "2018-06-13T23:08:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@franziskuskiefer @samscott89 Updated the code. We'll need to adopt the square root computations when they land in mainline hacspec.",
          "createdAt": "2018-06-15T00:34:16Z",
          "updatedAt": "2018-06-15T00:34:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 OK to merge?",
          "createdAt": "2018-06-18T03:17:28Z",
          "updatedAt": "2018-06-18T03:17:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTg0MDQ1",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I added a couple comments :)",
          "createdAt": "2018-06-13T22:12:06Z",
          "updatedAt": "2018-06-13T22:28:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "All functions must be annotated `@typechecked` to pass the hacspec checker.",
              "createdAt": "2018-06-13T22:12:07Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Raw Python lists aren't allowed in hacspec. You should wrap it into an array (`array([...])`).",
              "createdAt": "2018-06-13T22:15:19Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 27,
              "body": "The return type should be `felem_t`.",
              "createdAt": "2018-06-13T22:21:20Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 5,
              "body": "This changed to change to `refine_t` and `nat_t` to be more consistent using `_t`.",
              "createdAt": "2018-06-13T22:23:13Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 18,
              "body": "The return type should be `felem_t`.",
              "createdAt": "2018-06-13T22:26:45Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1NTgx",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:09Z",
          "updatedAt": "2018-06-13T23:06:10Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Aha! Thanks. :-)",
              "createdAt": "2018-06-13T23:06:09Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1NjMx",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:24Z",
          "updatedAt": "2018-06-13T23:06:25Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Noted -- I'm going to remove this before merging anyway.",
              "createdAt": "2018-06-13T23:06:24Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1Njc3",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:39Z",
          "updatedAt": "2018-06-13T23:06:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "ACK!",
              "createdAt": "2018-06-13T23:06:40Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1NzI5",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:58Z",
          "updatedAt": "2018-06-13T23:06:58Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Indeed. I was waiting for the square root function to make it complete. For now, I'll change it to felem_t. ",
              "createdAt": "2018-06-13T23:06:58Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NzIxMzA5",
          "commit": {
            "abbreviatedOid": "adc1f15"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T20:18:02Z",
          "updatedAt": "2018-06-18T20:18:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Does this still need to be done?",
              "createdAt": "2018-06-18T20:18:02Z",
              "updatedAt": "2018-06-18T20:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NzM3MTU3",
          "commit": {
            "abbreviatedOid": "adc1f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T20:59:55Z",
          "updatedAt": "2018-06-18T20:59:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@samscott89  I elected not to do it, since this wouldn't go into the appendix. ",
              "createdAt": "2018-06-18T20:59:55Z",
              "updatedAt": "2018-06-18T21:00:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3NTUyMDUz",
      "title": "Clarify Naive encoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-26T21:09:40Z",
      "updatedAt": "2022-02-18T16:41:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "0e08d7613c9a77783a08cc56d15082aa226f540b",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/naive-clarify",
      "headRefOid": "65341643e39e6e85f3be3e856e6b54d1326dddc8",
      "closedAt": "2018-07-01T20:42:02Z",
      "mergedAt": "2018-07-01T20:42:02Z",
      "mergedBy": "samscott89",
      "mergeCommit": {
        "oid": "fdb70a5f0c836a4ab8090c5a84952c688e5ccc35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDY0OTkx",
          "commit": {
            "abbreviatedOid": "6534164"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-01T20:41:54Z",
          "updatedAt": "2018-07-01T20:41:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4NDYwMzE1",
      "title": "encoding-tables",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/44",
      "state": "CLOSED",
      "author": "klcappelli",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Added curve primes and prime characteristics. Added table with possible encodings for a given curve.",
      "createdAt": "2018-08-15T02:48:48Z",
      "updatedAt": "2019-01-25T19:16:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fdb70a5f0c836a4ab8090c5a84952c688e5ccc35",
      "headRepository": "klcappelli/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "tables",
      "headRefOid": "2d9cf13a15a2476695e1640dd73275da026639ff",
      "closedAt": "2019-01-25T19:16:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@klcappelli do you plan to update this PR?",
          "createdAt": "2018-10-20T05:24:26Z",
          "updatedAt": "2018-10-20T05:24:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events (ciphersuite additions), so closing for now. @klcappelli please re-open with requested changes when ready!",
          "createdAt": "2019-01-25T19:16:01Z",
          "updatedAt": "2019-01-25T19:16:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2NjM4NzYy",
          "commit": {
            "abbreviatedOid": "2d9cf13"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-15T22:08:07Z",
          "updatedAt": "2018-08-15T22:09:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Some explanatory text or prologue before this table would be nice. Also, we don't have Elligator Squared or DE defined, so perhaps either add sections for them or remove them? And what is TI?",
              "createdAt": "2018-08-15T22:08:07Z",
              "updatedAt": "2018-08-15T22:09:32Z"
            },
            {
              "originalPosition": 10,
              "body": "When rendered, this is a bit more information than I expected. I think we ought to drop these two new rows, as they don't seem to help when making an encoding decision. ",
              "createdAt": "2018-08-15T22:09:30Z",
              "updatedAt": "2018-08-15T22:09:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIwNzg1Mzk0",
      "title": "Clarify definitions of utility functions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/56",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #6, #40 and partially addresses #51.\r\n\r\nTrying to be a bit more rigorous with the HashToBase definition, and usage of the Legendre symbol computation. We could additionally specify hash functions which should be used with each field size?",
      "createdAt": "2018-10-05T18:22:55Z",
      "updatedAt": "2019-01-25T17:02:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fdb70a5f0c836a4ab8090c5a84952c688e5ccc35",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "update-utilities",
      "headRefOid": "cb55b6a757c8c5ee35d0462df8296319d007cd68",
      "closedAt": "2018-10-09T05:14:16Z",
      "mergedAt": "2018-10-09T05:14:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f093b5838aa8068b09ad1b8af2a63b2f51f41def"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Can potentially roll #12 into this PR as well.",
          "createdAt": "2018-10-05T18:24:17Z",
          "updatedAt": "2018-10-05T18:24:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNzE4MjU2",
          "commit": {
            "abbreviatedOid": "cb55b6a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These changes look great! Merging as is.",
          "createdAt": "2018-10-09T05:14:10Z",
          "updatedAt": "2018-10-09T05:14:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNDQ5Nzky",
      "title": "Ciphersuite changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/57",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-17T02:26:00Z",
      "updatedAt": "2022-02-18T16:41:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "32a1a5922a2d3bb39ea5eb97868dcf47cead1327",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "nick/ciphersuites",
      "headRefOid": "1330b8251fe14d0f331a920ec14c6fce83bd2036",
      "closedAt": "2018-10-20T05:23:31Z",
      "mergedAt": "2018-10-20T05:23:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6cd3189cb1bb74fe926697cb17a6d574e40cfa24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1NDM2NTAz",
          "commit": {
            "abbreviatedOid": "04997fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-17T02:33:19Z",
          "updatedAt": "2018-10-17T02:39:56Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The title of the document uses \"hashes,\" so this seems to be inconsistent. Perhaps we can say \"encode or hash an arbitrary...\"?",
              "createdAt": "2018-10-17T02:33:19Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 59,
              "body": "Should this be SSWU?",
              "createdAt": "2018-10-17T02:34:36Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 59,
              "body": "Should we add \"-*\" to indicate that the Transformation is nil?",
              "createdAt": "2018-10-17T02:34:57Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 74,
              "body": "Missing period after \"P-256\".",
              "createdAt": "2018-10-17T02:35:22Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 110,
              "body": "I think this should say that the output is transformed with FFSTV, right?",
              "createdAt": "2018-10-17T02:39:04Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzMzNDI2",
          "commit": {
            "abbreviatedOid": "1330b82"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-20T01:32:56Z",
          "updatedAt": "2018-10-20T01:32:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNzE2NDY4",
      "title": "Correcting some parts of the text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/58",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR corrects some parts of the texts that are imprecise.\r\nElligator2 must consider mapping the 0 \\in Fp  to the point (0,0); thus a clear cofactor phase must be added later.",
      "createdAt": "2018-10-17T18:54:48Z",
      "updatedAt": "2018-10-18T23:36:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8e193b7e41c3b4658675f814440789edc6694a24",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "typos",
      "headRefOid": "e223a01d59f99911e4e759876b2fa8ac706bbf09",
      "closedAt": "2018-10-18T23:36:03Z",
      "mergedAt": "2018-10-18T23:36:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "32a1a5922a2d3bb39ea5eb97868dcf47cead1327"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "My editor automatically removed whitespaces at the end. ",
          "createdAt": "2018-10-17T18:55:37Z",
          "updatedAt": "2018-10-17T18:55:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1Nzg2Nzk1",
          "commit": {
            "abbreviatedOid": "7f4e810"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. Thanks!",
          "createdAt": "2018-10-17T18:57:26Z",
          "updatedAt": "2018-10-17T19:46:09Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "I guess this should either be \"must output\" or \"outputs\".",
              "createdAt": "2018-10-17T18:57:26Z",
              "updatedAt": "2018-10-18T23:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzMzODk1",
          "commit": {
            "abbreviatedOid": "7f4e810"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-18T23:29:22Z",
          "updatedAt": "2018-10-18T23:29:23Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Yes -- please change this to \"outputs\". Otherwise, this looks great! Thanks!",
              "createdAt": "2018-10-18T23:29:22Z",
              "updatedAt": "2018-10-18T23:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzM1MDE4",
          "commit": {
            "abbreviatedOid": "e223a01"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-18T23:35:18Z",
          "updatedAt": "2018-10-18T23:35:18Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Done.",
              "createdAt": "2018-10-18T23:35:18Z",
              "updatedAt": "2018-10-18T23:35:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzM1MTQw",
          "commit": {
            "abbreviatedOid": "e223a01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-18T23:35:56Z",
          "updatedAt": "2018-10-18T23:35:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NDE5MTY4",
      "title": "WIP specifics of HashToBase.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/59",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WIP"
      ],
      "body": "Some attempts to formalize HashToBase a bit more.\r\nIncludes sage script for computing.\r\nPartially includes #54 #42 #12 ",
      "createdAt": "2018-10-19T21:50:04Z",
      "updatedAt": "2018-10-22T14:02:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "eed50eabd4c8416432dbedd13ad44ccc0e56d6d9",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "hash-to-base-improvements",
      "headRefOid": "7c557424159b93440006c3dff7ed199e0e728e4e",
      "closedAt": "2018-10-22T13:50:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks all for the comments.\r\n\r\nI would say the outstanding issue here is whether to standardise the use of this additional sign bit across all the algorithms. My changes reflect what that would look like.\r\nPersonally.... I'm not entirely sure it's justified. This would be a case of increasing complexity for the sake of an additional bit of security. At the same time, it has some precedent (see the [signal spec](https://signal.org/docs/specifications/xeddsa/#hashing-to-a-point-with-elligator-2), for example).\r\nThoughts?\r\n\r\nAlso, would be good to get some input about the example configurations text in C.5.2, and how to specify variable length hashing (#12). It would be good to have a precise definition here which the ciphersuites (#57) can refer to. I like the idea of using is to justify use of, e.g. SHA512 for P256 though.",
          "createdAt": "2018-10-20T15:59:44Z",
          "updatedAt": "2018-10-20T15:59:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Will you have a chance to resolve these conflicts before tomorrow?",
          "createdAt": "2018-10-21T19:50:31Z",
          "updatedAt": "2018-10-21T19:50:31Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Could handle the conflicts, but not sure if it's ready (with respect to my comment above)",
          "createdAt": "2018-10-21T22:08:11Z",
          "updatedAt": "2018-10-21T22:08:11Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Just pushed a subset of these changes (the ones I believe don't require discussion).\r\nFor some reason I couldn't create a PR, and it fixes some broken links so I went ahead and pushed straight to master. Getting 500 errors from Github, sooo.... (@chris-wood)",
          "createdAt": "2018-10-22T03:56:28Z",
          "updatedAt": "2018-10-22T03:56:28Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Core changes made in other commit - 8f9d9a5cbb1c3994faa879e71d3656ac1aa711cf. Closing this for now.",
          "createdAt": "2018-10-22T13:50:54Z",
          "updatedAt": "2018-10-22T14:02:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE0OTI4",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "",
          "createdAt": "2018-10-19T22:29:17Z",
          "updatedAt": "2018-10-20T16:00:46Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "reduced -> reduces it",
              "createdAt": "2018-10-19T22:29:17Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE3NDM3",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:43:46Z",
          "updatedAt": "2018-10-19T22:43:46Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "round -> floor",
              "createdAt": "2018-10-19T22:43:46Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE3NjY2",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:45:13Z",
          "updatedAt": "2018-10-19T22:45:13Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I am not completely sure whether the hash output must be truncated. Since all the bits of the hash must contribute _in some manner_ to the value X in Fp.",
              "createdAt": "2018-10-19T22:45:13Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE4Mjkw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:48:58Z",
          "updatedAt": "2018-10-19T22:48:58Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Keeping one bit during all the mapping can result costly, if constant-time implementation is required.\r\nA better approach is that every suite decides a criteria for selecting square roots. \r\nFor example, for p=3 mod 4, one can choose the principal square root. \r\nAnd, for p=5 mod 8, one can choose the root x such that 0 <= x <= (p-1)/2. \r\nThese criteria must be set by the suite and not by the hash output",
              "createdAt": "2018-10-19T22:48:58Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE5MDQw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:53:41Z",
          "updatedAt": "2018-10-19T22:53:41Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "round -> floor",
              "createdAt": "2018-10-19T22:53:41Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE5NDcw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:56:15Z",
          "updatedAt": "2018-10-19T22:56:15Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This definition is quite complicated. The number of bits of a positive integer x is floor(log2(x))+1.\r\n",
              "createdAt": "2018-10-19T22:56:15Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzUyMzkw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-20T15:12:15Z",
          "updatedAt": "2018-10-20T15:12:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "So I'm with you on the principal square root computation. But the idea of returning an additional bit from HashToBase is to be able to cover more elements in the encoding phase. Given a properly specified principal `sqrt` function, it is still useful to be able to do `CNEG(sqrt(x), s)`, making use of the additional bit of entropy. Or perhaps a better way would be to move it to the final computation. I.e. replace `return P` with `return CNEG(P, s)`.\r\n\r\nI'm not sure I follow the claim about making it costly and relevance to constant time operations though.",
              "createdAt": "2018-10-20T15:12:15Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzUyNjI1",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-20T15:21:57Z",
          "updatedAt": "2018-10-20T15:21:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The original idea of using `round` was to allow for primes which are slightly higher than a power of 2 to be used. E.g. mapping to 2^256 + 297, you can get away with just taking 256 bits of output, since the bias is negligible. Whereas using `floor +1` would require 257 bits, thus potentially needing another hash invocation.\r\n\r\nBUT... since this doesn't to be the case for any fields in use afaict, it probably is just over complicating things.",
              "createdAt": "2018-10-20T15:21:57Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY2MjQw",
      "title": "Various edits.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/60",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For #50.",
      "createdAt": "2018-10-21T20:18:44Z",
      "updatedAt": "2022-02-18T16:42:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8f9d9a5cbb1c3994faa879e71d3656ac1aa711cf",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/various-edits",
      "headRefOid": "eed50eabd4c8416432dbedd13ad44ccc0e56d6d9",
      "closedAt": "2018-10-22T13:49:08Z",
      "mergedAt": "2018-10-22T13:49:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "eed50eabd4c8416432dbedd13ad44ccc0e56d6d9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0Nzk4NzQ4",
      "title": "Add general CMOV implementation suggestion.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/64",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-22T20:10:54Z",
      "updatedAt": "2022-02-18T16:42:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "eed50eabd4c8416432dbedd13ad44ccc0e56d6d9",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/cmov",
      "headRefOid": "fb287f78808055a34a6fbaebab9cc5bba73e9479",
      "closedAt": "2018-10-22T20:12:58Z",
      "mergedAt": "2018-10-22T20:12:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fe6551c2b57f378d8ab5f3b9453d4f735409f7df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDg4MTkz",
          "commit": {
            "abbreviatedOid": "fb287f7"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T20:11:47Z",
          "updatedAt": "2018-10-22T20:11:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0ODAxODgx",
      "title": "More cleanup and missing details.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/65",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #38, #14, and #11.",
      "createdAt": "2018-10-22T20:22:13Z",
      "updatedAt": "2022-02-18T16:42:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fe6551c2b57f378d8ab5f3b9453d4f735409f7df",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/more-cleanup",
      "headRefOid": "67986e2aeb9b9885d04d921597681aeb73ef24fa",
      "closedAt": "2018-10-22T20:33:23Z",
      "mergedAt": "2018-10-22T20:33:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d7ed0df33fe054082930e2dd70ed2facf9dfe274"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDk1MjU2",
          "commit": {
            "abbreviatedOid": "0799b43"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-22T20:29:27Z",
          "updatedAt": "2018-10-22T20:29:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Should be -1 according to @armfazh ",
              "createdAt": "2018-10-22T20:29:27Z",
              "updatedAt": "2018-10-22T20:31:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDk1NjYw",
          "commit": {
            "abbreviatedOid": "0799b43"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-22T20:30:27Z",
          "updatedAt": "2018-10-22T20:30:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "We were just double checking this!",
              "createdAt": "2018-10-22T20:30:27Z",
              "updatedAt": "2018-10-22T20:31:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDk2NTAw",
          "commit": {
            "abbreviatedOid": "67986e2"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T20:32:40Z",
          "updatedAt": "2018-10-22T20:32:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0ODA3MTA4",
      "title": "Fix bug in Icart definition.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/67",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #61.",
      "createdAt": "2018-10-22T20:40:55Z",
      "updatedAt": "2019-01-25T17:02:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d7ed0df33fe054082930e2dd70ed2facf9dfe274",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "icart-bug",
      "headRefOid": "ec7ddd168c89f445b346472a15fc3a2af0ff7fda",
      "closedAt": "2018-10-22T20:42:34Z",
      "mergedAt": "2018-10-22T20:42:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2fee72ad1787b65c988382ffa0fd61fbe777ba95"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTAwMzEw",
          "commit": {
            "abbreviatedOid": "ec7ddd1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T20:42:29Z",
          "updatedAt": "2018-10-22T20:42:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0ODExODUy",
      "title": "Minor fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/68",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added some minor fixes on the text.\r\nIn algorithms, the operations are performed over the finite field; thus removing (mod p) is more precise.",
      "createdAt": "2018-10-22T20:57:16Z",
      "updatedAt": "2019-01-25T19:08:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "2fee72ad1787b65c988382ffa0fd61fbe777ba95",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "rev01",
      "headRefOid": "2413c7917e048d33b6e46f2fc53a87d482517fec",
      "closedAt": "2019-01-25T19:08:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Submit a new PR based on the latest version of the draft and after our meeting.\r\n",
          "createdAt": "2019-01-25T19:08:53Z",
          "updatedAt": "2019-01-25T19:08:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTQyODI2",
          "commit": {
            "abbreviatedOid": "2413c79"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T22:53:38Z",
          "updatedAt": "2018-10-22T22:53:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NDc2ODY0",
          "commit": {
            "abbreviatedOid": "2413c79"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this is a good idea overall. But we should make sure to be more explicit in the cases which *are* over the integers. And each algorithm block should be clear to state that all operations (unless otherwise specified) are over the field.\r\n(E.g. in the Icart algorithm there is `t2 = (2*p - 1) / 3` which should be specified to be done as scalars).",
          "createdAt": "2018-10-23T15:08:02Z",
          "updatedAt": "2018-10-23T15:08:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3Nzc3NDk2",
      "title": "Algorithm clarity + consistency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/72",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just dropping this here for now discussion in the meeting. An attempt to make the algorithms more consistent, and instrument the code for producing test vectors.",
      "createdAt": "2019-01-25T18:54:29Z",
      "updatedAt": "2019-02-09T15:59:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "86f7d4a0e65d8d58019dd2db364bc4c6565b3c37",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "algorithm-clarity",
      "headRefOid": "425d955031a33d20132fb6662a0fbf030741646d",
      "closedAt": "2019-02-09T15:59:55Z",
      "mergedAt": "2019-02-09T15:59:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "42903d81677fe9f0d56813429da43d711fd33a0e"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This will try and tackle a lot of minor issues. Relevant ones include:\r\n#40, #41, #45, #53, #55, #66, #69, #70, ",
          "createdAt": "2019-01-25T19:01:28Z",
          "updatedAt": "2019-01-25T19:01:28Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I claim this addresses the above issues:\r\n - #40, #70 - specified [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/blob/bdc2d53db28a9e0d5bde01c82527aa73669f825e/draft-irtf-cfrg-hash-to-curve.md#hashtobase-hashtobase). Prefix the input with the length (encoded as 4 bytes).\r\n - #41 - alpha is now only the bytestring input for all algorithms\r\n - #45 - corrected [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R667)\r\n - #53 - various fixes, but square root added [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R755)\r\n - #69 - added condition [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R544)\r\n\r\nOpen issue is #66 - how to specify square root algorithm. Initial attempt [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R436).\r\n",
          "createdAt": "2019-01-26T01:24:11Z",
          "updatedAt": "2019-01-26T01:24:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 will you have time to update this by end of the week?",
          "createdAt": "2019-02-07T15:36:27Z",
          "updatedAt": "2019-02-07T15:36:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2Nzk4ODAy",
          "commit": {
            "abbreviatedOid": "60909de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, this a great set of changes. I have minor editorial comments. I went through each pseudocode description and tried to make sure they have not changed, though I didn't run the code. ",
          "createdAt": "2019-01-26T19:08:08Z",
          "updatedAt": "2019-01-26T19:22:29Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Can we remove this commented out code?",
              "createdAt": "2019-01-26T19:08:08Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 29,
              "body": "Can we give an example of how indexed values are used for clarity?",
              "createdAt": "2019-01-26T19:11:54Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 38,
              "body": "Can we drop a reference to Sage?",
              "createdAt": "2019-01-26T19:12:27Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 315,
              "body": "Can we move `n` out of the algorithm, and just specify it in the preceding textual description? ",
              "createdAt": "2019-01-26T19:14:18Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 291,
              "body": "Should these be `sqrt` calls?",
              "createdAt": "2019-01-26T19:14:58Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 18,
              "body": "I wonder if we should be specific about which curves meet `p = 3 mod 4`, so as to save the reader the extra step of looking up the prime.",
              "createdAt": "2019-01-26T19:16:22Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 122,
              "body": "Should we provide guidance for how to check if an element is square (is a quadratic residue)?",
              "createdAt": "2019-01-26T19:20:46Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5MDM2NTQ1",
          "commit": {
            "abbreviatedOid": "60909de"
          },
          "author": "vadym-f",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-01T11:40:02Z",
          "updatedAt": "2019-02-01T11:40:03Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "if(legendre(z) == 1)  { \"z is a square\" case }",
              "createdAt": "2019-02-01T11:40:02Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMTQ5",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:18:25Z",
          "updatedAt": "2019-02-09T04:18:25Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Done in latest.",
              "createdAt": "2019-02-09T04:18:25Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMTY4",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:18:51Z",
          "updatedAt": "2019-02-09T04:18:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Done.",
              "createdAt": "2019-02-09T04:18:51Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzAy",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:23:54Z",
          "updatedAt": "2019-02-09T04:23:54Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "Done.",
              "createdAt": "2019-02-09T04:23:54Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzA3",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:24:02Z",
          "updatedAt": "2019-02-09T04:24:02Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "Good catch",
              "createdAt": "2019-02-09T04:24:02Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzMy",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:24:45Z",
          "updatedAt": "2019-02-09T04:24:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yeah, will have a look. If most are 3 (mod 4) then even easier, can just point out the outliers.",
              "createdAt": "2019-02-09T04:24:45Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzU0",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:25:33Z",
          "updatedAt": "2019-02-09T04:25:33Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "In the unrolled code we use the legendre method. Should we explain this somewhere? Or can replace the text by the computation?",
              "createdAt": "2019-02-09T04:25:33Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODY3NTMy",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-09T15:59:00Z",
          "updatedAt": "2019-02-09T15:59:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNjgzODIw",
      "title": "Address #48 and #36",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/74",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-09T16:42:47Z",
      "updatedAt": "2022-02-18T16:42:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "42903d81677fe9f0d56813429da43d711fd33a0e",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/edits",
      "headRefOid": "c46c7bc4bc7e2420153b8410fc8a78515888d27e",
      "closedAt": "2019-02-09T21:04:55Z",
      "mergedAt": "2019-02-09T21:04:55Z",
      "mergedBy": "samscott89",
      "mergeCommit": {
        "oid": "76d7bb422cc4f94aed92ccd6f42f69167533a287"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM!",
          "createdAt": "2019-02-09T21:04:50Z",
          "updatedAt": "2019-02-09T21:04:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc2NjY0",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Good additions, just a few suggestions.",
          "createdAt": "2019-02-09T20:17:41Z",
          "updatedAt": "2019-02-09T20:32:46Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The invertible part generally doesn't hold for random oracle constructions. ",
              "createdAt": "2019-02-09T20:17:41Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n| Curve448 | Elligator2 {{elligator2}} | FFSTV(Elligator2)\r\n```",
              "createdAt": "2019-02-09T20:18:12Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            },
            {
              "originalPosition": 44,
              "body": "This is a much nicer way to present this information :)\r\n\r\nShould we add that when in doubt, a random oracle construction is safer? As a separate note, it might be useful to include some basic intuition (in the appendix most likely) around the gaps between them.",
              "createdAt": "2019-02-09T20:28:39Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            },
            {
              "originalPosition": 51,
              "body": "Maybe add a sentence to explain the FFSTV(_) notation?",
              "createdAt": "2019-02-09T20:29:26Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc3Nzg1",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T20:54:05Z",
          "updatedAt": "2019-02-09T20:54:05Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oops. I meant to say non-invertible!",
              "createdAt": "2019-02-09T20:54:05Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc3ODQ1",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T20:55:30Z",
          "updatedAt": "2019-02-09T20:55:30Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Yep, will add!",
              "createdAt": "2019-02-09T20:55:30Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc3OTEw",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T20:57:42Z",
          "updatedAt": "2019-02-09T20:57:42Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Yep, will do!",
              "createdAt": "2019-02-09T20:57:42Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNzAxMjM4",
      "title": "Details square root",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/75",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Solves #66.",
      "createdAt": "2019-02-09T21:58:52Z",
      "updatedAt": "2019-02-09T22:00:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "76d7bb422cc4f94aed92ccd6f42f69167533a287",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "details-square-root",
      "headRefOid": "3abfe31bbe8f8b4db2bbadef52b2742c40dcba86",
      "closedAt": "2019-02-09T22:00:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNzAxMzYy",
      "title": "More details on computing constant time square root.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/76",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #66 .",
      "createdAt": "2019-02-09T22:01:19Z",
      "updatedAt": "2019-02-10T03:10:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "2b988928986119601bc22de139c678d5b1fab494",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "details-square-root",
      "headRefOid": "235d2bae0d1338c35e4d6b940b078da4a7c25ea6",
      "closedAt": "2019-02-10T03:10:40Z",
      "mergedAt": "2019-02-10T03:10:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d51d8443655d8658e5f7cefaddccb2537d4f59ed"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "For verifying the primes:\r\nhttps://sagecell.sagemath.org/?z=eJyNj00OwiAQRvdNeocvbZpAjQumYIDElRfwBK504UJt6s_5HUZpo4sqC76BPN4wNTb34XEg50woix5rUNvyCUvIxXA831Q1MRE91Omyh9XMNtcKDVTPm9V6DvdfuE94WdTYklu9G--45L6cZLHgNIEkQ7o2oz49iXitud-IvvM267kUvSEvydpk7yjZMemZ-1cvk1rrcwsuxwk-pBmMP6VPt1lWWg==&lang=sage",
          "createdAt": "2019-02-09T22:05:12Z",
          "updatedAt": "2019-02-09T22:05:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODgzMTkz",
          "commit": {
            "abbreviatedOid": "3abfe31"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T00:08:10Z",
          "updatedAt": "2019-02-10T00:08:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "s/Fieldsand/Fields and",
              "createdAt": "2019-02-10T00:08:11Z",
              "updatedAt": "2019-02-10T03:01:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODgzMjMw",
          "commit": {
            "abbreviatedOid": "3abfe31"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T00:09:36Z",
          "updatedAt": "2019-02-10T00:09:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should we add a comment which says this is -1 mod p? (I'm assuming it is, so please correct me and help clarify if I'm wrong!)",
              "createdAt": "2019-02-10T00:09:36Z",
              "updatedAt": "2019-02-10T03:01:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODgzMjQx",
          "commit": {
            "abbreviatedOid": "3abfe31"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved pending two suggestions!",
          "createdAt": "2019-02-10T00:09:59Z",
          "updatedAt": "2019-02-10T00:09:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODg2NTQ0",
          "commit": {
            "abbreviatedOid": "235d2ba"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T03:02:04Z",
          "updatedAt": "2019-02-10T03:02:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks",
              "createdAt": "2019-02-10T03:02:04Z",
              "updatedAt": "2019-02-10T03:02:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODg2NTYz",
          "commit": {
            "abbreviatedOid": "235d2ba"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T03:02:41Z",
          "updatedAt": "2019-02-10T03:02:41Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "It is indeed, and I agree it is worth clarifying (especially since it should be precomputed) ",
              "createdAt": "2019-02-10T03:02:41Z",
              "updatedAt": "2019-02-10T03:02:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNzU5MTQ3",
      "title": "Added test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/77",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #5 as well.",
      "createdAt": "2019-02-10T19:18:13Z",
      "updatedAt": "2022-02-18T16:42:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d51d8443655d8658e5f7cefaddccb2537d4f59ed",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/vectors",
      "headRefOid": "614758d3f96836d24bb45f1d5107003543c738bc",
      "closedAt": "2019-02-11T22:07:14Z",
      "mergedAt": "2019-02-11T22:07:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "43201207b29a6794fd9a7d9d0f0596800702cba7"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would it make sense to have some kind of easily machine-parseable artifact as well, that people can use for local tests?\r\n\r\nCan you give an example?",
          "createdAt": "2019-02-11T21:20:19Z",
          "updatedAt": "2019-02-11T21:20:19Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Might be unnecessary, but I was thinking the same information as is in the draft, but in a single text file (or one per ciphersuite), to allow people to just download the file and parse for tests. Probably unnecessary thinking about it though, easier to keep it in one place.",
          "createdAt": "2019-02-11T21:27:22Z",
          "updatedAt": "2019-02-11T21:27:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Bug: points calculated by Elligator2 suite must be multiplied by the cofactor at the end (Sage script does not do that). Also I consider this task is not optional as the document says.\r\n\r\n",
          "createdAt": "2019-02-11T21:47:09Z",
          "updatedAt": "2019-02-11T21:47:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @armfazh! I'll fix in a separate PR.",
          "createdAt": "2019-02-11T22:07:11Z",
          "updatedAt": "2019-02-11T22:07:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzI4NzMw",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T20:46:55Z",
          "updatedAt": "2019-02-11T20:46:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Thinking about this a bit more, there are a few operations which are similar complexity. Inverses, square root, cube root, quadratic residues, are all implemented in constant time using an exponentiation of approx about p. These would all count towards the running time.\r\n\r\nMy calculation (in terms of # of field mults):\r\n - Elligator2 has one sqrt, one inv = ~2log(p)\r\n - Icart has one inv, one cube root = ~ 2log(p)\r\n - SWU has one inv, onesqrt, two qrs = 4log(p)\r\n - SimpleSWU has one inv, one sqrt, one qr. = ~3log(p)\r\n\r\n----\r\nedited to reflect optimization from below",
              "createdAt": "2019-02-11T20:46:55Z",
              "updatedAt": "2019-02-11T21:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzMwNzcy",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These all seem like great additions, and awesome to finally have test vectors. \r\nWould it make sense to have some kind of easily machine-parseable artifact as well, that people can use for local tests?",
          "createdAt": "2019-02-11T20:51:49Z",
          "updatedAt": "2019-02-11T20:51:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzMxMjA0",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T20:52:48Z",
          "updatedAt": "2019-02-11T20:52:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "(I think that makes sense, any errors I'm blaming on a fever).",
              "createdAt": "2019-02-11T20:52:48Z",
              "updatedAt": "2019-02-11T20:52:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzMxNzkz",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T20:54:08Z",
          "updatedAt": "2019-02-11T20:54:08Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Actually, those square roots should all be brought down to 1, our implementation is inefficient.... We should compute the square root after doing a conditional swap on the x values so we only compute it once.",
              "createdAt": "2019-02-11T20:54:08Z",
              "updatedAt": "2019-02-11T20:54:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzM0OTU4",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T21:01:27Z",
          "updatedAt": "2019-02-11T21:01:27Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "#78 opened to solve that.",
              "createdAt": "2019-02-11T21:01:27Z",
              "updatedAt": "2019-02-11T21:01:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyMDYyNDkw",
      "title": "Reorder conditional moves and sqrt for efficiency.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/78",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-11T21:00:56Z",
      "updatedAt": "2019-03-01T16:21:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d96d735db4dffba50831af72e38a200ff814dec4",
      "headRepository": "samscott89/draft-sullivan-cfrg-hash-to-curve",
      "headRefName": "alg-efficiency",
      "headRefOid": "bfd0cfc9df375fd1c3405d8489d5d30d1128732a",
      "closedAt": "2019-03-01T16:21:41Z",
      "mergedAt": "2019-03-01T16:21:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fc1c89adf5994a6406532ad1383ea10a5caa2a78"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 can you update the Sage script, too?",
          "createdAt": "2019-02-11T22:08:22Z",
          "updatedAt": "2019-02-11T22:08:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5NjY2MDM3",
          "commit": {
            "abbreviatedOid": "d19c96f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-01T16:20:26Z",
          "updatedAt": "2019-03-01T16:20:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyNTIxNDQ4",
      "title": "Removes the index from HashToBase function.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/83",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: issue #80\r\n\r\nChanges:\r\n - Description of HashToBase in main document.\r\n - Sage scripts updated.\r\n - SWU test vectors were updated.",
      "createdAt": "2019-02-13T00:34:51Z",
      "updatedAt": "2019-02-13T18:34:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "43201207b29a6794fd9a7d9d0f0596800702cba7",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "feb12-del-index",
      "headRefOid": "a5bc63ab74947997286b05fcce4085454bbf52d4",
      "closedAt": "2019-02-13T18:33:54Z",
      "mergedAt": "2019-02-13T18:33:54Z",
      "mergedBy": "samscott89",
      "mergeCommit": {
        "oid": "ef23acbbd6d030b2c466ab7fdcd0279c2ca1fcba"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, this looks like a good change to me too.",
          "createdAt": "2019-02-13T18:33:50Z",
          "updatedAt": "2019-02-13T18:34:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzMDEzMDY4",
          "commit": {
            "abbreviatedOid": "a5bc63a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good to me! And thanks for catching the other small errors, and updating the vectors.",
          "createdAt": "2019-02-13T03:12:11Z",
          "updatedAt": "2019-02-13T03:12:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyNTIyMTQz",
      "title": "Make more emphasis on preconditions for each algorithm.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/84",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds few things about formatting of algorithms. \r\nMakes a visible separation between Weierstrass and Montgomery curves.\r\n",
      "createdAt": "2019-02-13T00:38:47Z",
      "updatedAt": "2019-03-01T16:16:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "216b317947c38dbe9368982821fa696a60750848",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "feb12-preconditions",
      "headRefOid": "77b17cd8a383316b39f3b80f361e47a55c9e9b75",
      "closedAt": "2019-03-01T16:16:25Z",
      "mergedAt": "2019-03-01T16:16:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d96d735db4dffba50831af72e38a200ff814dec4"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": " - This PR was updated with latest master branch.\r\n - The Random Oracle section was updated to be more consistent. (related to #85)",
          "createdAt": "2019-02-13T19:34:59Z",
          "updatedAt": "2019-02-13T19:37:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDk5MTk0",
          "commit": {
            "abbreviatedOid": "4cdd03a"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T23:16:42Z",
          "updatedAt": "2019-02-13T23:16:43Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Sense check: does this properly separate domains?\r\nFor example, using I can call regular Icart on inputs `alpha || 0x02`, `alpha || 0x03`, and add the outputs.\r\n\r\nI think this would only be an issue in a situation where both were exposed in the same protocol?",
              "createdAt": "2019-02-13T23:16:42Z",
              "updatedAt": "2019-03-01T16:16:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDM0OTM1",
          "commit": {
            "abbreviatedOid": "4cdd03a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:18:53Z",
          "updatedAt": "2019-02-15T00:18:53Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Agree, it is required to separate the two cases when using an encoding X with and without the random oracle property. \r\nRequires further investigation.\r\n",
              "createdAt": "2019-02-15T00:18:53Z",
              "updatedAt": "2019-03-01T16:16:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyOTA4MTQy",
      "title": "Includes encodings for Weierstrass curves with A=0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/86",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Adds two new encodings FT and BF.\r\n - BF works for supersingular curves.\r\n - It is based on the suggested changes of\r\n   Ela B. Lee (#20) for the case of pairing-friendly\r\n   curves.\r\n - FT encoding supports all pairing-friendly curves.\r\n - FT also supports SECP256K1 (Bitcoin curve).\r\n\r\nAddresses: #16, #9 (partially), #39.",
      "createdAt": "2019-02-14T01:30:09Z",
      "updatedAt": "2019-03-01T16:12:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "ef23acbbd6d030b2c466ab7fdcd0279c2ca1fcba",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "feb13_aEqual0",
      "headRefOid": "0dc9968532715edb0ab9a8e37523550d5d31f99d",
      "closedAt": "2019-03-01T16:12:18Z",
      "mergedAt": "2019-03-01T16:12:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3ce9c3e87a3799fbbcc798bd2b0dec984f264832"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This might take some time to review. Looks great at first glance though.",
          "createdAt": "2019-02-14T01:54:20Z",
          "updatedAt": "2019-02-14T01:54:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The FT paper is behind a paywall. Do we have a soft copy?",
          "createdAt": "2019-02-14T02:25:06Z",
          "updatedAt": "2019-02-14T02:25:06Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> The FT paper is behind a paywall. Do we have a soft copy?\r\nhttps://www.di.ens.fr/~fouque/pub/latincrypt12.pdf",
          "createdAt": "2019-02-14T22:59:09Z",
          "updatedAt": "2019-02-14T22:59:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh please have a look!",
          "createdAt": "2019-02-20T20:03:08Z",
          "updatedAt": "2019-02-20T20:03:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM! @samscott89, can you please have a look?",
          "createdAt": "2019-02-27T00:46:49Z",
          "updatedAt": "2019-02-27T00:46:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNTQzMjQ4",
          "commit": {
            "abbreviatedOid": "ee5d184"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T02:20:19Z",
          "updatedAt": "2019-02-14T02:23:46Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "nit: here we use `alpha: an...` and below we use `alpha - an...`. Can we be consistent?",
              "createdAt": "2019-02-14T02:20:19Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 121,
              "body": "Why is `covering the case...` a parenthetical? Can we make it a proper sentence? Perhaos:\r\n\r\n`... and q=7 mod 12. This covers the case of q=1 mod, which is not handled by the Boneh-Franklin method.`",
              "createdAt": "2019-02-14T02:21:48Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 126,
              "body": "We should cite these curves.",
              "createdAt": "2019-02-14T02:21:59Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 146,
              "body": "Why is this an operation? Can we lift this up to somewhere above?",
              "createdAt": "2019-02-14T02:22:43Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNTQ0NDc3",
          "commit": {
            "abbreviatedOid": "ee5d184"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T02:26:46Z",
          "updatedAt": "2019-02-14T02:26:46Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Stupid question: on what page is this method described in the paper?",
              "createdAt": "2019-02-14T02:26:46Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDE1MzE4",
          "commit": {
            "abbreviatedOid": "ee5d184"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T22:59:59Z",
          "updatedAt": "2019-02-14T23:00:00Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Secction 5.2 of \"Identity-Based Encryption from the Weil Pairing\" Boneh, Franklin",
              "createdAt": "2019-02-14T23:00:00Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMDE5",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:09:41Z",
          "updatedAt": "2019-02-15T00:09:41Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Done",
              "createdAt": "2019-02-15T00:09:41Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMDM5",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:09:48Z",
          "updatedAt": "2019-02-15T00:09:48Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Done",
              "createdAt": "2019-02-15T00:09:48Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMDcx",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:09:54Z",
          "updatedAt": "2019-02-15T00:09:54Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Done",
              "createdAt": "2019-02-15T00:09:54Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMTI3",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:10:16Z",
          "updatedAt": "2019-02-15T00:10:16Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Removed and explicitly stated.",
              "createdAt": "2019-02-15T00:10:16Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTQwMjM0",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I still need to review the FT method, though I've left comments on the BF method. As an aside, can we please ensure that all expressions are written with spacing between operator terms, e.g., `3 + x * 2` instead of `3+x*2`",
          "createdAt": "2019-02-17T00:24:31Z",
          "updatedAt": "2019-02-17T00:35:36Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "It also requires that `b=1`, no? Can you explain why it works for other values of `b`?",
              "createdAt": "2019-02-17T00:24:32Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 157,
              "body": "Should we express this cube root as `(u^2 - B)^((2*q - 1)/3)`?",
              "createdAt": "2019-02-17T00:26:13Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 158,
              "body": "IIUC, the paper also describes multiplying by the cofactor (`l`). Do we need that? If not, why?",
              "createdAt": "2019-02-17T00:27:38Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 229,
              "body": "nit: s/`st`/`s*t`",
              "createdAt": "2019-02-17T00:28:43Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 234,
              "body": "nit: capitalize \"if\", and same below.",
              "createdAt": "2019-02-17T00:29:09Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 115,
              "body": "What is the purpose of this section? Do we plan to specify encodings for other curve representations?",
              "createdAt": "2019-02-17T00:29:41Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA1OTY3ODU2",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Okay, my pass with the FT algorithm is done. I think there might be one error in the description (for `x3` specifically). My other comments are editorial.",
          "createdAt": "2019-02-20T19:53:44Z",
          "updatedAt": "2019-02-20T20:02:40Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Can you please drop a reference to Section 3, Definition 2 of the paper?",
              "createdAt": "2019-02-20T19:53:44Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 229,
              "body": "nit: `st` -> `s*t`",
              "createdAt": "2019-02-20T19:54:30Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 230,
              "body": "Can you add parentheses around (-1 + s) / 2 so that order of operations are clear? Also `tw` -> `t*w`",
              "createdAt": "2019-02-20T19:56:10Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 232,
              "body": "`x3` seems wrong. Should it be `x3 = 1 - 1/w^2`?",
              "createdAt": "2019-02-20T19:59:14Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 263,
              "body": "Can this be t, as in the paper and above description?",
              "createdAt": "2019-02-20T20:00:18Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 268,
              "body": "Can we use different values (and names -- not `ti`) for these intermediates? That would help with test vector generation.",
              "createdAt": "2019-02-20T20:00:43Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 294,
              "body": "Can we remove the values for `h`, as those depend on the curve? We can just say that multiplication by the cofactor is required.",
              "createdAt": "2019-02-20T20:01:54Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjQxNDk3",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:21:21Z",
          "updatedAt": "2019-02-26T22:21:21Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "It works for any `B` since there exist always a cubic root of any element in `Fp`.\r\n",
              "createdAt": "2019-02-26T22:21:21Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjQzNzQ4",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:26:38Z",
          "updatedAt": "2019-02-26T22:26:38Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Fixed.",
              "createdAt": "2019-02-26T22:26:38Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjUyOTYx",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:49:41Z",
          "updatedAt": "2019-02-26T22:49:41Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Yes, it is required to multiply by a cofactor and this is recurrent in several encodings to obtain points in a subgroup of points. For the BF encoding, the value of the cofactor varies as is dependent on the target subgroup.\r\n",
              "createdAt": "2019-02-26T22:49:41Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjU1NTE3",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:56:29Z",
          "updatedAt": "2019-02-26T22:56:29Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Basically, I was planning to include encodings for \r\n 2. Montgomery curves\r\n 2.1. Elligator2 ( A!=0 )\r\n 2.2  Elligator2 specillized for  A=0 \r\n\r\nHowever, this can be discussed in the future.\r\n",
              "createdAt": "2019-02-26T22:56:29Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjczNTA0",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T23:55:20Z",
          "updatedAt": "2019-02-26T23:55:20Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Done.",
              "createdAt": "2019-02-26T23:55:20Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4Mjc3ODY1",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T00:12:13Z",
          "updatedAt": "2019-02-27T00:12:14Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "`x3 = 1+1/w^2` is correct.\r\nIn the paper, there is a minus sign due to the squaring of sqrt(-3) produces the minus sign. ",
              "createdAt": "2019-02-27T00:12:14Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4Mjc4MTk4",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T00:13:33Z",
          "updatedAt": "2019-02-27T00:13:33Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "Done.",
              "createdAt": "2019-02-27T00:13:33Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjgwODc5",
          "commit": {
            "abbreviatedOid": "0dc9968"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T00:24:08Z",
          "updatedAt": "2019-02-27T00:24:08Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "Done",
              "createdAt": "2019-02-27T00:24:08Z",
              "updatedAt": "2019-02-27T00:24:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4Mjg2Mzg3",
          "commit": {
            "abbreviatedOid": "0dc9968"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-27T00:46:31Z",
          "updatedAt": "2019-02-27T00:46:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3NTc3ODg3",
      "title": "Rename HashToBase.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/89",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #88.",
      "createdAt": "2019-03-01T20:50:18Z",
      "updatedAt": "2022-02-18T16:42:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a940065c50b82f1e3f6ffb97e73691c176311631",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/hash2base-rename",
      "headRefOid": "640426251c511ff79767a02235d5145aec2b0468",
      "closedAt": "2019-03-01T21:13:31Z",
      "mergedAt": "2019-03-01T21:13:31Z",
      "mergedBy": "samscott89",
      "mergeCommit": {
        "oid": "63ec71da8a59aec00927e75dd26ae312265e5cea"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This makes sense!",
          "createdAt": "2019-03-01T21:13:16Z",
          "updatedAt": "2019-03-01T21:13:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYwMDY5MTkw",
      "title": "Reference for BLS curves fixed.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/91",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Solving #90 ",
      "createdAt": "2019-03-11T17:40:42Z",
      "updatedAt": "2019-03-11T18:47:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8150855f1529290e783bbd903dd7e4aef29c9b57",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "24a84bc79a2e6ba2681455ba515879f2f61ab119",
      "closedAt": "2019-03-11T18:47:48Z",
      "mergedAt": "2019-03-11T18:47:48Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2765896160f9ed956f4ae651aaea278c5663f919"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDIwMzg2",
          "commit": {
            "abbreviatedOid": "24a84bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T18:47:44Z",
          "updatedAt": "2019-03-11T18:47:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYxMzgyNTIz",
      "title": "Fix non-ascii character",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/92",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2260 symbol appears as `&#8800;` in the HTML version",
      "createdAt": "2019-03-15T00:15:06Z",
      "updatedAt": "2022-02-18T16:42:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "2765896160f9ed956f4ae651aaea278c5663f919",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fix-non-ascii",
      "headRefOid": "5f1a4541dc893c2f34c56924c98d10bf19a4c337",
      "closedAt": "2019-03-15T01:09:23Z",
      "mergedAt": "2019-03-15T01:09:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9682be6cf4b38d129ac3691e5cd210276763d439"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYxNzAwMTcz",
      "title": "Updates the hash2base test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/94",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The reference code for hash2base is compliant with the specification in the main file.\r\nThis function must be correct as it has effect on all encodings.\r\n",
      "createdAt": "2019-03-15T21:11:33Z",
      "updatedAt": "2019-06-13T09:31:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "9682be6cf4b38d129ac3691e5cd210276763d439",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fix_hash2base",
      "headRefOid": "5a677589854bc0d6a70ba7056d07bc5a3c1e99db",
      "closedAt": "2019-06-13T09:31:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are we still waiting on Michelle\u2019s proof and PR? If so, can you please check with him?",
          "createdAt": "2019-05-02T18:37:31Z",
          "updatedAt": "2019-05-02T18:37:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR.\r\nChanges here proposed were superseded and test vectors will be stable once the definition of all functions be completed.",
          "createdAt": "2019-06-13T09:31:36Z",
          "updatedAt": "2019-06-13T09:31:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1MjU0NjI1",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-15T21:21:48Z",
          "updatedAt": "2019-03-15T21:21:48Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Why change this to not? Also, I think it should be `not(min_bits > hbits)`.",
              "createdAt": "2019-03-15T21:21:48Z",
              "updatedAt": "2019-03-15T21:21:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1MjYwODY4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-15T21:43:24Z",
          "updatedAt": "2019-03-15T21:43:24Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I followed what the main document states.\r\n\r\n```\r\n Preconditions:\r\n     floor(log2(p)) + 1 >= hbits\r\n```\r\nWhat would be the right equation to test?",
              "createdAt": "2019-03-15T21:43:24Z",
              "updatedAt": "2019-03-15T21:43:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDgzNTQ4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T00:36:43Z",
          "updatedAt": "2019-03-20T00:36:43Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Hmm,  the spec is actually wrong here. The spec should be:\r\n\r\n```\r\nhbits >= floor(log2(p)) + 1\r\n```\r\nand the code should be:\r\n```py\r\n     assert hbits >= min_bits, \"Need at least %d bits to hash p. H only outputs %d\" % (min_bits, hbits) \r\n```\r\n(In particular, `hbits` can be equal to `min_bits` ).",
              "createdAt": "2019-03-20T00:36:43Z",
              "updatedAt": "2019-03-20T00:36:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDgzNzk4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T00:38:17Z",
          "updatedAt": "2019-03-20T00:38:18Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "For my own sanity:\r\n\r\nThe output of the hash function `H` needs to output at least `log2(p) + 1` bits so that when we reduce the output of `H` by `mod p` we get as close to uniform as possible.",
              "createdAt": "2019-03-20T00:38:18Z",
              "updatedAt": "2019-03-20T00:38:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDk1NTQ4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T01:43:38Z",
          "updatedAt": "2019-03-20T01:43:38Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "On reading more about this, NIST.SP.800-56Ar3 suggests taking log(p)+64 bits instead of log(p)+1 to remove statistical bias introduced by the mod. Perhaps we should follow that advice?",
              "createdAt": "2019-03-20T01:43:38Z",
              "updatedAt": "2019-03-20T01:43:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDk1NjI3",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Requesting changes to increase the number of bits extracted before modulation.",
          "createdAt": "2019-03-20T01:44:03Z",
          "updatedAt": "2019-03-20T01:44:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NTEwNzE1",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T03:07:21Z",
          "updatedAt": "2019-03-20T03:07:21Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I think that's too conservative in this case, since the bias in the output is generally pretty negligible, and feeds into an encoding algorithm which is itself biased anyway. ",
              "createdAt": "2019-03-20T03:07:21Z",
              "updatedAt": "2019-03-20T03:07:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NzMzNDMz",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T13:55:34Z",
          "updatedAt": "2019-03-20T13:55:34Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "> ... and feeds into an encoding algorithm which is itself biased anyway\r\n\r\nThat may be the case, though I still think we should follow what seems to be best practice here, rather than deviate without cause. ",
              "createdAt": "2019-03-20T13:55:34Z",
              "updatedAt": "2019-03-20T13:55:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2ODUyNTcy",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T16:54:26Z",
          "updatedAt": "2019-03-20T16:54:27Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "The downside would be removing the validity of the SHA256-based ciphersuites. Neither P256 nor Curve25519 (which incidentally seems to be missing atm?) could be used with SHA256.\r\n\r\nFor the other combinations, we are already taking more that 64 extra (Curve448 has just about enough space).\r\n\r\nSo on one hand, we gain meeting best practice, and set stricter limits for future implementation.\r\n\r\nOn the other hand, we lose some ciphersuite combinations.",
              "createdAt": "2019-03-20T16:54:26Z",
              "updatedAt": "2019-03-20T16:54:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3MDQyMjUw",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-21T00:23:04Z",
          "updatedAt": "2019-03-21T00:23:04Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Are you agree with these parameters ?\r\n\r\n| bit length of primes  | size of hash |\r\n|----|-------|\r\n| 256 | SHA-512 |\r\n| 384 | SHA-512 |\r\n| 448 | SHA-512 |\r\n| 521 |  ? |\r\n\r\nAre you considering some suites with SHAKE/XOF? \r\n",
              "createdAt": "2019-03-21T00:23:04Z",
              "updatedAt": "2019-03-21T00:23:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3MjQ4OTA3",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-21T13:50:07Z",
          "updatedAt": "2019-03-21T13:50:08Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Yeah, the tradeoff is clear, and I'm not sure what is best. Perhaps we can email the list?",
              "createdAt": "2019-03-21T13:50:07Z",
              "updatedAt": "2019-03-21T13:50:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY2ODYyNDEw",
      "title": "A major update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/97",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I did a lot of changes in the text but I tried to keep the same structure of the document. You will notice that I remove some lines and comments. Hopefully, I did not erase something relevant; otherwise we can included again.\r\n\r\n",
      "createdAt": "2019-04-03T01:31:48Z",
      "updatedAt": "2019-04-20T01:17:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "9682be6cf4b38d129ac3691e5cd210276763d439",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "apr02",
      "headRefOid": "1b20fdf62597c1744bd8484462ae1d0d5fa3a393",
      "closedAt": "2019-04-20T01:17:18Z",
      "mergedAt": "2019-04-20T01:17:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "69f7e0eac615d51f18a35b53e69a3a99e66b05d8"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This update in the PR only solves most of the nits.\r\nIt remains as a to-do:  #99, which will be in another PR.\r\n",
          "createdAt": "2019-04-16T01:27:55Z",
          "updatedAt": "2019-04-16T01:27:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 @grittygrease any comments? If not, can we merge?",
          "createdAt": "2019-04-18T22:33:28Z",
          "updatedAt": "2019-04-18T22:33:28Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "No specific comments. Thanks for the continued effort.\n\nOn Thu, Apr 18, 2019 at 3:33 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @samscott89 <https://github.com/samscott89> @grittygrease\n> <https://github.com/grittygrease> any comments? If not, can we merge?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/97#issuecomment-484711470>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ7WIT2FAESUSHKHBHDPRDZLTANCNFSM4HDFWW7A>\n> .\n>\n",
          "createdAt": "2019-04-18T23:58:18Z",
          "updatedAt": "2019-04-18T23:58:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1MDc2NzIw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great start! I left some comments and food for thought. There are a few major ones, e.g., defining hash2base and cofactor clearing. I'm happy to hop on a call to discuss any of these. \r\n\r\n(Also, as Nick suggests, please add yourself as an author!)",
          "createdAt": "2019-04-10T16:15:41Z",
          "updatedAt": "2019-04-13T00:20:23Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "For clarity, should we just make a class to store the entire set of curve parameters? Or maybe just have a factory that returns curve objects given an input string?",
              "createdAt": "2019-04-10T16:15:41Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 79,
              "body": "Should we note that this is not constant time?",
              "createdAt": "2019-04-12T23:39:59Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 56,
              "body": "nit: please spell out Edwards. I think we ought to avoid abbreviations in this code.",
              "createdAt": "2019-04-12T23:41:29Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 77,
              "body": "nit: same here -- let's please spell out Affine and Edwards",
              "createdAt": "2019-04-12T23:42:06Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 87,
              "body": "nit: maybe we should refer to these textbook implementations as \"reference\" implementations? And we could then rename the \"slp\" variants to \"constant_time\", or something?",
              "createdAt": "2019-04-12T23:43:51Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1,
              "body": "Can we please rename this file back to its full form? ft might be misread as something else.",
              "createdAt": "2019-04-12T23:46:10Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 617,
              "body": "nit: what is \"it\" in \"it is allowed? Can we just say \"For example, some elliptic curves have order n = hr, where r is a large prime, and h is a non-negative integer known as the cofactor.\"",
              "createdAt": "2019-04-12T23:52:03Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 618,
              "body": "I would expand on the possible subgroups here. In particular, we have subgroups of order r and any multiple of h times r, right? I would then say that any encoding typically requires an encoding to a subgroup of prime order, i.e., of order r. ",
              "createdAt": "2019-04-12T23:53:56Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 621,
              "body": "I might also add that we refer to this process as \"cofactor clearing.\"",
              "createdAt": "2019-04-12T23:54:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 587,
              "body": "Nit: we need to define `char(p)` here, as we use it below.",
              "createdAt": "2019-04-12T23:54:56Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 637,
              "body": "s/\"For mapping to subgroup, need to multiply by cofactor.\"/\"Constant used in cofactor clearing to map to prime-order subgroup.\"?",
              "createdAt": "2019-04-12T23:55:31Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 763,
              "body": "I would remove this computation from the text. Folks may read the prior sentence, use this, and then stop reading. ",
              "createdAt": "2019-04-12T23:58:17Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 819,
              "body": "s/should/MUST?",
              "createdAt": "2019-04-12T23:59:12Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 915,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-04-13T00:00:05Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 837,
              "body": "Based on discussion, shouldn't this be at least `floor(log2(p))+64`?",
              "createdAt": "2019-04-13T00:00:49Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 837,
              "body": "If so, can we also move the rationale for this requirement to an appendix, perhaps with a sketch from Michele's proof?",
              "createdAt": "2019-04-13T00:01:43Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 852,
              "body": "nit: based on list feedback, \"as many bits as possible\" is not a meaningful requirement. We should probably be more precise here.",
              "createdAt": "2019-04-13T00:02:35Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 876,
              "body": "nit: this should be +64?",
              "createdAt": "2019-04-13T00:03:21Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 935,
              "body": "nit: missing comma after `e.g.`",
              "createdAt": "2019-04-13T00:03:42Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 940,
              "body": "s/the coordinates/the affine coordinates/?",
              "createdAt": "2019-04-13T00:03:59Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1003,
              "body": "Can we make `3*A` a constant?",
              "createdAt": "2019-04-13T00:04:58Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1386,
              "body": "nit: extra space between `curve` and `space`",
              "createdAt": "2019-04-13T00:09:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1483,
              "body": "nit: the style of this constants list does not match that of previous sections",
              "createdAt": "2019-04-13T00:12:00Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 805,
              "body": "The code uses `sq_root` in some places. Can we make this usage consistent?",
              "createdAt": "2019-04-13T00:12:52Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 2007,
              "body": "nit: copy-paste error for these suite IDs? They're all `H2C-0000`. Maybe we should make `H2C-0000` reserved and start at `H2C-0001`? ",
              "createdAt": "2019-04-13T00:14:48Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 2017,
              "body": "It seems odd that callers of `hash2curve` may have to *also* multiply by the cofactor to get a usable point in the curve. I think we should bake this step into the algorithms, i.e., always include a step that multiplies by the cofactor in each algorithm. This works for all curves, since for curves where p=n (h=1) nothing changes.",
              "createdAt": "2019-04-13T00:17:24Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 2140,
              "body": "Why drop this section? I think we ought to keep it.",
              "createdAt": "2019-04-13T00:17:41Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MTA4",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:00:11Z",
          "updatedAt": "2019-04-16T01:00:11Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It would be good to have the factory model that matches with recommended suites.",
              "createdAt": "2019-04-16T01:00:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MTM2",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:00:18Z",
          "updatedAt": "2019-04-16T01:00:18Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Done",
              "createdAt": "2019-04-16T01:00:18Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MzI3",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:01:15Z",
          "updatedAt": "2019-04-16T01:01:15Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Done",
              "createdAt": "2019-04-16T01:01:15Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MzU2",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:01:23Z",
          "updatedAt": "2019-04-16T01:01:24Z",
          "comments": [
            {
              "originalPosition": 617,
              "body": "Done",
              "createdAt": "2019-04-16T01:01:23Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NDU1",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:01:57Z",
          "updatedAt": "2019-04-16T01:01:57Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I didn't get the point, could you please rephrase it.",
              "createdAt": "2019-04-16T01:01:57Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NTYx",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:02:32Z",
          "updatedAt": "2019-04-16T01:02:32Z",
          "comments": [
            {
              "originalPosition": 621,
              "body": "Done. The cofactor clearing section was moved before presenting encodings.",
              "createdAt": "2019-04-16T01:02:32Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NjI0",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:02:47Z",
          "updatedAt": "2019-04-16T01:02:47Z",
          "comments": [
            {
              "originalPosition": 587,
              "body": "Removed.",
              "createdAt": "2019-04-16T01:02:47Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0Njcy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:03:02Z",
          "updatedAt": "2019-04-16T01:03:03Z",
          "comments": [
            {
              "originalPosition": 637,
              "body": "Done.",
              "createdAt": "2019-04-16T01:03:02Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NzM0",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:03:20Z",
          "updatedAt": "2019-04-16T01:03:20Z",
          "comments": [
            {
              "originalPosition": 763,
              "body": "Good observation.",
              "createdAt": "2019-04-16T01:03:20Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0ODc5",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:03:51Z",
          "updatedAt": "2019-04-16T01:03:51Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "Changed.",
              "createdAt": "2019-04-16T01:03:51Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ1MTgy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:05:29Z",
          "updatedAt": "2019-04-16T01:05:29Z",
          "comments": [
            {
              "originalPosition": 915,
              "body": "Let's see how this matches with cofactor multiplication step.",
              "createdAt": "2019-04-16T01:05:29Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NTE1",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:12:59Z",
          "updatedAt": "2019-04-16T01:12:59Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "The text currently implies there are only two possible subgroups, one of order `r` and another of order `hr`, though that's not the case, right? Aren't there more? See https://safecurves.cr.yp.to/twist.html.",
              "createdAt": "2019-04-16T01:12:59Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NjUw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:13:50Z",
          "updatedAt": "2019-04-16T01:13:50Z",
          "comments": [
            {
              "originalPosition": 837,
              "body": "This will be resolved in another PR. Currently #99 will track this issue.",
              "createdAt": "2019-04-16T01:13:50Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NzIw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:12Z",
          "updatedAt": "2019-04-16T01:14:12Z",
          "comments": [
            {
              "originalPosition": 852,
              "body": "Tracked on #99 .",
              "createdAt": "2019-04-16T01:14:12Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NzU2",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:25Z",
          "updatedAt": "2019-04-16T01:14:25Z",
          "comments": [
            {
              "originalPosition": 876,
              "body": "Tracked on #99 ",
              "createdAt": "2019-04-16T01:14:25Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2Nzcy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:31Z",
          "updatedAt": "2019-04-16T01:14:32Z",
          "comments": [
            {
              "originalPosition": 935,
              "body": "Done",
              "createdAt": "2019-04-16T01:14:31Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2Nzk0",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:38Z",
          "updatedAt": "2019-04-16T01:14:38Z",
          "comments": [
            {
              "originalPosition": 940,
              "body": "Done",
              "createdAt": "2019-04-16T01:14:38Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2ODc3",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:15:06Z",
          "updatedAt": "2019-04-16T01:15:06Z",
          "comments": [
            {
              "originalPosition": 1003,
              "body": "Done. It was changed in the implementation, but not in the description.",
              "createdAt": "2019-04-16T01:15:06Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2OTk5",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:15:35Z",
          "updatedAt": "2019-04-16T01:15:35Z",
          "comments": [
            {
              "originalPosition": 1386,
              "body": "done. However parser eats extra spaces.",
              "createdAt": "2019-04-16T01:15:35Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3MTcy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:16:38Z",
          "updatedAt": "2019-04-16T01:16:38Z",
          "comments": [
            {
              "originalPosition": 1483,
              "body": "Changed.",
              "createdAt": "2019-04-16T01:16:38Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3Mjc4",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:17:11Z",
          "updatedAt": "2019-04-16T01:17:11Z",
          "comments": [
            {
              "originalPosition": 805,
              "body": "Good catch.",
              "createdAt": "2019-04-16T01:17:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3Mzgx",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:17:42Z",
          "updatedAt": "2019-04-16T01:17:42Z",
          "comments": [
            {
              "originalPosition": 2007,
              "body": "These are TBD numbers.",
              "createdAt": "2019-04-16T01:17:42Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3NDkw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:18:17Z",
          "updatedAt": "2019-04-16T01:18:17Z",
          "comments": [
            {
              "originalPosition": 2017,
              "body": "Now it is included a cofactor multiplication for each encoding in the last step.",
              "createdAt": "2019-04-16T01:18:17Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3NjU5",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:19:15Z",
          "updatedAt": "2019-04-16T01:19:16Z",
          "comments": [
            {
              "originalPosition": 2140,
              "body": "The performance paragraph was included again now in Section 4.\r\nThe remainder of the paragraphs are also in Section 4.",
              "createdAt": "2019-04-16T01:19:15Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ5NDYy",
          "commit": {
            "abbreviatedOid": "986d061"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:28:54Z",
          "updatedAt": "2019-04-16T01:28:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Tracked in #98. \r\nCurrent PR will not handle this issue.",
              "createdAt": "2019-04-16T01:28:54Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTUxMzk3",
          "commit": {
            "abbreviatedOid": "986d061"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:38:54Z",
          "updatedAt": "2019-04-16T01:38:54Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Got it, the elliptic curve, as a whole, is a group order `n=hr` (the entire curve). But, it also has several subgroups.\r\n\r\nIn the text, it should be clear that the subgroup of interest is one of prime order `r`, with `r | n` hence `n=h*r` .\r\nThe other subgroup of the curve is one of order h. \r\nHowever, `h` could be again a composite number indicating the presence of smaller subgroups inside of the group of order `h`.\r\nHope this helps.\r\n",
              "createdAt": "2019-04-16T01:38:54Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTU5MzEy",
          "commit": {
            "abbreviatedOid": "986d061"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T02:22:58Z",
          "updatedAt": "2019-04-16T02:22:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We're keeping the list alphabetical, so please move your name up! :)",
              "createdAt": "2019-04-16T02:22:58Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3MzMzODM2",
          "commit": {
            "abbreviatedOid": "1b20fdf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T17:17:34Z",
          "updatedAt": "2019-04-16T17:17:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done\r\n",
              "createdAt": "2019-04-16T17:17:35Z",
              "updatedAt": "2019-04-16T17:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0MjM5Mjc1",
      "title": "omnibus: new hash2curve ; undefined cases ; sign issues ; etc.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/104",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hello folks,\r\n\r\nUPDATE (20190430): at this point most of the work is done, barring decisions on how to proceed. Please see specific notes on the checkbox items below.\r\n\r\nThanks again for all of your hard work on this standardization effort!\r\n\r\nThis is a WIP pull request that rolls up a bunch of edits addressing a few open issues. I'm sharing now to start getting feedback and to start discussing how to handle some of the remaining open questions.\r\n\r\nI look forward to your feedback! And, of course, I'm happy to split this up into multiple PRs, squash commits, etc. as you prefer.\r\n\r\nThe issues that this PR touches are:\r\n\r\n- [x] #52 - explicitly defined a primitive `inv0` in S3 that returns 0 on input 0. Could require impl via exponentiation as suggested in that issue. ~~**TODO** decide whether to require impl via exponentiation.~~ leave this unresolved in #52\r\n\r\n- [x] #54 - ~~this is WIP. Need to decide what to do for some of these.~~ I changed the way Simplified SWU and SvdW work to match with our suggestions in the paper, and I'm happy to suggest specific changes to the others. ~~**TODO** decide whether to hash to an extra bit for Elligator (supersingular)~~\r\nUPDATE (20190429): updated sign for SvdW\r\nUPDATE (20190430): suggested how to choose sign for all of them\r\n  - [x] sign for Simplified SWU\r\n  - [x] sign for Icart (need to check the paper on this)\r\n  - [x] sign for Elligator\r\n  - [x] sign for Elligator (Edwards)\r\n  - [x] sign for Elligator (supersingular)\r\n  - [x] sign for Boneh-Franklin\r\n  - [x] sign for SWU\r\n\r\n\r\n- [x] #79, #95 - I added a subsection in 5 that talks about multiplying by the cofactor. I'm happy to go through and make sure all impls do this. Probably it is worthwhile to make specific recommendations, especially for curves with big cofactors (e.g., both of the groups of BLS12-381).\r\n~~**TODO** need to decide whether the appx will have curve-specific impls, in which case this should go there for BLS12-381 G1 and G2.~~\r\n#111 should take care of this.\r\n  - [x] general discussion of cofactor clearing\r\n  - [x] cofactor clearing discussion for BLS12-381 G1\r\n  - [x] cofactor clearing discussion for BLS12-381 G2\r\n\r\n\r\n- [x] #82 - I defined a primitive `sgn0` that returns -1 if a point is \"negative,\" in a way that is defined for fields and extensions. This can be used everywhere for fixing a specific branch of sqrt.\r\nUPDATE (20190430): probably all of the decisions to be made are now in the sign of output point discussion\r\n\r\n- [x] #96 - added support in common.sage using tags \"BLS12_381_1\" and \"BLS12_381_2\" as Hoeteck suggested.\r\n\r\n\r\n- [x] #99 - added words suggesting how many extra bits to use. ~~Can strengthen this from a recommendation to a requirement.~~ ~~**TODO**: require rather than recommend number of extra bits?~~\r\n~~UPDATE (20190430): strengthened recommendations and made explicit how to use a \"small\" hash function~~\r\nLeave this unresolved in #99.\r\n\r\n- [x] #100 - ~~WIP, because I think probably what's currently in the Fouque-Tibouchi section needs to change a bit to make handling exceptional cases easier. I suggest following our recommendations in WB19; I'm planning to push an edit to this effect in the next couple days.~~\r\nUPDATE (20190429): renamed FT to \"Shallue-van de Woestijne,\" updated recommendations for constants and recovering from exceptional cases, added implementation for Secp256k1.\r\n\r\n\r\n- [x] #101 - rolls in a description of the algorithm and relevant implementations for both G1 and G2\r\n\r\n\r\n- [x] #102 - done. There aren't any curves for which you'd pick non-simplified over simplified SWU given the generalization in WB19.\r\n\r\n\r\n- [x] #103 - ~~WIP. I made explicit the way to handle exceptions for Icart, Elligator 2, and Simplified SWU. I still need to do so for the other variants of Elligator (Edwards and A0), the Boneh and Franklin method, and the Fouque-Tibouchi (I mentioned the latter above).~~\r\nUPDATE (20190429): handled for FT\r\nUPDATE (20190430): finished\r\n  - [x] Icart\r\n  - [x] Simplified SWU\r\n  - [x] Elligator\r\n  - [x] Elligator (Edwards)\r\n  - [x] Elligator (supersingular)\r\n  - [x] Boneh-Franklin\r\n  - [x] FT / SvdW\r\n\r\n- [x] ~~update test vectors in document~~ moved to #112 \r\n\r\n- [x] ~~add discussion of points-as-bitstrings relwork (Elligator, Elligator squared, binary Elligator squared)~~ moved to #113\r\n\r\n- [x] ~~consider moving detailed impls for each of the recommended curves to the appendix.~~ Moved to #111\r\n\r\n- [x] ~~consider removing some of the unused impls (e.g., ell2edwards, fouquetibouchi)~~ moved to #112 \r\n\r\n- [x] ~~hacspec impls for new encodings?~~ moved to #112",
      "createdAt": "2019-04-29T04:09:26Z",
      "updatedAt": "2019-05-21T21:38:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "29471b2ff1d0e4b0fadc7724b1a6f09277df8346",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "385d8282c81461e2bdd5009ffd83d6a82ec69a5b",
      "closedAt": "2019-05-21T21:38:02Z",
      "mergedAt": "2019-05-21T21:38:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "61fc31e9b152caa9ebd56f960b37df0f1da99180"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, yes: test vectors at the end of the file are not in sync with the changes here.\r\n\r\nTODO for later",
          "createdAt": "2019-04-29T04:13:48Z",
          "updatedAt": "2019-04-29T04:13:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "just pushed commits that more or less handle the open issues with FT12 (see updates marked 20190429 in original message).\r\n\r\nI renamed Fouque-Tibouchi to Shallue-van de Woestijne, which is I think the more correct terminology. But I want to be clear that I'm not ignoring Fouque and Tibouchi's contributions! I'm just trying to avoid confusion...",
          "createdAt": "2019-04-29T18:08:58Z",
          "updatedAt": "2019-04-29T18:09:11Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: I think at this point I've at least suggested how to address all of the above issues. I've updated the checklist accordingly.",
          "createdAt": "2019-05-01T04:14:33Z",
          "updatedAt": "2019-05-01T04:14:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Riad, I suggest you to make a cut-off here to review all the changes. Otherwise, the PR will get giant. I am going to review your changes.",
          "createdAt": "2019-05-02T16:01:30Z",
          "updatedAt": "2019-05-02T16:01:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good. Please let me know how I can make it easier! Happy to chat in person or on the phone.",
          "createdAt": "2019-05-02T18:37:20Z",
          "updatedAt": "2019-05-02T18:37:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I propose @armfazh and I review the PR and then we schedule a call for sometime next week to discuss any lingering issues. Will that work?",
          "createdAt": "2019-05-02T18:38:34Z",
          "updatedAt": "2019-05-02T18:38:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good. Meanwhile I'll hold off on pushing the change to hash2base that we discussed via email. It's relatively self-contained, so we can just do it in a separate PR.",
          "createdAt": "2019-05-02T18:40:36Z",
          "updatedAt": "2019-05-02T18:40:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I dealt with most of the nits, except for the ones that require some more discussion (see above).\r\n\r\nI think most of the remaining checkboxes in the first post of this thread either need a decision or should be pushed to their own issue (or both).\r\n\r\nOnce we've landed this I'll start whittling away at the new issues I just made, plus a suggestion for hash2base that we've previously discussed.",
          "createdAt": "2019-05-19T05:31:24Z",
          "updatedAt": "2019-05-19T05:31:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I was going over the impl and noticed a discrepancy with the cofactor clearing method for BLS12-381 G1. I pushed the (very small) fix.",
          "createdAt": "2019-05-21T20:53:07Z",
          "updatedAt": "2019-05-21T20:53:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's freeze the changes on this PR. Most of the items were addressed by @kwantam, who does a great job. During the review were raised some items in the form of issues. Let's move on with this PR as is, and the next time, let's update this document incrementally.",
          "createdAt": "2019-05-21T21:07:04Z",
          "updatedAt": "2019-05-21T21:07:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh @chris-wood before merging this PR I recommend that we go through and check the commit messages to make sure that they don't end up closing issues that should remain open.\r\n\r\nAlso, do you want me to squash this into one commit, or keep as-is?",
          "createdAt": "2019-05-21T21:14:58Z",
          "updatedAt": "2019-05-21T21:14:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, just checked. Merging as-is will close #99, #100, and #102. Of these, #99 should definitely remain open. We can either re-open manually or I can rewrite the commit history. Happy to do either, please let me know what you prefer.",
          "createdAt": "2019-05-21T21:19:07Z",
          "updatedAt": "2019-05-21T21:19:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Please rewrite the commit history closing only the solved tickets. \r\n\r\n",
          "createdAt": "2019-05-21T21:31:17Z",
          "updatedAt": "2019-05-21T21:31:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh done.",
          "createdAt": "2019-05-21T21:36:19Z",
          "updatedAt": "2019-05-21T21:36:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1ODc0NjIx",
          "commit": {
            "abbreviatedOid": "d6e0d67"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "First partial pass complete. More to come. Great stuff so far!",
          "createdAt": "2019-05-09T23:49:57Z",
          "updatedAt": "2019-05-10T00:16:14Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "nit: I'd revert this change since `m` is used as input to `F` and, to me, `m` reads better.",
              "createdAt": "2019-05-09T23:49:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 486,
              "body": "```suggestion\r\nIBE schemes {{BF01}}. When the required encoding is not clear, applications\r\n```",
              "createdAt": "2019-05-09T23:50:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 586,
              "body": "Do we want this to be constant time? If so, this doesn't achieve that, does it? (Runtime seems to be a function of `x_i`.)",
              "createdAt": "2019-05-09T23:55:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 638,
              "body": "```suggestion\r\nhash2base should map its input to a uniformly random element of F.\r\n```",
              "createdAt": "2019-05-09T23:56:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 651,
              "body": "nit: this should clarify that the results fo each invocation of H are concatenated, and point to the algorithm implementation below. (Maybe also label that section?)",
              "createdAt": "2019-05-09T23:57:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 731,
              "body": "nit: maybe reference the NIST curves as an example?",
              "createdAt": "2019-05-10T00:01:45Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 749,
              "body": "This paragraph ends on a cliffhanger! What is the trick? Is it specified? If not, perhaps this belongs in an appendix?",
              "createdAt": "2019-05-10T00:02:35Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 669,
              "body": "s/`msg`/`alpha` to be consistent with use of `hash2base` in the rest of the document?",
              "createdAt": "2019-05-10T00:03:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1005,
              "body": "nit: comment is not aligned with the others. Was that due to column overflow?",
              "createdAt": "2019-05-10T00:09:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTE1OTE2",
          "commit": {
            "abbreviatedOid": "d6e0d67"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T03:55:23Z",
          "updatedAt": "2019-05-10T03:55:24Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "Sure, that works. Or we can make it\r\n\r\n    F(k, msg) = k * H(msg)\r\n\r\nThe reason I went through getting rid of `m` in this context is because the document defines `q = p^m` elsewhere and I was hoping to avoid overloading.\r\n\r\nWhat do you think?",
              "createdAt": "2019-05-10T03:55:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTE5NjA2",
          "commit": {
            "abbreviatedOid": "896a906"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:20:54Z",
          "updatedAt": "2019-05-10T04:20:55Z",
          "comments": [
            {
              "originalPosition": 586,
              "body": "D'oh, great catch! I pushed a fix.",
              "createdAt": "2019-05-10T04:20:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTIwMDE5",
          "commit": {
            "abbreviatedOid": "e1a25a8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:23:41Z",
          "updatedAt": "2019-05-10T04:23:41Z",
          "comments": [
            {
              "originalPosition": 1005,
              "body": "Yes, was trying to prevent the HTML version from needing a horizontal scrollbar for this code snippet. Which style do you prefer?",
              "createdAt": "2019-05-10T04:23:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTIwNzU0",
          "commit": {
            "abbreviatedOid": "e1a25a8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:28:09Z",
          "updatedAt": "2019-05-10T04:28:10Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "Haha, sorry for the cliffhanger.\r\n\r\nAn appendix seems like the right place for this trick. Putting it here would probably be a big distraction.\r\n\r\nThis touches on something we can chat about next week: it seems like (maybe in the appx) we should give optimized implementations for the standard curves (whatever that means... but probably at least P256, secp256k1, Curve25519, Curve448, BLS12-381, ...). In that case, at least for BLS12-381 we'd also end up specifying how to clear the cofactor quickly.",
              "createdAt": "2019-05-10T04:28:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTIyMjIw",
          "commit": {
            "abbreviatedOid": "d3ce62f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:38:38Z",
          "updatedAt": "2019-05-10T04:38:38Z",
          "comments": [
            {
              "originalPosition": 651,
              "body": "Good catch! Done.",
              "createdAt": "2019-05-10T04:38:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTI2MDU0",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T05:04:11Z",
          "updatedAt": "2019-05-10T05:04:11Z",
          "comments": [
            {
              "originalPosition": 731,
              "body": "Good idea. Done.",
              "createdAt": "2019-05-10T05:04:11Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTI3MTA5",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T05:10:58Z",
          "updatedAt": "2019-05-10T05:10:58Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Sure. Is it OK if I roll this into the changes to hash2base that we discussed via email (referenced in a comment above)?",
              "createdAt": "2019-05-10T05:10:58Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTI3NTkw",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T05:13:56Z",
          "updatedAt": "2019-05-10T05:13:56Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Also: do you think a global msg -> alpha replacement, or just local to this definition?\r\n\r\n(Also, I suppose it's worth mentioning the other obvious option: we could do alpha -> msg instead...)",
              "createdAt": "2019-05-10T05:13:56Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM2MTY0OTcw",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T15:19:06Z",
          "updatedAt": "2019-05-10T15:19:07Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "Agreed -- let's go with your suggestion to avoid confusion! ",
              "createdAt": "2019-05-10T15:19:06Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM2MTY1NDUy",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T15:19:58Z",
          "updatedAt": "2019-05-10T15:19:58Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Hmm, I think just doing it locally is probably fine for now. Though I'm curious to hear what @armfazh and @samscott89 think.",
              "createdAt": "2019-05-10T15:19:58Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM2MTY1NjY3",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T15:20:21Z",
          "updatedAt": "2019-05-10T15:20:21Z",
          "comments": [
            {
              "originalPosition": 1005,
              "body": "Lack of overflow is best, so let's keep it as is.",
              "createdAt": "2019-05-10T15:20:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjE3NDU3",
          "commit": {
            "abbreviatedOid": "6f70a30"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T00:57:46Z",
          "updatedAt": "2019-05-19T00:57:47Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "Agreed!",
              "createdAt": "2019-05-19T00:57:47Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjE3NDk2",
          "commit": {
            "abbreviatedOid": "c66051f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "OK, this is a tremendously massive and ambitious PR. Many thanks, @kwantam! \r\n\r\nI went through the new BLS map2curve algorithm (from the paper) and I think it's correct. I went through the `q = 3 mod 4` Elligator2 implementation, too, and that seemed fine. I did not check the other optimized variants. My comments are mostly nits, with questions affecting perhaps the scope and structure of the document. We don't need to address them all here, so please feel free to file issues such that we can address them later if desired. ",
          "createdAt": "2019-05-19T01:00:06Z",
          "updatedAt": "2019-05-19T01:50:46Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "nit: missing terminal period",
              "createdAt": "2019-05-19T01:00:06Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 6,
              "body": "nit: missing spaces around `-` in `q-2`",
              "createdAt": "2019-05-19T01:31:26Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 53,
              "body": "nit: what happened to constant #2?",
              "createdAt": "2019-05-19T01:34:00Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 82,
              "body": "nit: missing spaces around `=` in `e2=True`",
              "createdAt": "2019-05-19T01:35:05Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 29,
              "body": "Perhaps we should re-write this section as a series of algorithms for the different conditions? That might help ease implementation should people choose to use one of them.",
              "createdAt": "2019-05-19T01:36:04Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 94,
              "body": "nit: missing spaces around `=`",
              "createdAt": "2019-05-19T01:37:14Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 98,
              "body": "nit: s/Elligator 2/Elligsator2",
              "createdAt": "2019-05-19T01:37:29Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 99,
              "body": "nit: missing spaces around `=`",
              "createdAt": "2019-05-19T01:41:07Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 157,
              "body": "Should we generalize the Montgomery->Edwards point conversion function? (I would have benefited from such a function being written in cleartext *somewhere* earlier this year.) We might then also include conversion from, say, Weierstrass to Montgomery, among others.",
              "createdAt": "2019-05-19T01:45:50Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 34,
              "body": "Unrelated to your change, but can we rename this to `hash2curve`? (I would now assume that hash implies RO functionality. Does it have the same meaning for you?)",
              "createdAt": "2019-05-19T01:47:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 9,
              "body": "Should we add a matching Python/Sage implementation? (Not in this PR -- we can do that in a separate one.)",
              "createdAt": "2019-05-19T01:48:08Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 5,
              "body": "nit: perhaps put parentheses around `W * b` for clarity?",
              "createdAt": "2019-05-19T01:48:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIwOTg2",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T04:51:57Z",
          "updatedAt": "2019-05-19T04:51:57Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I think I've cleaned all these up now.",
              "createdAt": "2019-05-19T04:51:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMDEy",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T04:53:25Z",
          "updatedAt": "2019-05-19T04:53:25Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "It looks like in the other impls, named constants are just used directly. In other words, rather than using `c2 = Z`, other impls just use `Z` directly. I did the same here, which killed the old `c2`, and just forgot to renumber.\r\n\r\nDo we want to revisit this style decision throughout?",
              "createdAt": "2019-05-19T04:53:25Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTA2",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T04:59:20Z",
          "updatedAt": "2019-05-19T04:59:21Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "this seems to be a pervasive issue that I didn't quite manage to fix. I opened #105 about this, because fixing all of them would be a pretty huge diff to tack on to this one.",
              "createdAt": "2019-05-19T04:59:20Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTIx",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:00:45Z",
          "updatedAt": "2019-05-19T05:00:46Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "The Elligator paper puts a space between \"Elligator\" and \"2\", and I tried to be consistent with that.\r\n\r\nIf your preference is to remove the space everywhere, I'm happy to open another issue.",
              "createdAt": "2019-05-19T05:00:45Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTI0",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:01:11Z",
          "updatedAt": "2019-05-19T05:01:11Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Opened #105 to decide on fix and handle document-wide.",
              "createdAt": "2019-05-19T05:01:11Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTcx",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:04:41Z",
          "updatedAt": "2019-05-19T05:04:41Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Created #106 ",
              "createdAt": "2019-05-19T05:04:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMzUy",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:15:42Z",
          "updatedAt": "2019-05-19T05:15:42Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Opened #107 about this\r\n\r\nNote that while Montgomery -> Weierstrass is easy, the opposite isn't guaranteed to exist, but it's relatively easy to write down the necessary and sufficient conditions for its existence (due to [Okeya, Kurumatani, and Sakurai, PKC 2000](https://doi.org/10.1007%2F978-3-540-46588-1_17))",
              "createdAt": "2019-05-19T05:15:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxNTQ1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:26:42Z",
          "updatedAt": "2019-05-19T05:26:42Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "That makes sense. The version I added to common.sage for this PR gives the same answer but probably ends up obfuscated for trying to be too clever.\r\n\r\nI added #108 for this.",
              "createdAt": "2019-05-19T05:26:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5NTY2MzQ3",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-20T15:17:37Z",
          "updatedAt": "2019-05-20T15:17:37Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Ah, sorry, I meant that the list of constants is missing a second item! It has #1 and #3.",
              "createdAt": "2019-05-20T15:17:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5NzQ4NjA5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This PR has a lot of changes. \r\nI posted some questions for some issues must be discussed.\r\nI didn't check the sage files, I only focused on the main document.",
          "createdAt": "2019-05-20T22:20:37Z",
          "updatedAt": "2019-05-21T02:01:27Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "This is the full name \"Progress in Cryptology - LATINCRYPT 2012\"",
              "createdAt": "2019-05-20T22:20:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 181,
              "body": "Unfortunately, this must be an ASCII document.",
              "createdAt": "2019-05-20T22:21:55Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 447,
              "body": "i.e., as ~~vectors of~~ m elements of GF(p) ~~where vector elements are~~ written in ascending order",
              "createdAt": "2019-05-20T22:31:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 455,
              "body": "~~Each of these forms defines a category of curve equations that is sometimes called a \"curve shape.\"~~",
              "createdAt": "2019-05-20T22:34:44Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 462,
              "body": "~~non-negative~~",
              "createdAt": "2019-05-20T22:37:16Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 465,
              "body": "This line must refer to the points on the curve that have order multiple of `r`. Thus, by multiplying by `h` will give us a point `hP` that is in the subgroup of order `r`.\r\n",
              "createdAt": "2019-05-20T22:43:12Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 469,
              "body": " the curve ~~shape~~ form",
              "createdAt": "2019-05-20T22:43:43Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 29,
              "body": "Regarding square-root calculation.\r\n\r\nWe have faced the problem of root selection vs fixed algorithm for calculating square roots. Each method has pros/cons, but in my opinion the easiest way is to calculate the root and then select one using, for example, the `sign` function.\r\n\r\nSince we cannot cover all the cases for sqrt, the definition of the `sqrt` function should be simpler. The algorithms for the well-known cases could be attached in an appendix.\r\n\r\n\r\n\r\n",
              "createdAt": "2019-05-21T00:40:52Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 582,
              "body": "s/sgn0/sgn/\r\n\r\nThe classic definition sets `sgn(0)=0` easing the implementation of `sgn` for extension fields.\r\n\r\nIf required, other predicates such as `isNegative(x)= {true, false}` can be defined on top of the `sgn` function.",
              "createdAt": "2019-05-21T00:45:07Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 585,
              "body": "~~See {{bg-curves}} for a discussion of representing x as a vector.~~",
              "createdAt": "2019-05-21T00:45:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 593,
              "body": "-1,0,1",
              "createdAt": "2019-05-21T00:45:55Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 9,
              "body": "It is desired that the sage files contain explicit and easily to understand implementations. We can work on this in a further PR.",
              "createdAt": "2019-05-21T00:47:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 9,
              "body": "It maybe better to have a pseudo-code description (using `if`/`else`, if required) and then a constant-time implementation of it (using CMOV).",
              "createdAt": "2019-05-21T00:49:01Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 607,
              "body": "\r\nThis can be stated as: \r\n > This function extends the definition of a multiplicative inverse for all F by fixing inv(0) = 0.",
              "createdAt": "2019-05-21T00:51:52Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 641,
              "body": "I noticed the change `m` -> `msg` however, I prefer to use a variable, since the content is an arbitrary string. In fact, the random oracle construction modifies the actual input of the hash2base, e.g., hash2base(m || 0).",
              "createdAt": "2019-05-21T00:55:04Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 646,
              "body": "This paragraph can be removed.",
              "createdAt": "2019-05-21T00:58:00Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 713,
              "body": "I am not agree with this implementation. \r\n\r\nThe concatenation of hash outputs does not produce a stronger hash output. \r\n\r\n\r\n",
              "createdAt": "2019-05-21T01:02:34Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 661,
              "body": "As mentioned in #99, it is required a hash function that outputs at least k more bits than the size of the prime, where k is the security parameter.\r\n\r\nA problem that arises is to find large enough hash functions for large curves. We can think on including XOF in replacement. This topic can be moved to the main list seeking for guidance.\r\n\r\n\r\n",
              "createdAt": "2019-05-21T01:12:40Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 673,
              "body": " Pre-hashing must be done at a higher level by the user of a hashing suite. At this point, the definition of hash2base must be as generic as possible.",
              "createdAt": "2019-05-21T01:14:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 669,
              "body": "I prefer to use short variable names. \r\nHere there is no message unlike the case of encryption or signatures.\r\n`msg` could be the initial input at the very top level.",
              "createdAt": "2019-05-21T01:17:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 713,
              "body": "For example \r\nSHA256(X||0) || SHA256(X||1)\r\nis not equal to \r\nSHA512(X)\r\nin the sense of **security**.\r\n",
              "createdAt": "2019-05-21T01:18:39Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 713,
              "body": "It is hard to tell now a better approach. \r\nFor 256-bit fields, one can use either SHA384 or SHA512. However, for larger fields larger hashes are required.",
              "createdAt": "2019-05-21T01:22:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 739,
              "body": "This section can be more general for example: `Map To Subgroup`\r\nbecause this step ensures that the point obtained by the encoding is in the subgroup of order `r`.\r\n\r\nThere are three techniques to do that which are not strictly multiplication by `h`:\r\n1. The trivial h=1, it does nothing. (The case of prime order curves.)\r\n2. The classical, cofactor clearing, is exactly multiplying P times h. (Most of the cases.)\r\n3. The one used for pairing curves, which is multiplying P by h*c for some integer c. (the variants of Scott, Fuentes, and Budroni and recently the Scott trick in Wahby's paper.)\r\n\r\nHence, `Map To Subgroup` can be described as a more general task for sending points to a prime subgroup.\r\n\r\n\r\n\r\n",
              "createdAt": "2019-05-21T01:29:45Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 749,
              "body": "I think at this point, the draft should mention or give pointer to the algorithms. \r\nThe description of the actual algorithms seems to me is out of the scope of this draft. (maybe in the pairing draft is a good place) or attaching them on an appendix.",
              "createdAt": "2019-05-21T01:32:31Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 771,
              "body": "I am totally agree with this approach, however I think we must emphasize why this decision was taken and it is not arbitrary.",
              "createdAt": "2019-05-21T01:35:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 780,
              "body": "This can be rephrased with something like this.\r\n> Some encodings (as described in the literature) have exceptional cases. However, this section presents some modifications on top of the encodings that have no exceptional cases.",
              "createdAt": "2019-05-21T01:38:03Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 816,
              "body": "This can be changed by setting the proper `y`-coordinate at the end.\r\nFor example, \r\n`y = sgn(u) * y`\r\nin the cases were applies.",
              "createdAt": "2019-05-21T01:40:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 819,
              "body": "Previously was mentioned that the encodings presented will have no exceptions. Hence, this section can introduce some misunderstanding. It is better to handle the exceptions internally though arithmetic operations and remove this section.\r\nThis applies for all the encodings.",
              "createdAt": "2019-05-21T01:42:09Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 835,
              "body": "As I suggested to use a more general section called `map to Subgroup`\r\nI think it is ok to return only the (x,y) coordinates. As the `mapping to subgroup` function is dependent of the curve, hence this can be specified per suite basis.",
              "createdAt": "2019-05-21T01:45:04Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1100,
              "body": "Elligator 2 method applies for any field. I do not see any difference between making special cases for 3 mod 4 and 5 mod 8. The only change is the calculation of the square-root, which must be handled by the `sqrt` function defined above.\r\n",
              "createdAt": "2019-05-21T01:49:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1263,
              "body": "I do not understand why the previous version was changed?\r\nThe previous formulas directly compute a point in a twisted Edwards curve.\r\n",
              "createdAt": "2019-05-21T01:51:49Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 157,
              "body": "I think that conversions are well-known, hence pointers to the original papers should be enough.",
              "createdAt": "2019-05-21T01:53:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1436,
              "body": "Maybe some curious reader can ask why to fix to a positive root.",
              "createdAt": "2019-05-21T01:55:19Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 2071,
              "body": "I am not sure whether this description is in the scope of hash2curve draft.",
              "createdAt": "2019-05-21T01:59:34Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODIyOTA2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:45:47Z",
          "updatedAt": "2019-05-21T04:45:47Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "@armfazh agreed, this seems like a possible option. The only issue is, it's not obvious (to me) what the overall intent is. To be explicit, it seems like there are two options:\r\n\r\n1. For each of a set of curves that are \"of interest\" (i.e., in common use---obviously Curve25519, but perhaps also BLS12-381...) give a full description of an optimized hash-to-curve implementation.\r\n\r\n2. Describe the maps in a general way and leave implementors to \"figure out the details\" for the curves they care about.\r\n\r\nFrom my perspective, (1) seems pretty workable---there are only a few curves that anyone will realistically use, and if this document is geared toward implementors, then they will appreciate being told in a careful way how to get good performance right off the bat.",
              "createdAt": "2019-05-21T04:45:47Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODIzMTk2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:47:14Z",
          "updatedAt": "2019-05-21T04:47:14Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "How about we take this into a separate issue / discussion / PR? It would be good to settle on conventions throughout the document (variable names, spacing, etc.), and that's more or less orthogonal to settling on the content.",
              "createdAt": "2019-05-21T04:47:14Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODIzMjc5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:47:29Z",
          "updatedAt": "2019-05-21T04:47:30Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Got it. Thanks, fixed!",
              "createdAt": "2019-05-21T04:47:29Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI0MDA0",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:50:57Z",
          "updatedAt": "2019-05-21T04:50:58Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Sure, that's fine. From my perspective it's somewhat nonstandard to write out the full conference name---there's no ambiguity, certainly---but I have no particular objections.",
              "createdAt": "2019-05-21T04:50:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI1NTk3",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:59:48Z",
          "updatedAt": "2019-05-21T04:59:48Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "Sorry, that's not quite correct.\r\n\r\nThe reason is that the implementations described here are optimized in a way that makes non-black-box use of the sqrt function. See lines 13--16 of this algorithm description, and compare with lines 10--19 of the algorithm for p = 5 mod 8. This optimization is described in the 3rd paragraph of Section 5.5 of the Elligator paper.\r\n\r\nI think there's a higher-level issue to be discussed here, which I also mentioned in a response above: does this document want to be a general guide for these algorithms, or does it want to give specific implementation advice for curves of interest? If the latter, then these should be broken out and treated separately, because sqrt() is not just a black box here.\r\n\r\nBy the way, the same is true for Simplified SWU: one can avoid computing a second square root with non-black-box use of sqrt().\r\n\r\nOne final thought: if this document ends up describing algorithms for projective coordinates (which are better from an efficiency perspective), then there will be even more non-black-box use of sqrt to avoid taking multiplicative inverses.\r\n\r\nFrom my perspective, giving implementors the best possible implementations will make this document most useful to them. But of course there are plenty of arguments in both directions.",
              "createdAt": "2019-05-21T04:59:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI2MTI1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:02:46Z",
          "updatedAt": "2019-05-21T05:02:46Z",
          "comments": [
            {
              "originalPosition": 1263,
              "body": "The reason I suggest making this change is because the prior version was incredibly inefficient---it requires something like five exponentiations. This one requires at the very worst three, and that can be reduced to just one if implemented in projective coordinates.\r\n\r\nBeyond that, using the same mapping for Montgomery and Edwards means that the same implementation can be used for multiple purposes, which is a pretty clear win from a practical perspective.",
              "createdAt": "2019-05-21T05:02:46Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI2NTY2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:05:06Z",
          "updatedAt": "2019-05-21T05:05:06Z",
          "comments": [
            {
              "originalPosition": 1436,
              "body": "You're totally right---what I wrote here doesn't make any sense. Just like in the other cases, this one should set sgn0(u) == sgn0(y). I will push a fix for this.",
              "createdAt": "2019-05-21T05:05:06Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI3MjA0",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:08:21Z",
          "updatedAt": "2019-05-21T05:08:22Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "You're totally right. I added this for completeness, but it may be that this section should go.\r\n\r\nThe argument in favor of having it is that the description of applying Simplified SWU to pairing-friendly curves is maybe incomplete without something along these lines. But on the other hand, that might be OK---implementors aren't likely to be doing this kind of thing for themselves, and the document can just include the isogeny maps for the curves it covers (e.g., BLS12-381).",
              "createdAt": "2019-05-21T05:08:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI3ODI5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:11:28Z",
          "updatedAt": "2019-05-21T05:11:29Z",
          "comments": [
            {
              "originalPosition": 465,
              "body": "Sorry, I don't quite understand the issue here. Can you please explain?\r\n\r\nMultiplying any point by h will return a point in the subgroup of order r. Of course, it might return the identity point, but that's fine---it's also in the subgroup. So it's not obvious to me why it's necessary to talk about points having order a multiple of r.\r\n\r\nSorry if I'm not understanding...",
              "createdAt": "2019-05-21T05:11:28Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI4MzQ0",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:14:15Z",
          "updatedAt": "2019-05-21T05:14:16Z",
          "comments": [
            {
              "originalPosition": 582,
              "body": "I'm aware that the definition of `sgn` returns 0 for 0, but that's not the intent here.\r\n\r\nThe reason I called this `sgn0` is, there is never a need to have a separate case for the sign of 0, nor is there a need for a separate `isNegative` function.\r\n\r\nOf course I'm happy to rename the function to `isNegative` if that seems more reasonable! The point is just that there's no need for a true signum function. The reason for `sgn0` is that it dovetails nicely with `inv0`---in both cases, the appended `0` is indicating \"this function does something slightly special with 0\".",
              "createdAt": "2019-05-21T05:14:16Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI4NjQz",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:15:55Z",
          "updatedAt": "2019-05-21T05:15:56Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Pardon, but why get rid of the reference? It seems reasonable as a way to avoid confusion here.",
              "createdAt": "2019-05-21T05:15:56Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI4Njc2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:16:09Z",
          "updatedAt": "2019-05-21T05:16:10Z",
          "comments": [
            {
              "originalPosition": 593,
              "body": "See comment above. This is not a signum function.",
              "createdAt": "2019-05-21T05:16:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI5MDU1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:18:14Z",
          "updatedAt": "2019-05-21T05:18:14Z",
          "comments": [
            {
              "originalPosition": 641,
              "body": "In another comment I proposed to leave questions of variable naming and other conventions to a separate issue and discussion. If that's OK, I'll make an issue for it.\r\n\r\nThe reason I suggested avoiding `m` is that this name is already used for the extension field degree, and I was hoping to avoid overloading variable names.",
              "createdAt": "2019-05-21T05:18:14Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM1MDkx",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:48:24Z",
          "updatedAt": "2019-05-21T05:48:24Z",
          "comments": [
            {
              "originalPosition": 713,
              "body": "Pardon, but this comment appears to be false.\r\n\r\nThe reason is that here we are modeling H as a PRF, so the difference in collision resistance doesn't apply. And of course, concatenating two outputs of a PRF *does* give more (pseudo)randomness, which is all that's required here---the point is just to produce an element of GF(p) indistinguishable from uniformly random.\r\n\r\nExpanding a bit, obviously if we model H as a random oracle there's no practical distinction between two evaluations of SHA256 and one of SHA512. In terms of concrete security, I am not aware of any work on the concrete security of using any member of the SHA-2 family as a PRF, but in general it appears that most practical work treats SHA256 as a 256-bit-secure PRF, which is more than adequate even for Ed448, the highest-security curve mentioned anywhere in this document.\r\n\r\nAnecdotally, the consensus of the BLS signatures working group in a discussion a couple weeks ago was that using 2 evaluations of SHA256 was preferable to 1 evaluation of SHA512.",
              "createdAt": "2019-05-21T05:48:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM1NzYy",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:51:23Z",
          "updatedAt": "2019-05-21T05:51:23Z",
          "comments": [
            {
              "originalPosition": 661,
              "body": "See my comment above. Under standard assumptions it's just not necessary to use a hash with a wide output.\r\n\r\nIn any case, this document is probably not the right place to make recommendations about which hash functions to use as PRFs, and almost certainly not a place to start recommending little-used constructions like SHAKE.",
              "createdAt": "2019-05-21T05:51:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM2MjY1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:53:35Z",
          "updatedAt": "2019-05-21T05:53:36Z",
          "comments": [
            {
              "originalPosition": 673,
              "body": "I agree.\r\n\r\nI've got a separate PR waiting to go that tries to make hash2base easy to implement and as generic as possible. I suggest we delay this discussion until that PR.",
              "createdAt": "2019-05-21T05:53:36Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM3MDg5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:56:59Z",
          "updatedAt": "2019-05-21T05:57:00Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "That's a good point.\r\n\r\nOn the other hand, \"clearing the cofactor\" is essentially standard terminology. It might be confusing to make up alternate terminology.",
              "createdAt": "2019-05-21T05:57:00Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM3OTgz",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:00:39Z",
          "updatedAt": "2019-05-21T06:00:39Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "Great point. Are there specific reasons you think we should mention here?\r\n\r\nOff the top of my head, the logic might be:\r\n\r\n- *somewhere* need to make an arbitrary decision about how to make sqrt() a function,\r\n- can do that by specifying sqrt(), but that requires case-by-case for different field characteristics and might end up making sqrt implementations more complex / less efficient\r\n- instead, specify sign at the output, which ensures that everyone agrees while being the least prescriptive in terms of implementation\r\n\r\nIf the above reasoning seems good, I'm happy to turn it into prose.",
              "createdAt": "2019-05-21T06:00:39Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM4NzY5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:03:57Z",
          "updatedAt": "2019-05-21T06:03:57Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "I don't think it's necessary (or advisable) to change the sign of y, since the encoding is unambiguous.",
              "createdAt": "2019-05-21T06:03:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQxMjIy",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:13:33Z",
          "updatedAt": "2019-05-21T06:13:34Z",
          "comments": [
            {
              "originalPosition": 780,
              "body": "I took a stab at clarifying and cleaning up.",
              "createdAt": "2019-05-21T06:13:33Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQxOTIy",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:16:24Z",
          "updatedAt": "2019-05-21T06:16:24Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "Ah, I see your point.\r\n\r\nThe text currently in `{{map-exceptions}}` says \"we discuss the exceptional cases and show how to handle them in constant time.\"\r\n\r\nIf the preference is to get rid of the explicit discussion and just tweak the maps, that's fine. But it might be nice to make explicit the tweaks and the reasons for them, otherwise readers might wonder why the descriptions in this document differ from the published algorithms...",
              "createdAt": "2019-05-21T06:16:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQyMjQx",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:17:40Z",
          "updatedAt": "2019-05-21T06:17:41Z",
          "comments": [
            {
              "originalPosition": 835,
              "body": "Happy to make this change.\r\n\r\nI was following the existing convention in the document, which was to return h * (x, y). But I think you're right that it's probably confusing to say this when most of the time it's not actually what implementors will do!",
              "createdAt": "2019-05-21T06:17:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQ1MTg2",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:28:22Z",
          "updatedAt": "2019-05-21T06:28:23Z",
          "comments": [
            {
              "originalPosition": 1436,
              "body": "Done now.",
              "createdAt": "2019-05-21T06:28:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTA3MDU1",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T08:50:54Z",
          "updatedAt": "2019-05-21T08:50:54Z",
          "comments": [
            {
              "originalPosition": 465,
              "body": "In this line of the document it seems that cofactor clearing only works for points that are not in the prime-order subgroup. \r\nI was trying to be more general saying that cofactor clearing works for any point in the curve.\r\n",
              "createdAt": "2019-05-21T08:50:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTExNzQ5",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T08:59:26Z",
          "updatedAt": "2019-05-21T08:59:26Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "It was already stated how to represent elements. ",
              "createdAt": "2019-05-21T08:59:26Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTE0MTEw",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T09:03:44Z",
          "updatedAt": "2019-05-21T09:03:44Z",
          "comments": [
            {
              "originalPosition": 641,
              "body": "Good catch! m is used for the extension fields. Let's use another name.",
              "createdAt": "2019-05-21T09:03:44Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTM4MDk3",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T09:47:47Z",
          "updatedAt": "2019-05-21T09:47:48Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "We can stay with clearing the cofactor and making the observation that clearing the cofactor for pairing curves is different from a straightforward multiplication by h.",
              "createdAt": "2019-05-21T09:47:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTQ2Nzg3",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:04:32Z",
          "updatedAt": "2019-05-21T10:04:33Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "I am agree with that. You can also use the following ideas for using a root-selection method rather than fixed algorithms for sqrt are:\r\n1) covering all fields is complicated (as you mention this will require going case-per-case)\r\n2) there is no restriction for changing the underlying algorithm that calculates sqrt(). (I am optimistic that in the future there could be improvements on the calculation of sqrt )\r\n3) using a predicate to select a principal root can be done easily by using the sgn() function.\r\n\r\n",
              "createdAt": "2019-05-21T10:04:32Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTQ4NTc1",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:08:23Z",
          "updatedAt": "2019-05-21T10:08:24Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "My observation is that the mini-section \"Sign of y: .... \"  can be omitted, and make the desired changes in the sign of y internally in the algorithm. \r\n",
              "createdAt": "2019-05-21T10:08:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTUxODYy",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:15:48Z",
          "updatedAt": "2019-05-21T10:15:48Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "Ideally, the tweaks and the related discussion can be summarized in a supportive short paper, which can be released on eprint. I am happy to collaborate with that. ",
              "createdAt": "2019-05-21T10:15:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTYwODgw",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:34:53Z",
          "updatedAt": "2019-05-21T10:34:53Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "One can make the distinction between algorithm and implementation.\r\nAs you can see, in the document there is a short description using black-box functions and non-constant time pseudo-code, and then, it is followed by a constant-time implementation. This short description must be enough to be used by anyone on the specified curve.\r\n\r\nAlso I am aware that by unboxing functions and working on projective coordinates allows more optimization tricks, and definitely, this is more useful for implementors. However, we need to figure out in which part of the draft to include the optimized versions.\r\n\r\n  \r\n\r\n\r\n\r\n",
              "createdAt": "2019-05-21T10:34:53Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjE4NjI1",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:17:37Z",
          "updatedAt": "2019-05-21T18:17:38Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Created Issue #110.",
              "createdAt": "2019-05-21T18:17:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjE5Mjcz",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:18:54Z",
          "updatedAt": "2019-05-21T18:18:54Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Noted in issue #105, which deals with spacing.",
              "createdAt": "2019-05-21T18:18:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjIxNzI5",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:23:32Z",
          "updatedAt": "2019-05-21T18:23:33Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Sorry, I don't see it. Where was this stated locally? It looks like the only place that it's described is in the referenced section ({{bg-curves}}), which is why I'm proposing a crossref here---to make the document easier to read.",
              "createdAt": "2019-05-21T18:23:32Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjIyMjEz",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:24:27Z",
          "updatedAt": "2019-05-21T18:24:27Z",
          "comments": [
            {
              "originalPosition": 641,
              "body": "Cool. I created issue #110 for this.",
              "createdAt": "2019-05-21T18:24:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjM2ODQx",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:52:54Z",
          "updatedAt": "2019-05-21T18:52:54Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "Great, this makes sense.\r\n\r\nI've pushed a commit that I believe addresses this comment:\r\n\r\n1. it clarifies the three cases that @armfazh lists above,\r\n2. it defines a new abstract function `clear_h(x, y)` that represents cofactor clearing, and\r\n3. it replaces `Output h * (x, y)` with `clear_h(x, y)` in the descriptions of the implementations.",
              "createdAt": "2019-05-21T18:52:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQwMzA5",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:59:41Z",
          "updatedAt": "2019-05-21T18:59:41Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "> Wahby and Boneh ([WB19], Section 5) describe a trick due to Scott for faster cofactor clearing on any elliptic curve for which the prime factorization of h and the number of points on the curve meet certain conditions.\r\n\r\n@kwantam  Quick question: does your method is particular to pairing-friendly curves? If so, then the paragraph should be merged.",
              "createdAt": "2019-05-21T18:59:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQxNzUx",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:02:42Z",
          "updatedAt": "2019-05-21T19:02:43Z",
          "comments": [
            {
              "originalPosition": 582,
              "body": "Ok, I am agree with that. \r\nIn fact, the signum is actually computed, and at the very end it sets sgn(x)=1  if x=0.\r\n",
              "createdAt": "2019-05-21T19:02:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQyNDQw",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:04:10Z",
          "updatedAt": "2019-05-21T19:04:10Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "That's fine, let's move on.",
              "createdAt": "2019-05-21T19:04:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ2MjIy",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:12:20Z",
          "updatedAt": "2019-05-21T19:12:20Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "Note that after #111 these `clear_h()` operations should be revisited.",
              "createdAt": "2019-05-21T19:12:20Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ3OTc3",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:16:20Z",
          "updatedAt": "2019-05-21T19:16:20Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "The high-level descriptions and straight-line procedures *do* implement the sign changes. So is the suggestion to remove the explanation here?\r\n\r\nI'm in favor of explicitly documenting decisions like this (and exceptional cases) rather than making them implicit in the algorithm, since that gives an opportunity to explain the rationale for the decision and documents departures from the algorithms described in the literature.\r\n\r\n@armfazh suggests in another comment that these decisions could be documented separately, say, on ePrint. That certainly could work! but to me it seems better to make the document self-contained to the greatest extent possible.",
              "createdAt": "2019-05-21T19:16:20Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ4NTY0",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:17:43Z",
          "updatedAt": "2019-05-21T19:17:44Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "(see comment above. I can see this working, but it's not clear to me why that's preferable to creating a self-contained document that explains its decisions)",
              "createdAt": "2019-05-21T19:17:44Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ4ODk5",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:18:28Z",
          "updatedAt": "2019-05-21T19:18:28Z",
          "comments": [
            {
              "originalPosition": 835,
              "body": "See above: pushed a commit that partially addresses this. I think it's worth revisiting this after #111 is settled.",
              "createdAt": "2019-05-21T19:18:28Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjUwNjc2",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:22:21Z",
          "updatedAt": "2019-05-21T19:22:21Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "I agree about the distinction between algorithm and implementation. The *algorithm*, a few lines above, is fully black-box. The two *implementations* (for p = 3 mod 4 and p = 5 mod 8) make non-black-box use. So we seem to be in agreement.\r\n\r\nI agree with you that we need to make a decision about optimized versions. I created a new issue, #111, for this. I'll write a specific proposal there in the near future.",
              "createdAt": "2019-05-21T19:22:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjU5NDU2",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:41:15Z",
          "updatedAt": "2019-05-21T19:41:16Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "I've slightly expanded and clarified the justification here.",
              "createdAt": "2019-05-21T19:41:15Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjYyNTc1",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:47:58Z",
          "updatedAt": "2019-05-21T19:47:59Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "No, it applies to any curve meeting the (un)specified conditions. Probably it's *most useful* in the context of pairing-friendly curves, since most non-pairing-friendly curves have very small cofactors, and thus clearing the cofactor isn't particularly expensive...",
              "createdAt": "2019-05-21T19:47:58Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjYzNjIw",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:50:16Z",
          "updatedAt": "2019-05-21T19:50:16Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "Good work.",
              "createdAt": "2019-05-21T19:50:16Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjY4MTU2",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:59:48Z",
          "updatedAt": "2019-05-21T19:59:49Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "LGTM",
              "createdAt": "2019-05-21T19:59:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjc0MzE4",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:13:05Z",
          "updatedAt": "2019-05-21T20:13:06Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "There is a section that is missing to be written, which is the instantiations of suites. In such a section, draft must specify all the parameters for a given curve. \r\nFor example, the suite correspondent to BLS12-381 will state which isogeny was used and all other relevant parameters.",
              "createdAt": "2019-05-21T20:13:05Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjgwMTg4",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:24:57Z",
          "updatedAt": "2019-05-21T20:24:57Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "Let's keep the full descriptions for the cases were are required.",
              "createdAt": "2019-05-21T20:24:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk0Njkx",
          "commit": {
            "abbreviatedOid": "6324739"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:54:37Z",
          "updatedAt": "2019-05-21T20:54:38Z",
          "comments": [
            {
              "originalPosition": 713,
              "body": "Move this topic to #99 ",
              "createdAt": "2019-05-21T20:54:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk0NzMy",
          "commit": {
            "abbreviatedOid": "6324739"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:54:43Z",
          "updatedAt": "2019-05-21T20:54:43Z",
          "comments": [
            {
              "originalPosition": 661,
              "body": "Move this topic to #99 ",
              "createdAt": "2019-05-21T20:54:43Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk2MTYw",
          "commit": {
            "abbreviatedOid": "6324739"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:57:38Z",
          "updatedAt": "2019-05-21T20:57:38Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "Great. I made a note of this in #111. Next I'll push a commit that removes this text.",
              "createdAt": "2019-05-21T20:57:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk4MjE1",
          "commit": {
            "abbreviatedOid": "fe7df96"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T21:01:55Z",
          "updatedAt": "2019-05-21T21:01:55Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "(Done)",
              "createdAt": "2019-05-21T21:01:55Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk5MjEw",
          "commit": {
            "abbreviatedOid": "fe7df96"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-21T21:04:02Z",
          "updatedAt": "2019-05-21T21:04:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMzAwNDMx",
          "commit": {
            "abbreviatedOid": "fe7df96"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T21:06:33Z",
          "updatedAt": "2019-05-21T21:06:33Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "I think #111 comprehends this now. I've added a link to this conversation there.",
              "createdAt": "2019-05-21T21:06:33Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTU5MzQz",
      "title": "simplify / clarify sgn0 implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/114",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses one of @chris-wood's comments on #104 which is captured in #108 \r\n\r\nNOTE: this and #115  can rebase cleanly on top of one another, so if the preference is to keep a clean history we can sequence a merge->rebase->merge for these two.\r\n\r\ncloses #108",
      "createdAt": "2019-05-21T21:39:21Z",
      "updatedAt": "2019-06-03T22:32:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "029e677faf077a4ce3b454bef21f83227a9a03cf",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sgn0_impl",
      "headRefOid": "ea8c1aa870d8246a811fa36defba27f4a2cafb72",
      "closedAt": "2019-06-03T20:53:30Z",
      "mergedAt": "2019-06-03T20:53:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "938c005eed80c9c457727470e209dfda02546a92"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've just added another commit to this PR that updates the definition of sgn0, both in the code and in the document.\r\n\r\nThe effect of this change is to reverse the order in which vector elements are considered when computing sgn0. Previously the order was from least significant to most significant; with this change, the order is from most to least. Note that this change has no effect on elements of GF(p), only on elements of GF(p^m).\r\n\r\nThe reason for this change is to bring the document into agreement with existing conventions used by deployed implementations of BLS12-381.",
          "createdAt": "2019-05-29T20:16:25Z",
          "updatedAt": "2019-05-29T20:16:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This LGTM -- thanks!",
          "createdAt": "2019-06-03T20:53:09Z",
          "updatedAt": "2019-06-03T20:53:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTYwMDk4",
      "title": "split sqrt def'n by field characteristic",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/115",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This clarifies the definition of square roots as requested by @chris-wood's comment on #104 and captured in #106.\r\n\r\nSee note in #114 about sequencing merges and rebases to keep a clean commit history, if desired.\r\n\r\ncloses #106",
      "createdAt": "2019-05-21T21:42:10Z",
      "updatedAt": "2019-05-31T18:01:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "61fc31e9b152caa9ebd56f960b37df0f1da99180",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sqrt_clarification",
      "headRefOid": "b1805711be6db8ef2a2f1c711f30a580a1419e27",
      "closedAt": "2019-05-31T17:12:51Z",
      "mergedAt": "2019-05-31T17:12:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "412d5b1864dc62e7802090a8edb94c45c5b875aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDIwNTc2",
          "commit": {
            "abbreviatedOid": "b180571"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-05-31T17:11:11Z",
          "updatedAt": "2019-05-31T17:11:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTY2NDI5",
      "title": "hash2base update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/116",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates hash2base to use the same method described in the Pairing WG's BLS signatures [spec-v1](https://github.com/pairingwg/bls_standard/blob/master/minutes/spec-v1.md).\r\n\r\nExecutive summary:\r\n\r\nThe idea behind this change is that it makes it possible to call hash2base multiple times (for the random oracle construction) while hashing the input message exactly once. This avoids requiring applications to specify pre-hashing and also avoids requiring implementors to make non-black-box use of a hash function (e.g., computing a \"partial\" hash of a message and then \"finishing\" the hash in two different ways to get the two different evaluations for the random oracle construction).\r\n\r\nOne potential downside of this change is that it requires adding an argument `ctr` to all of the map2curve functions, which is \"passed through\" to hash2base. (This PR makes that change.) To address this slight ugliness, this PR makes `ctr` optional and defaults it to 0 if not specified. That way, one can still sensibly refer to a value like `map2curve(alpha)`.\r\n\r\nDetails:\r\n\r\nThe reasoning is as follows. In the current hash2base, one might want to call, say,\r\n\r\n    hash2base(msg || I2OSP(1, 1))\r\n    hash2base(msg || I2OSP(2, 1))\r\n\r\nand this results in computing, inside the hash2base calls,\r\n\r\n    m_prime_1 = H(msg || I2OSP(1, 1))\r\n    m_prime_2 = H(msg || I2OSP(2, 1))\r\n\r\nIf `msg` is long, this is inefficient. One way to avoid this is, as I mentioned above, to \"partially evaluate\" H on `msg`. But requiring implementors to make non-black-box use of H is undesirable, because it constrains their implementations (for example, what happens if your crypto library doesn't let you partially evaluate H?).\r\n\r\nThe other way to avoid this is to make applications pre-hash messages. That's fine, but requiring them to do that for efficiency is a little unfriendly, because it means that if they forget to specify pre-hashing in their protocol, they have to change the protocol to fix it.\r\n\r\nThis PR gives a third option: call\r\n\r\n    hash2base(msg, 1)\r\n    hash2base(msg, 2)\r\n\r\nThis results in computing, inside the hash2base calls,\r\n\r\n    m_prime_1 = H(msg) || I2OSP(1, 1)\r\n    m_prime_2 = H(msg) || I2OSP(2, 1)\r\n\r\nSince the concatenation is outside the call to H, both invocations of hash2base can share the same evaluation of `H(msg)`. This allows seamlessly optimizing the implementation of hash2base in a way that is guaranteed to be backward compatible, which means that applications do not have to worry about breaking changes that come as a result of pre-hashing.",
      "createdAt": "2019-05-21T22:06:47Z",
      "updatedAt": "2019-06-03T18:55:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "412d5b1864dc62e7802090a8edb94c45c5b875aa",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "hash2base_update",
      "headRefOid": "3267ff41c589c87be3df15a7791139d5764b473c",
      "closedAt": "2019-06-03T12:52:32Z",
      "mergedAt": "2019-06-03T12:52:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "029e677faf077a4ce3b454bef21f83227a9a03cf"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "As with #114 and #115, happy to rebase this as necessary to keep the commit history clean.",
          "createdAt": "2019-05-21T22:07:31Z",
          "updatedAt": "2019-05-21T22:07:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed an update that partially addresses [my comment in #99](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/99#issuecomment-495428394) regarding collision resistance.\r\n\r\nIt's not clear to me whether specific hash function recommendations should go in Section 4, elsewhere in the document, or nowhere in the document. Thoughts?",
          "createdAt": "2019-05-24T16:14:01Z",
          "updatedAt": "2019-05-24T16:14:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See my [inline comment](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#discussion_r289488785). At a high level, the improvement is in the sense that this version is easier to optimize for long messages.\r\n\r\nNote also that this change is motivated by \"user\" feedback: folks from the BLS signatures working group preferred this version specifically because it builds in the possibility of implementing a \"prehashed\" mode without changing application code or requiring partial evals of `H`.",
          "createdAt": "2019-05-31T17:51:44Z",
          "updatedAt": "2019-05-31T17:51:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've (I think) clarified the text. I will think carefully about how to incorporate @jedisct1's feedback, too (thanks!)",
          "createdAt": "2019-05-31T19:02:50Z",
          "updatedAt": "2019-05-31T19:02:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At a high level, the improvement is in the sense that this version is easier to optimize for long messages.\r\n\r\nI certainly don't disagree that it's an improvement in that sense. It's just that the description and implementation seemed not in alignment. Adopting @jedisct1 suggestion, and writing one in terms of the underlying helper, would make this more clear. ",
          "createdAt": "2019-05-31T19:10:27Z",
          "updatedAt": "2019-05-31T19:10:27Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought a bit more about this and have a couple questions/comments:\r\n\r\n1. Factoring H(msg) out of hash2base is strictly an optimization, and in many (probably most) cases not one that's going to make much difference in the end-to-end cost of hashing to the curve. So actually I think the common case is going to be the unoptimized version. But I'd argue it's still worthwhile to make this change: it's essentially free future proofing.\r\n\r\n2. It's not perfectly clear to me who the target audience is, but I'm guessing that for most people the optimization we're talking about here is rather trivial. If that's true, it further supports keeping the pseudocode simple: adding the optimization is probably a net loss in clarity for everyone, even people who would actually want to implement the optimization.\r\n\r\nGiven the above, my vote is to keep the simple version of the pseudocode in Section 4, and *maybe* add an appendix that makes the optimization explicit.",
          "createdAt": "2019-05-31T19:48:18Z",
          "updatedAt": "2019-05-31T19:48:18Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider that we must assume short-input messages for the function hash2base; this allows invoking H as many times as needed without performance issues. \r\nIn case of large messages, these messages can be pre-hashed by the caller of the cipher-suite.\r\nSee my proposal at #118 ",
          "createdAt": "2019-05-31T21:00:06Z",
          "updatedAt": "2019-05-31T21:03:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "![Image](https://github.com/armfazh/draft-sullivan-cfrg-hash-to-curve/blob/diagrams/drawings/desc.png)",
          "createdAt": "2019-05-31T21:02:41Z",
          "updatedAt": "2019-05-31T21:02:41Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Very useful diagram.\r\n\r\nBut `hash2field(s)` is as confusing as `hash2base(s)`. If the input is a string, the prefix of the function name shouldn't be `hash`.\r\n\r\nAlso, `hash2field(h(s))` and `hash2field_prehash(s)` produce the same output. This may be a problem if the former or the later are dynamically called according to the length of the `s`.",
          "createdAt": "2019-05-31T21:16:29Z",
          "updatedAt": "2019-05-31T21:16:49Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> But `hash2field(s)` is as confusing as `hash2base(s)`. If the input is a string, the prefix of the function name shouldn't be `hash`.\r\n\r\nWell, the function \r\n```\r\nXYZ : s -> U \r\n```\r\nconverts an string s (regardless its size) into an non-empty set of field elements U. Then, XYZ should be one-way and must behave as a random oracle in F. These two properties justify the name of hash2field. However, I am agree with any other meaningful name.\r\n \r\n\r\n\r\n",
          "createdAt": "2019-05-31T21:25:57Z",
          "updatedAt": "2019-05-31T21:25:57Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, `hash2field(h(s))` and `hash2field_prehash(s)` produce the same output. This may be a problem the former or the later are dynamically called according to the length of the `s`.\r\n\r\nThey do, however, my proposal is that `hash2field_prehash(s)` should not exist in the definition of the suite. \r\n\r\nA similar strategy as the one I propose is Ed25519 and Ed25519ph. Both signatures are in essence the same (except by domain separation strings).",
          "createdAt": "2019-05-31T21:26:30Z",
          "updatedAt": "2019-05-31T21:26:30Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> except by domain separation strings\r\n\r\nThis is what is missing here. How about `s = 0 || s` (if no prehashing is done) or `s = 1 || s` (after prehashing) before calling `hash2field()`?",
          "createdAt": "2019-05-31T21:34:34Z",
          "updatedAt": "2019-05-31T21:34:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about s = 0 || s (if no prehashing is done) or s = 1 || s (after prehashing) before calling hash2field()?\r\n\r\nI think we ought to first agree on whether or not prehashing is something the API or the caller should implement. @armfazh suggests its the caller's responsibility, whereas @kwantam suggests it be supported by the API (IIUC). (Hand waving specificity with what I mean by \"supported by the API\" here.) I think both are viable, though I'd prefer to do without additional complexity, and therefore slightly prefer @armfazh's proposal. ",
          "createdAt": "2019-05-31T21:55:16Z",
          "updatedAt": "2019-05-31T21:55:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Folks,\r\n\r\nI think this conversation is getting a bit far afield here.\r\n\r\nI agree with @armfazh that the suite should **not** specify a separate prehash mode. That's up to the application layer. Specifying it here subverts the abstraction.\r\n\r\n**But**: the whole point of this PR is to point out that *a prehash mode is not needed for efficiency*!\r\nThis is great! Everyone wins!\r\n\r\nWhy is this true? Because hash2base can easily be designed in a way that allows hashing the whole message only once, with essentially no effect on cost.\r\n\r\nHere are the facts:\r\n\r\n- There is *no* overhead for changing the specification of hash2base from what's currently in the document to what's in this PR.\r\n\r\n- The cost of what is currently in the document (and likewise what is in this PR) is *at most* one H invocation beyond the cost if we assumed that all messages are short (i.e., ~50 bytes). One H invocation is *nothing* compared to the cost of evaluating any of the map functions.\r\n\r\n- For messages of a few hundred bytes and essentially any reasonable parameter setting, what's currently in the document is *cheaper* than assuming messages are short. Again, this PR does not change that.\r\n\r\n- This PR is friendlier to applications built on top of it: an application layer that uses this version of hash2base never needs to prehash for performance, because it's possible (but not necessary) to implement a simple optimization. Of course, they can if they want to! but they can already get equivalent performance for free via this PR.",
          "createdAt": "2019-05-31T22:00:59Z",
          "updatedAt": "2019-05-31T22:03:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ach, one more thing.\r\n\r\nThe biggest downside of what's currently in this PR is that it means all of the `map2curve...` functions now take another parameter. But that's an artifact of the way that `map2curve` is currently specified, i.e., as `{0,1}* -> E`.\r\n\r\nWe can easily fix that by specifying all `map2curve...` functions as `F -> E`. In this case, to hash a string one calls `map2curve...(hash2base(string, ctr))`. From my perspective this is nicer anyway: it more closely matches the way that the literature describes these functions and the way that they should be implemented. As a bonus, it makes the document easier to maintain, because changes to hash2curve don't need to be propagated to all of the map2curve specifications, too.\r\n\r\nThe specific changes are:\r\n\r\n1. Update section 5.1 to reflect the new interface,\r\n\r\n2. add words to the effect that the input to map2curve... MUST come from hash2base,\r\n\r\n3. change the signatures of the map2curve... functions, and\r\n\r\n4. update section 6 in a similar way.\r\n\r\nI'm happy to update the PR to reflect the above.",
          "createdAt": "2019-05-31T22:08:32Z",
          "updatedAt": "2019-06-01T18:39:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam No disagreement with the facts! What concerns me is that this introduces another parameter without a specified use for it. Sure, implementations could make use of it when calling `hash2base(msg)` twice in `hash2curve`, yet that's not currently done or shown how to be done. At the very least, I think we ought to provide that example in appendix.",
          "createdAt": "2019-05-31T22:09:49Z",
          "updatedAt": "2019-05-31T22:09:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> yet that's not currently done or shown how to be done\r\n\r\nSorry, I think I'm missing something.\r\n\r\nSection 6 uses `ctr` to specify the two independent hash evaluations. Are you referring to something else?",
          "createdAt": "2019-05-31T22:21:14Z",
          "updatedAt": "2019-05-31T22:21:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Aha, I missed that! You\u2019re right, my apologies. I\u2019m fine with this as is then!",
          "createdAt": "2019-05-31T22:33:52Z",
          "updatedAt": "2019-05-31T22:33:52Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am going do a second pass on the latest version.",
          "createdAt": "2019-05-31T22:35:38Z",
          "updatedAt": "2019-05-31T22:35:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nIn order to have a simpler description, I think there is a compatible way to remove the `ctr` parameter from the hash2base function.\r\n\r\nFirst, remove this line from `hash2base` :\r\n```\r\n1. m' = H(msg) || I2OSP(ctr, 1)\r\n```\r\nupdate the signature to `hash2base(msg)` and replace `m'` -> `msg` .\r\n\r\nSecond, modify the RO-construction as follows:\r\n```\r\nhash2curve(alpha) \r\n1.  h = H(alpha)\r\n2.  return map2curve( h || I2OSP(0, 1) ) + map2curve( h || I2OSP(1, 1) )\r\n```\r\nIf I am not wrong this is equivalent to what is currently proposed. Please check this @kwantam.\r\n\r\n",
          "createdAt": "2019-05-31T23:08:41Z",
          "updatedAt": "2019-05-31T23:08:41Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you're right that it's equivalent for the random oracle construction, but it looks to me like the non-RO constructions would also need a similar change. We can do this, but I worry that the resulting description ends up being more complicated.\r\n\r\n@armfazh, when you refer to simpler description, can you be more specific which piece of the description you're trying to simplify? Specifically, is it hash2base, or is it map2curve? In other words, does my [suggestion above](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#issuecomment-497875160) also work to simplify in the way you're aiming for?",
          "createdAt": "2019-06-01T18:40:09Z",
          "updatedAt": "2019-06-01T18:42:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've just pushed a new commit that changes the map2curve signature to `F -> E` as described above.\r\n\r\nTo me this is nicer, but obviously happy to revert if y'all disagree :)",
          "createdAt": "2019-06-01T19:37:16Z",
          "updatedAt": "2019-06-01T19:37:16Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> @armfazh, when you refer to simpler description, can you be more specific which piece of the description you're trying to simplify? \r\n\r\nWhen I refer simplicity am thinking on something like the following:\r\n```fortran\r\n! alpha is an arbitrary-length bit string\r\n! G is the group of interest.\r\nfunction Suite(id, alpha) -> P=(x,y) \\in G\r\n    params = SetParams(id)  \r\n    \r\n    if suite is RO\r\n        P0 = hash2curve(alpha || I2OSP(0,1) )\r\n        P1 = hash2curve(alpha || I2OSP(1,1) )\r\n        return P0 + P1\r\n\r\n    if suite is not RO\r\n        P = hash2curve(alpha)\r\n        return P\r\n\r\nfunction hash2curve(alpha) -> P=(x,y) \\in G\r\n    u = hash2base(alpha)\r\n    Q = map2curve(u)\r\n    P = clearCofactor(Q)\r\n    return P\r\n    \r\nhash2base     : {0,1}* -> F     ! Section 4   (or renamed to hash2field) \r\nmap2curve     :    F   -> E(F)  ! Section 5\r\nclearCofactor :   E(F) -> G     ! Section 5.3 (or a new Section 6)\r\n```\r\n\r\nBy simplicity, also consider that functions have only one purpose and the less number of parameters as possible. \r\n\r\nI think we must add a new section (e.g. after Section 2) at the beginning that gives a road map on how do hash2curve in a high level, and then entering into the details. #119 \r\n*Notice that the lack of this section causes confusion on how to assemble all the parts.\r\n\r\n",
          "createdAt": "2019-06-01T21:26:47Z",
          "updatedAt": "2019-06-02T00:32:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The random oracle construction requires the output of two different hash functions H0 and H1. As noted in the FFSTV paper this can be done using 1 hash function H as follows:\r\n```rust\r\n// FFSTV\r\nH0(x) := H( x || 0 )\r\nH1(x) := H( x || 1 )\r\nhash2curve(alpha) \r\n1.  h = H(alpha)\r\n2.  return map2curve( H0(alpha) ) + map2curve( H1(alpha) )\r\n```\r\nI am not sure whether doing this\r\n```rust\r\nhash2curve(alpha) \r\n1.  h = H(alpha)\r\n2.  return map2curve( h || I2OSP(0, 1) ) + map2curve( h || I2OSP(1, 1) )\r\n```\r\nbe as secure as it is proposed in the paper. \r\n\r\nI suggest to follow the recommendation (and proof) given in the FFSTV paper. This implies that two hash evaluations are needed for the RO construction.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-06-01T21:37:30Z",
          "updatedAt": "2019-06-01T21:37:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh: I've pushed changes to address the typo and wording comments. See my comments above for the other cases.\r\n\r\nAs far as [your](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/117#discussion_r289619477) [comments](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#issuecomment-497979394) on the random oracle construction go: you're right that we have to make sure that the new construction meets the security requirements from FFSTV13. It's always good to be careful.\r\n\r\nBut please note that this:\r\n\r\n>    ```\r\n>    h = H(alpha)\r\n>    return map2curve(h || I2OSP(0, 1)) + map2curve(h || I2OSP(1, 1))\r\n>    ```\r\n\r\nis **not what is proposed in this PR**.\r\n\r\nSo let's think through what *is* proposed.\r\n\r\nFor security, we need H0 and H1 such that H0 and H1 are independent random oracles. Here, independence means that the probability distributions of H0's and H1's outputs are independent. To model H0 and H1 as random oracles, it suffices to show that their outputs are indistinguishable from a random function. It's easy to prove all of this, so let's just write it down.\r\n\r\nFirst, let's simplify our task a bit by assuming (WLOG) that the hash2base parameter W = 2 and that m = 1. Further, let's ignore the final reduction mod p in line 6 of hash2base, since it's easy to show that reducing a uniformly random (W * b)-bit integer mod p gives a field element with negligible statistical distance from random as long as W is chosen correctly. Finally, as always we will model the underlying hash function H as a random oracle.\r\n\r\nSo in sum, our goal is to show that the following two functions give outputs indistinguishable from a random oracle:\r\n\r\n```\r\nfn H0(msg):\r\n    m_0 = H(msg) || I2OSP(0, 1)\r\n    h1_0 = H(m_0 || I2OSP(1, 1) || I2OSP(1, 1))\r\n    h2_0 = H(m_0 || I2OSP(1, 1) || I2OSP(2, 1))\r\n    return h1_0 || h2_0\r\n\r\nfn H1(msg):\r\n    m_1 = H(msg) || I2OSP(1, 1)     // NOTE: the difference from H0 is in this line\r\n    h1_1 = H(m_1 || I2OSP(1, 1) || I2OSP(1, 1))\r\n    h2_1 = H(m_1 || I2OSP(1, 1) || I2OSP(2, 1))\r\n    return h1_1 || h2_1\r\n```\r\n\r\nand further that their output distributions are independent. Independence is by inspection: h1_0, h1_1, h2_0, and h2_1 are all the results of distjoint queries to H, and thus their distributions are independent by the definition of a random oracle.\r\n\r\nFor indistinguishability, it suffices to show that H0 is indistinguishable; the same argument applies for H1. Consider the following game between a challenger C and an adversary A on a function Htest: {0,1}* -> {0,1}^ell.\r\n\r\n**RO security game** \r\n\r\n1. **Setup**: C chooses b <-$- {0,1}. If b == 1, C initializes an empty table T with two columns, i={0,1}* and o={0,1}^ell.\r\n\r\n2. **Query** (repeated any number of times): A sends msg_j to C, and C responds as follows.\r\n    - If b == 0, C computes and returns Htest(msg_i) to A.\r\n    - If b == 1, C checks whether any entry in table T has i=msg_j. If so, C returns the corresponding o. Otherwise, C samples a random value out_j <-$- {0,1}^ell, records the pair (i=msg_j, o=out_j) in table T, and returns out_j to A.\r\n\r\n3. **Guess**: A outputs a bit b*, winning if b* == b.\r\n\r\n\r\n**Definition** *(RO security)*: a function Htest is indistinguishable from a random oracle if, for all PPT adversaries A, A's probability of winning the RO security game on Htest is negligibly different from 1/2.\r\n\r\n\r\n**Theorem** *(H0 security)*: the function H0 defined above is indistinguishable from a random oracle if the underlying hash function H is modeled as a random oracle.\r\n\r\n\r\n**Proof**. Supposing that an adversary A* can distinguish H0 from a random oracle, we use A* to construct an adversary that wins the RO security game against the underlying hash H.  Since H is modeled as a random oracle, this is a contradiction. Thus, A* cannot distinguish H0 from a random oracle.\r\n\r\nOur algorithm Ctest proceeds as follows:\r\n\r\n1. Initiate the random oracle security game on H0, where A* is the adversary and Ctest is the challenger.\r\n\r\n2. Initiate the random oracle security game on H, where Ctest is the adversary and Ch is the challenger.\r\n\r\n3. For each of A*'s queries in the H0 game, Ctest evaluates the function H0 by making oracle queries to Ch. In particular, for query msg_j,\r\n    - h_msg_j is the result of querying Ch on msg_j\r\n    - m' := h_msg_j || I2OSP(0, 1)\r\n    - h1_msg_j is the result of querying Ch on m' || I2OSP(1, 1) || I2OSP(1, 1)\r\n    - h2_msg_j is the result of querying Ch on m' || I2OSP(1, 1) || I2OSP(2, 1)\r\n    - Ctest returns h1_msg_j || h2_msg_j\r\n\r\n4. When A* outputs bit b*, Ctest outputs the same bit to Ch.\r\n\r\nBy inspection, A*'s view of the game with Ctest is indistinguishable from its view of a game with a challenger in the RO security game. Thus, A*'s probability of winning against Ctest is negligibly different from its probability of winning the RO security game.  Moreover, Ctest wins against Ch just when A* would have won in the RO security game, by the definition of H0. (To see why both of these are true, note that with overwhelming probability all of Ctest's queries to Ch are fresh whenever A* sends a fresh query msg_j, which means that Ctest uses Ch to indistinguishably simulate the challenger to A*.) Thus, Ctest wins the RO security game on H with non-negligible probability, \u2a33. \u25a1",
          "createdAt": "2019-06-02T19:18:41Z",
          "updatedAt": "2019-06-02T20:17:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> When I refer simplicity am thinking on something like the following:\r\n\r\nThe roadmap in #119 is a great idea!\r\n\r\nAs far as the proposed function `Suite`, it seems like it's a nice way of tying everything together, which is great. But it seems like it would be fully redundant with the \"roadmap\" section. Also, I don't think it's really in scope for this pull request, which is just about how to define hash2base.\r\n\r\nBut my biggest concern with `Suite` is that, as far as I can tell, it doesn't reflect how people will actually use this standard. In particular, to first order no one is going to implement ten different suites and then select one on-the-fly. Rather, for any given protocol that needs to hash to a curve, other considerations will drive the decision on which curve to use, what hash function to use, whether to hash indifferentiably, etc. Once these decisions are made, the protocol only needs one hash-to-curve implementation, at which point the Suite function doesn't do anything useful.\r\n\r\nBut to reiterate: even if I'm wrong about the above (which I may well be!), it's irrelevant from the point of view of this PR, which is solely focused on getting hash2curve right.",
          "createdAt": "2019-06-02T19:40:01Z",
          "updatedAt": "2019-06-02T19:40:01Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for giving a full proof of your proposal. \r\nIn the pseudo-code from the previous comment, it's obvious the suite is not implemented as is. \r\nWhat I want to show is that hash2curve can be used for having a non-RO mapping (calling directly) and a RO mapping (using the FFSTV construction).\r\n",
          "createdAt": "2019-06-02T21:13:12Z",
          "updatedAt": "2019-06-02T21:13:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I changed ctr=0 to MUST from SHOULD.\r\n\r\nRegarding the use of hash2base, now I think I understand the reasoning. Thanks for explaining it. Does this PR's version of \"Interface\" (under {{encodings}}) and {{rom}} achieve this? Perhaps the roadmap section of #119 can also help to clarify this point.",
          "createdAt": "2019-06-02T22:58:09Z",
          "updatedAt": "2019-06-02T22:59:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider this PR has achieved its main purpose which is to define the internals of hash2base.\r\nIt has my approval for merging, the discussion about the interfaces can be done in #119 or in another PR. \r\n\r\n\r\n\r\n",
          "createdAt": "2019-06-03T00:18:03Z",
          "updatedAt": "2019-06-03T00:18:03Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I've removed the `(+)`.\r\n\r\nI'm not sure which changes (if any) your review is still requesting, but happy to fix them asap.",
          "createdAt": "2019-06-03T03:52:11Z",
          "updatedAt": "2019-06-03T03:52:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0MzQ4Mjk3",
          "commit": {
            "abbreviatedOid": "9e5403e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Technically, this PR is fine, I'm just not sure it's an improvement for implementers. @armfazh @grittygrease, please have a look!",
          "createdAt": "2019-05-31T14:44:31Z",
          "updatedAt": "2019-05-31T14:45:51Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Hmm... How would we make use of this in the actual implementation of `hash2base`? Since the benefit comes from invoking `hash2base` with the same `msg` yet different suffixes, it seems that `hash2base` must necessarily  be stateful so as to not recompute `H(msg)` twice. Is this an improvement? I'm not sure. I think, absent a proposed implementation story there, we ought not to add this complexity.",
              "createdAt": "2019-05-31T14:44:31Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            },
            {
              "originalPosition": 144,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-05-31T14:45:05Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDM2ODIy",
          "commit": {
            "abbreviatedOid": "9e5403e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-31T17:45:59Z",
          "updatedAt": "2019-05-31T17:46:00Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "You're absolutely right that the current pseudocode for hash2base doesn't take advantage of the fact that H(msg) can be shared among invocations. The reason for this is that I thought it made the pseudocode simpler.\r\n\r\nBut given the specification of hash2base, one can implement a helper like the following:\r\n\r\n    hash2base_prehashed(msg_hashed, ctr):\r\n        msg' = msg_hashed || I2OSP(ctr, 1)\r\n        ...\r\n\r\nThen, when evaluating hash2base multiple times for different `ctr` values, one can first compute `msg_hashed = H(msg)` and then call the above helper function instead.\r\n\r\nThis isn't to say that people will immediately implement the prehash version of hash2base; the point is, they can easily refactor their implementation in a way that is compatible with the spec yet doesn't require, say, partial evaluation of `H` (which isn't always an option in existing crypto libraries).",
              "createdAt": "2019-05-31T17:45:59Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDQwNDYx",
          "commit": {
            "abbreviatedOid": "9e5403e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-31T17:53:47Z",
          "updatedAt": "2019-05-31T17:53:48Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Probably I can make the above clearer with some edits to the text. Let me think about this a bit.",
              "createdAt": "2019-05-31T17:53:48Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDQ4Njk5",
          "commit": {
            "abbreviatedOid": "3dba1f7"
          },
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-31T18:11:26Z",
          "updatedAt": "2019-05-31T18:11:27Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "For clarity, `hash2base()` could be renamed to `msg2base()` and `hash2base_prehashed()` could be renamed `hash2base()`.\r\n\r\nIndeed, the actual hash to base operation is going to be a very common case, so we should document how to do it (for an actual implementation, the libsodium documentation has an [example](https://download.libsodium.org/doc/advanced/point-arithmetic#note)).\r\n\r\nHowever, in the proposed `hash2base_prehashed()` function above, we lack context separation with the non-prehashed version.",
              "createdAt": "2019-05-31T18:11:26Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyMzY2",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T21:47:45Z",
          "updatedAt": "2019-06-01T21:47:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "> uniform random element of H requires\r\n\r\nuniform random element of F requires",
              "createdAt": "2019-06-01T21:47:45Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNTkw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T21:56:43Z",
          "updatedAt": "2019-06-01T21:56:43Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "\r\n\r\nRegarding the second issue: \r\nI am not sure whether this proposal maintains or modifies the security properties required by the RO construction. \r\n\r\n\r\n",
              "createdAt": "2019-06-01T21:56:43Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNjUw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T21:59:05Z",
          "updatedAt": "2019-06-01T21:59:05Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "This section can be blended with the next section (Notation)",
              "createdAt": "2019-06-01T21:59:05Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNjg1",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T22:00:19Z",
          "updatedAt": "2019-06-01T22:00:20Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": ">  The only exceptional case is u == 0.\r\n\r\n The only exceptional case is u = 0.\r\n",
              "createdAt": "2019-06-01T22:00:20Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNzUw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T22:03:12Z",
          "updatedAt": "2019-06-01T22:03:13Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Note that implementors SHOULD NOT use a rejection sampling procedure to get a uniform random element from F. The reason ...",
              "createdAt": "2019-06-01T22:03:13Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyODQw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T22:06:57Z",
          "updatedAt": "2019-06-01T22:06:57Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "> The argument ctr to hash2base SHOULD be 0, except as described in Section 6.\r\n\r\nI prefer not to have by-default values.",
              "createdAt": "2019-06-01T22:06:57Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM2NjAy",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T18:07:11Z",
          "updatedAt": "2019-06-02T18:07:11Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "That's possible, but I don't see the advantage. Notation is \"what do these symbols in the code mean?\", Interface is \"how do I use this thing?\". To me, it is clearer to keep them separate.",
              "createdAt": "2019-06-02T18:07:11Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM2NjYz",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T18:09:39Z",
          "updatedAt": "2019-06-02T18:09:39Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "This is a pervasive style question in the document. Pushed to #105.",
              "createdAt": "2019-06-02T18:09:39Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM2Nzg5",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T18:13:38Z",
          "updatedAt": "2019-06-02T18:13:38Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Sorry, I don't understand this comment.\r\n\r\nIt seems pretty clear that everyone should choose the same value of `ctr`. I'm happy to change the definition of `hash2base` so that `ctr` is an integer in {0,1} rather than in [0, 256), but barring that change there must be an agreed-upon value in order for implementations to interoperate.",
              "createdAt": "2019-06-02T18:13:38Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM4ODcw",
          "commit": {
            "abbreviatedOid": "c406a58"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T19:19:22Z",
          "updatedAt": "2019-06-02T19:19:23Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "See [my comment](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#issuecomment-498057883), below.",
              "createdAt": "2019-06-02T19:19:22Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQyNDM1",
          "commit": {
            "abbreviatedOid": "c406a58"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T21:06:14Z",
          "updatedAt": "2019-06-02T21:06:15Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "I was not clear in this comment, please disregard it. \r\nHowever, narrowing the value of the counter to {0,1} seems to me is a good idea. \r\nThe non-RO must fix the ctr value to 0. ",
              "createdAt": "2019-06-02T21:06:15Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQzMzcy",
          "commit": {
            "abbreviatedOid": "c406a58"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T21:37:11Z",
          "updatedAt": "2019-06-02T21:37:12Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "(+)  -> +  \r\n(remove parenthesis of plus)",
              "createdAt": "2019-06-02T21:37:11Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ1OTc3",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T22:56:37Z",
          "updatedAt": "2019-06-02T22:56:38Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "I was thinking it might be clearer to avoid overloading the `+` operator for point addition, since `+` appears in a lot of the pseudocode and has a different meaning there.\r\n\r\nI'm happy to remove it, but it seems like it might improve clarity to use a different symbol here.",
              "createdAt": "2019-06-02T22:56:37Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ4ODM4",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-03T00:03:46Z",
          "updatedAt": "2019-06-03T00:03:46Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "> map2curve(u0) (+) map2curve(u1)\r\n> where map2curve is the chosen encoding and the (+) operation is elliptic curve point addition.\r\n\r\nThe note following the equation alerts the reader about performing point addition. So I will go for using a simple plus symbol.\r\n",
              "createdAt": "2019-06-03T00:03:46Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ5NTAx",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-03T00:15:44Z",
          "updatedAt": "2019-06-03T00:15:44Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "That makes sense, and it's true that the reader *should* be able to figure it out. On the other hand, it seems like using different notation draws attention to the fact that this isn't normal addition, which might make it easier on the reader.\r\n\r\nI just checked, and it looks like RFC8032 (EdDSA) uses just `+`. So maybe it makes sense to do the same.\r\n\r\nBefore I change it back, @chris-wood, @grittygrease, @jedisct1, any further thoughts?",
              "createdAt": "2019-06-03T00:15:44Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ5NzY5",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-03T00:19:55Z",
          "updatedAt": "2019-06-03T00:19:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ5ODUz",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-03T00:21:32Z",
          "updatedAt": "2019-06-03T00:21:32Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "I think simply `+` is fine, though maybe in the future we should consider separate notation to separate point from integer arithmetic.",
              "createdAt": "2019-06-03T00:21:32Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MTkwOTcy",
      "title": "Including one diagram",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/118",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "FWIW, this diagram would help to overview the suites recommended in this draft.\r\n\r\nSome considerations:\r\n - Rely always on hash evaluations over short-length strings.\r\n - Large input strings can be pre-hashed, but this is external to the suite.\r\n - Curves not addressed by means of a named-suite must follow the recommendations given in the draft.\r\n\r\nSources of the diagram are included (xml file) in case something needs to be fixed.\r\n",
      "createdAt": "2019-05-31T20:57:22Z",
      "updatedAt": "2020-03-13T22:18:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4f73ecf9d7b0550ee564f324eedbcde0bfae2f3a",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "diagrams",
      "headRefOid": "845d3558d8f4dde775697db91ac80d99cc1cbfea",
      "closedAt": "2020-03-13T22:18:35Z",
      "mergedAt": "2020-03-13T22:18:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "36346e036152d3130dce85c520a9cc9f2978aa8d"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Diagram is great, and in general super useful.\r\n\r\nMight be worthwhile to wait until after #116 since this would change dramatically if #116 is accepted.\r\n\r\nAlso, is there a better way to describe what's going on in the RO mode than duplicating the boxes? The issue is, if you don't already know what the difference is between the top and bottom sequence, it's *really* hard to tell from the diagram!",
          "createdAt": "2019-05-31T22:25:41Z",
          "updatedAt": "2019-05-31T22:25:41Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe two diagrams would improve clarity over a single diagram with branches for the RO mode.",
          "createdAt": "2019-05-31T23:10:53Z",
          "updatedAt": "2019-05-31T23:10:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple other small comments:\r\n\r\n- the line marked `msg = S0` merges into a line marked `msg = s` in a way that is unclear. Does this mean that `S0` gets replaced by `s`? (I know the answer to this; the point is, the reader doesn't, otherwise they wouldn't need the diagram.)\r\n\r\n- in the ROM case, the cofactor clearing operation should happen **after** the points are added together, not before. Clearing the cofactor commutes with point addition, so the result is the same either way, but clearing the cofactor is, in the general case, expensive, so it should not be repeated unnecessarily.",
          "createdAt": "2019-06-02T20:41:38Z",
          "updatedAt": "2019-06-02T20:41:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to gradually update this PR following the evolution of the draft. \r\n\r\nThis is a secondary material. The priority is on the main doc.",
          "createdAt": "2019-06-13T09:28:35Z",
          "updatedAt": "2019-06-13T09:28:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh as the document is stabilizing (?), can we update this before the draft deadline?",
          "createdAt": "2020-03-05T22:11:25Z",
          "updatedAt": "2020-03-05T22:11:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh this looks good, modulo one nit: we use `msg` instead of `alpha` as the `hash_to_curve` and `encode_to_curve` input parameter. ",
          "createdAt": "2020-03-09T19:05:33Z",
          "updatedAt": "2020-03-09T19:05:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed now. ",
          "createdAt": "2020-03-09T19:14:02Z",
          "updatedAt": "2020-03-09T19:14:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple small comments:\r\n\r\n- Hash2Field : should this be HashToField? MapToCurve says `To`, not `2`.\r\n\r\n    Really, both of these are inconsistent with the notation in the document, which uses snake rather than camel case. It might be worthwhile to use the function names from Section 3, which are\r\n    - hash_to_field\r\n    - map_to_curve\r\n    - clear_cofactor\r\n\r\n- Does it make sense to show the DST as being an input to Hash2Field? I'm not sure if this matters so much, but it might be nice to show people where domain separation comes from.\r\n\r\n    On the other hand, maybe simplicity is better for this diagram.\r\n\r\n- HashToField's outputs should be explicitly described as being in F, maybe in the same way as in the MapToCurve box (i.e., `u \\in F`).\r\n\r\n- A lot of the parameters in the lower-right box in the diagram aren't used in the diagram. Maybe we should simplify by removing them?\r\n\r\n    - p, q, and m aren't used\r\n    - n isn't used\r\n    - r, h, h' aren't used\r\n    - H and b aren't used\r\n\r\n    I'm strongly in favor of removing all of them---and especially H and b, because it will be confusing to talk about a hash function on a slide that's supposed to be defining a different kind of hash function.\r\n\r\n- In Section 3, we say `R = Q0 + Q1`, not `Q`. Probably would be good to be consistent here so that people don't get confused when cross-referencing.",
          "createdAt": "2020-03-09T19:19:16Z",
          "updatedAt": "2020-03-09T19:19:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam if this looks good to you, shall we merge and then submit?",
          "createdAt": "2020-03-09T19:19:21Z",
          "updatedAt": "2020-03-09T19:19:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we could submit without merging this, right? (It doesn't change the document, just the repo.)",
          "createdAt": "2020-03-09T19:20:35Z",
          "updatedAt": "2020-03-09T19:20:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we could submit without merging this, right? (It doesn't change the document, just the repo.)\r\n\r\nYep!",
          "createdAt": "2020-03-09T19:21:47Z",
          "updatedAt": "2020-03-09T19:21:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, one more comment: `Start` vs `END` is inconsistent.",
          "createdAt": "2020-03-09T19:22:37Z",
          "updatedAt": "2020-03-09T19:22:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh! And: `U` should be lower-case to match Section 3.",
          "createdAt": "2020-03-09T19:23:23Z",
          "updatedAt": "2020-03-09T19:23:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed @kwantam comments.",
          "createdAt": "2020-03-09T20:55:00Z",
          "updatedAt": "2020-03-09T20:55:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Addressed @kwantam comments.\r\n\r\nThanks! It looks like all but the DST comment were addressed. I'm fine with omitting that for now. @kwantam, are you OK with the latest diagram?",
          "createdAt": "2020-03-09T21:40:53Z",
          "updatedAt": "2020-03-09T21:40:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me!\r\n\r\nI guess one tiny little nit---not clear whether `Q = (x, y)` and `R = (x, y)` on the arrows going into clear_cofactor are communicating any information. Would it be OK if the labels just said `Q` and `R`?\r\n\r\nI'm fine leaving out the DST. Probably too low-level for this diagram anyway.",
          "createdAt": "2020-03-09T22:29:31Z",
          "updatedAt": "2020-03-09T22:29:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm fine leaving out the DST. Probably too low-level for this diagram anyway.\r\n\r\nThe API for `encode_to_curve` and `hash_to_curve` only take `msg` as input. The DST is defined per-invocation of the encoding. It is difficult to express this property in a high-level diagram.\r\n",
          "createdAt": "2020-03-13T19:28:16Z",
          "updatedAt": "2020-03-13T19:28:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NTM3MjAy",
          "commit": {
            "abbreviatedOid": "a838f58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Awesome! I love this diagram. Only a couple comments before merging. \r\n\r\n- The input `s` should ideally match the notation we use in the document as input to `map2curve` and `hash2curve`. \r\n- Can we also draw boxes around the `map2curve` steps (flows where `msg = s`) and label it accordingly? Maybe even rewrite it so that we have a `map2curve` blackbox that is fed input `msg=s` and `msg=S_1`? That will remove redundant text and should simplify things.",
          "createdAt": "2019-05-31T22:01:44Z",
          "updatedAt": "2019-05-31T22:01:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1MTU1MDUx",
          "commit": {
            "abbreviatedOid": "a838f58"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Comments on drawing. Many of these are to align the diagram with the result of #116.\r\n\r\n1. No need for \"long string?\" or \"prehash\" boxes because of #116.\r\n\r\n2. As @chris-wood said, the input `s` should match the notation in the document. Section 5.1 calls this `alpha`. The diagram, the \"Interface\" section, and the new roadmap section in #119 should all agree here.\r\n\r\n3. RO and non-RO probably need to be clarified. I'm not exactly sure how to do this. @jedisct1's suggestion to split them is pretty good. I wonder if there's anything better? I might play with this offline and return with a suggestion.\r\n\r\n4. The `msg=s`, `msg=S0`, and `msg=S1` labels are confusing in their placement. Probably the solution to this depends on the solution to the immediately preceding point.\r\n\r\n5. `S0` and `S1` are defined incorrectly, and in fact don't need to be defined at all---`hash2base(msg, 0)` and `hash2base(msg, 1)`, suffice.\r\n\r\n6. `Hash2Field` should be `hash2base`. But maybe we should instead consider changing this notation in the document, because I think `hash2field` is clearer. Thoughts?\r\n\r\n7. The output of `Hash2Field` is incorrect. If `F` is the finite field, then the output of `Hash2Field` is exactly one element of `F`. Right now, the notation implies that the output of `Hash2Field` is some number `i > 0` of elements of `F`. Also, `{ }` is usually used to mean unordered sets, whereas `( )` is used to mean (ordered) tuples---but neither should be necessary here, because `U` is one element of `F`, so it's just `u = hash2base(msg, 0) \\in F` (for example). Also, `U` should be `u` to match the document's notation.\r\n\r\n8. `Encoding` should be `map2curve`.\r\n\r\n9. The RO case should compute `P = clear(Q1 + Q2)` rather than `P = clear(Q1) + clear(Q2)`. This is the topic of #120. It might be better to fix the document in a different PR (maybe #119, or I'm happy to make one), but this diagram may as well anticipate that change.\r\n\r\n10. `q`, `p`, and `m` are only used in the definition of `F`, so they probably should not appear in the diagram at all, since they introduce pointless notation. It's clearer for the diagram to refer to `F` in abstract terms everywhere.\r\n\r\n11. The same is true of `n`, `r`, and `h`---`n` is only used in the definitions of `h` and `r`, and the latter two are never used anywhere in the diagram! I would just get rid of them and keep `clear()` totally abstract.\r\n\r\n12. `clear()` should be `clear_h()` to match the text of the document.\r\n\r\n13. `hash2base`, `map2curve`, and `clear_h` should probably be defined in the \"parameters\" block. Right now they're not defined except implicitly when used, which is confusing.\r\n\r\n14. `b` is not used anywhere in the diagram except in the definition of H. As above, probably `H` is better left abstract; the extra detail does not make the diagram any clearer.\r\n\r\n15. I know that #119 adds the `E(F)` and `G` notation, but I'm still not at all sold on it either there or here. The issue is, it's not obvious how it clarifies the document: more notation makes it harder to understand for a non-expert, and expert readers do not need the notation to grok the diagram or the document.\r\n\r\n16. Is it necessary to reference the \"suite\" jargon in this diagram? Why not just say: \"the document specifies algorithms and parameters for well-known elliptic curves, and makes recommendations for curves that are not specifically covered.\" That conveys the same information without requiring the reader to learn the meaning of \"suite\" in this context.\r\n\r\n17. Is the URL the right one? Would it be better to refer readers to the github repo for now, since presumably the diagram will disagree with the content of the current draft?\r\n\r\n18. `Start` is initial caps, but `END` is all caps.\r\n\r\n19. The title of the draft is \"Hashing to Elliptic Curves\", but the title of this diagram is \"Hashing to Elliptic Curve Points.\" The diagram should match the document.\r\n\r\n20. The ASCII arrow `-->` in `f: {0, 1}* --> G` looks hackey given all the nice arrows everywhere else in the diagram. Also, what is the purpose of this piece of text? It repeats information presented more clearly elsewhere in the diagram, and it introduces new notation (`f`) that's never used anywhere else and is inconsistent with what is in the document. My suggestion is to just delete it.\r\n\r\n21. Why does the arrow coming out of the green box say `Q = (x, y)` rather than just `Q`? The arrow coming out of the purple box doesn't say `U = Hash2Field(msg)`, which would be analogous. Beyond being inconsistent, it's not necessary: the yellow box doesn't use `(x, y)`, only `Q`. And having the duplicated notation makes it more likely that a future edit introduces a new inconsistency.",
          "createdAt": "2019-06-03T22:25:56Z",
          "updatedAt": "2019-06-03T22:29:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NTc1NDQ3",
          "commit": {
            "abbreviatedOid": "845d355"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-13T20:02:16Z",
          "updatedAt": "2020-03-13T20:02:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzA2MTAx",
      "title": "Adds a roadmap section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/119",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Gives a brief description about hash curve looks like.\r\n - Promotes clear cofactor as a section.\r\n - Introduces the notion of G, a group/subgroup of interest.\r\n - ~~Updates ROM to be consistent with hash2curve.~~\r\n - ~~Sketches the suite section (here more work is needed).~~",
      "createdAt": "2019-06-02T00:11:52Z",
      "updatedAt": "2019-06-04T20:26:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "938c005eed80c9c457727470e209dfda02546a92",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "contribRoadmap",
      "headRefOid": "1cb3b0a2acd7baeffcaa1db50b5b37b86992e8df",
      "closedAt": "2019-06-04T20:26:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "High-level comments:\r\n\r\n- The roadmap section seems like a good idea.\r\n\r\n- It's not obvious to me that adding more notation (E(F), G, etc) improves the clarity of the document. It's also not obvious that it worsens clarity! My point is just to caution against adding notation for its own sake.\r\n\r\n- `hash2curveROM` seems redundant in terms of distinguishing uniform random from not: non-RO is `map2curve`, RO is `hash2curve`. Note also that `hash2curve` used to be `hash2curveRO` and that was changed because it seemed unnecessary.\r\n\r\n- The changes in the random oracle section conflict with #116, and some of the changes here are already comprehended there. Probably that PR should be resolved before these changes are considered.\r\n\r\n- The question of suite recommendations seems orthogonal to the roadmap section, and it also needs a bunch of discussion and hammering out. It doesn't seem to make sense to do a partial edit in this commit.\r\n\r\nI'm happy to do a line-by-line review of this PR once the disposition of #116 is finalized and any resulting conflicts are resolved.",
          "createdAt": "2019-06-02T20:51:31Z",
          "updatedAt": "2019-06-02T20:52:14Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased with master, includes changes only for the roadmap section.\r\n\r\nHowever, a major update of the roadmap section is WIP: #121  .\r\n",
          "createdAt": "2019-06-03T23:34:40Z",
          "updatedAt": "2019-06-03T23:35:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh is this PR superseded by #121?",
          "createdAt": "2019-06-04T15:55:59Z",
          "updatedAt": "2019-06-04T15:55:59Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> @armfazh is this PR superseded by #121?\r\n\r\nYes, this one can be closed. \r\n\r\n",
          "createdAt": "2019-06-04T20:25:24Z",
          "updatedAt": "2019-06-04T20:25:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0NzY2NjA2",
      "title": "Extended roadmap section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/121",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Roadmap section is expanded to introduce 2 types of functions\r\n   to be supported. Injective Encodings and Random Oracles. (the\r\n   names can be changed accordingly).\r\n - The Random oracle section was merged in Section 2.2.3. in which\r\n   only alerts the reader how to construct a random oracle using\r\n   FFSTV.\r\n - For efficiency, clear cofactor is performed once. #120.\r\n\r\nTBD:\r\n - In the random oracle, hash2base is hashing twice the input, this\r\n   can be fixed by removing the call to the hash function from\r\n   hash2base.\r\n - As always, names of functions and variables can be changed to\r\n   something meaningful.\r\n",
      "createdAt": "2019-06-03T23:35:15Z",
      "updatedAt": "2019-06-18T19:58:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "5c22f835dca8723435bc8f4e72a259119f0d668d",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "extendedRoadmap",
      "headRefOid": "d51275459f6ef107b2aae59119342b3c46d4f776",
      "closedAt": "2019-06-18T19:58:05Z",
      "mergedAt": "2019-06-18T19:58:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6893c4d1b38627ebf98a2443333566c071294f36"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a WIP pull-request.  \r\nIt is expected that this PR serve as a starting point for giving feedback.\r\n",
          "createdAt": "2019-06-03T23:48:05Z",
          "updatedAt": "2019-06-03T23:48:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the first TODO: I know I've expressed this elsewhere, but I don't think it's a problem that the high-level description of the RO construction based on hash2base calls H(msg) twice. As long as the document points out the optimization, implementors will be able to take advantage of it. It's quite trivial.\r\n\r\nIn my mind, the argument against making the optimization explicit is that doing so makes the description more complicated, with no benefit. Since the optimization is trivial, my sense is that the document should optimize for clarity instead.\r\n\r\nIn contrast, other optimizations that are not trivial probably should be included. For example, it's possible to save an inversion in most of the mappings by combining the inversion and sqrt computations and returning a projective point. In contrast to the above, this is likely to be non-obvious, so here my sense is that the document *should* describe the optimization (specifically, in the low-level implementation descriptions).",
          "createdAt": "2019-06-04T01:08:48Z",
          "updatedAt": "2019-06-04T01:16:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay reviewing. I'll have time this afternoon.",
          "createdAt": "2019-06-10T16:36:42Z",
          "updatedAt": "2019-06-10T16:36:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh will you have time to respond to @kwantam's comments? If not, would you like me to apply a patch to this PR (or a branch with the changes in a separate PR)?",
          "createdAt": "2019-06-12T15:51:54Z",
          "updatedAt": "2019-06-12T15:51:54Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am preparing an update addressing the comments.\n\n\n>\n",
          "createdAt": "2019-06-12T16:46:07Z",
          "updatedAt": "2019-06-12T16:46:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I addressed most of the comments from your reviews. If I omitted something, let me know.\r\n\r\n",
          "createdAt": "2019-06-13T09:26:22Z",
          "updatedAt": "2019-06-13T09:26:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh can you please resolve conflicts?",
          "createdAt": "2019-06-17T18:09:46Z",
          "updatedAt": "2019-06-17T18:09:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@grittygrease @samscott89 @kwantam we should aim to land this PR sometime this week \u2014 please let me know if you won\u2019t have time to do a review!",
          "createdAt": "2019-06-17T18:10:46Z",
          "updatedAt": "2019-06-17T18:10:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay again. I'll review this afternoon / evening.",
          "createdAt": "2019-06-17T18:42:07Z",
          "updatedAt": "2019-06-17T18:42:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated addressing latest review (rebased with master)",
          "createdAt": "2019-06-18T04:36:55Z",
          "updatedAt": "2019-06-18T04:36:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks great :+1:\r\n\r\n~~Just one more quick change, please: change `G` to `P` in 5 spots in Related Work.~~",
          "createdAt": "2019-06-18T16:26:44Z",
          "updatedAt": "2019-06-18T18:00:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MDM5NDcw",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I left some comments regarding name choices and other editorial nits.",
          "createdAt": "2019-06-05T14:21:42Z",
          "updatedAt": "2019-06-05T14:36:33Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "nit: no trailing period needed",
              "createdAt": "2019-06-05T14:21:42Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 63,
              "body": "nit: `h>=1` -> `h >= 1`",
              "createdAt": "2019-06-05T14:22:22Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 113,
              "body": "I don't think the name should be prefixed with `h2c`, since it lacks the uniform property. Maybe `encode2curve`, or something similar? ",
              "createdAt": "2019-06-05T14:24:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 121,
              "body": "Naming related: this should probably be `clear_cofactor` to be consistent with other symbol names.",
              "createdAt": "2019-06-05T14:25:25Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 116,
              "body": "Do we need to specify the point representation? Or should we leave a comment saying that the representation depends on the implementation of the internal `map2curve` function?",
              "createdAt": "2019-06-05T14:25:56Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 129,
              "body": "I think this should just be `hash2curve`. No need to include \"RandomOracle\" in the name.",
              "createdAt": "2019-06-05T14:26:39Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "We should expand on this a bit and more clearly highlight the differences between encoding and hashing to the curve. Perhaps:\r\n\r\n```\r\nA mapping can either yield a uniform distribution over the range of points on the curve or not. A mapping that does not yield a uniform distribution is an injective encoding. Example algorithms include Elligator2, wherein the algorithm maps input strings to approximately half of the points on the curve. A mapping that yields a uniform distribution is, effectively, a random oracle from strings to points on the curve. Where appropriate, we use the terms random oracle and hash functions for such mappings interchangeably.```",
              "createdAt": "2019-06-05T14:31:55Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n{{suites}} of this document provides a list of suites for hash2curve algorithms.\r\n```",
              "createdAt": "2019-06-05T14:34:13Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 153,
              "body": "It occurs to me that there are no suites for injective encodings. Should we add some?",
              "createdAt": "2019-06-05T14:35:57Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3OTM5MTc2",
          "commit": {
            "abbreviatedOid": "03f8e51"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Adding this new section is a great idea!\r\n\r\nI've commented pretty heavily, but I hope not to the point of being discouraging :)\r\n\r\nThe high-level ideas are great, there are just a few issues with clarity and consistency that I'm sure we will solve quickly.",
          "createdAt": "2019-06-11T03:42:00Z",
          "updatedAt": "2019-06-11T05:52:09Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "The `E(F)` notation, while certainly correct, seems both unnecessary and potentially confusing to (some) readers.\r\n\r\nSpecifically:\r\n\r\n- this notation is not resolving ambiguity, because any time we talk about points on the curve it's clear from the context what curve and what field we mean. Beyond that, even when using `E(F)` the reader *still* has to rely on context to know what curve and field we mean!\r\n\r\n- it's also not saving space: it's only used a few times in this pull request, and the equivalent concept written in words is short enough to be used instead.\r\n\r\n- on the other hand, its use forces readers to learn a new piece of terminology, which actually makes the document *less* clear and harder to read.\r\n\r\nSo: I'd suggest removing all uses of E(F), and instead just using words. Concretely, I suggest simply removing \", denoted as E(F),\" here. I'll add notes to suggest other updates.",
              "createdAt": "2019-06-11T03:42:00Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 37,
              "body": "`G` is used elsewhere in the document (in the relwork appendix, at least) to mean a point, so this is now overloaded notation.\r\n\r\nSame question as above: why introduce extra notation here? The old text was, to my eyes, just as clear.",
              "createdAt": "2019-06-11T03:55:34Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 39,
              "body": "For our purposes, `G` is *always* a subgroup of prime order. No need to hedge (\"usually taken as\") here.",
              "createdAt": "2019-06-11T03:56:16Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 40,
              "body": "\"known as\" -> \"called\"",
              "createdAt": "2019-06-11T03:56:41Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 59,
              "body": "Suggest removing this line.",
              "createdAt": "2019-06-11T03:58:01Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 60,
              "body": "\"Number of points in the group of points on the elliptic curve E.\"\r\n\r\nthe `#E(F)` terminology is also unnecessary.\r\n\r\nAlso, \"n = h * r\" (the old \"relevance\" entry) is much more informative than \"This value can be prime or composite,\" which doesn't provide any new information. I suggest \"n = h * r, for h and r defined below.\"",
              "createdAt": "2019-06-11T04:02:11Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 61,
              "body": "Suggest removing this line.",
              "createdAt": "2019-06-11T04:02:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 62,
              "body": "I suggest:\r\n\r\n- Meaning: \"The order of the prime subgroup to which bitstrings are mapped.\"\r\n\r\n- Relevance: \"r is the largest prime factor of n.\"",
              "createdAt": "2019-06-11T04:06:24Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 63,
              "body": "\"integer number\" -> \"integer\"",
              "createdAt": "2019-06-11T04:06:49Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 152,
              "body": "Also, probably just remove \"of this document \".",
              "createdAt": "2019-06-11T04:15:44Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 153,
              "body": "Also, \"can be considered as\" -> \"is\". No need to hedge.",
              "createdAt": "2019-06-11T04:16:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 146,
              "body": "This section defines `clear_h`, which every encoding in Deterministic Encodings uses. So moving it here causes a use-before-def.\r\n\r\nBut probably given the new roadmap section we should *remove* `clear_h` from the encodings, in which case this can be later in the document as long as there's a clear forward ref to it from the roadmap.",
              "createdAt": "2019-06-11T04:21:45Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 148,
              "body": "\"of this section\" is no longer correct, since this is now its own section rather than a subsection of \"Deterministic Encodings.\" Perhaps\r\n\r\n    The encodings of {{encodings}} always",
              "createdAt": "2019-06-11T04:22:32Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 93,
              "body": "\"In other words:\" and the next 9 lines should be removed and replaced by \"We describe this construction in {{roadmap}}.\"\r\n\r\nDefining the random oracle construction redundantly with incompatible terminology will confuse readers (why are they different? how do I implement H0? etc.).",
              "createdAt": "2019-06-11T04:35:43Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 104,
              "body": "Just \"Roadmap.\" It's a top-level section of the document; there's no ambiguity about what it's a roadmap for.",
              "createdAt": "2019-06-11T04:38:14Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "Note that some of this is defined in the prior section. Probably this shouldn't repeat; maybe reference?",
              "createdAt": "2019-06-11T04:39:07Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 121,
              "body": "In the rest of the document this function is called `clear_h`. Whatever we decide on needs to be consistent.",
              "createdAt": "2019-06-11T04:39:40Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "\"prime group G\" -> \"points on an elliptic curve E\". The first sentence of the section does not need this level of detail, and having too much detail here makes it hard to understand.",
              "createdAt": "2019-06-11T04:45:25Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "Also, to Chris's point: the first paragraph of the section should introduce (or re-introduce) the high-level concepts before jumping into the low-level details.\r\n\r\nMaybe the right way to do this is to add a new paragraph before what's currently here that tells the reader what's ahead:\r\n\r\n- high level: three pieces (hash2base, map2curve, clear_h)\r\n- the following sections define each piece in detail\r\n- {{term-rom}} discussed two possibilities: injective mapping vs random oracle\r\n\r\netc",
              "createdAt": "2019-06-11T05:18:21Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 116,
              "body": "I'd say not in this section. High-level concepts here, low-level details elsewhere. But probably a forward ref to such discussion would be useful.",
              "createdAt": "2019-06-11T05:19:15Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 120,
              "body": "suggest \"E(F)\" -> \"point on E\"",
              "createdAt": "2019-06-11T05:20:35Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 121,
              "body": "suggest \"G\" -> \"point on E in prime-order subgroup\"",
              "createdAt": "2019-06-11T05:21:12Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 139,
              "body": "suggest (prior three lines):\r\n\r\n\"E(F) x E(F)\" -> \"two points on E\". Cartesian product notation isn't necessarily familiar to all readers.\r\n\r\n\"E(F)\" -> \"point on E\"",
              "createdAt": "2019-06-11T05:22:02Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 140,
              "body": "suggest: as above",
              "createdAt": "2019-06-11T05:22:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 122,
              "body": "\"Output\" -> \"return\" (used everywhere else; note case)",
              "createdAt": "2019-06-11T05:22:51Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 135,
              "body": "`{0,1}*` is written everywhere else as `{0, 1}^*` (note space between comma and 1, \"^\" symbol)\r\n\r\nSame comment applies on the next line, and in step 1 of the prior function",
              "createdAt": "2019-06-11T05:25:05Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 111,
              "body": "The two functions below use a bunch of notation that's not defined (hash2base? map2curve? etc). Readers will be confused by use-before-def.\r\n\r\nThere should be a sentence here introducing these function names and forward reffing to the sections that describe each.",
              "createdAt": "2019-06-11T05:26:58Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 145,
              "body": "The first sentence of this paragraph is confusing because it makes the reader feel like they're missing something (what properties?). I would get rid of it.\r\n\r\nThe rest of this paragraph should go *above* the function definitions (I left another comment there) so that hash2base etc are not used before def.",
              "createdAt": "2019-06-11T05:30:44Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 151,
              "body": "Comments on the above paragraph:\r\n\r\n- Each sentence should name a function (hash2base, etc) and give a brief idea of what that function does, then forward ref to the correct section.\r\n\r\n- The sentence that starts \"Due to the diversity...\" isn't necessary here, and \"Some possible choices\" hedges too much and simultaneously makes the reader feel nervous that they're going to have to make a bunch of decisions.\r\nInstead, maybe something like\r\n\r\n    The map2curve function depends on the target elliptic curve. {{encodings}} describes mappings for a range of curve families.\r\n\r\n- Maybe: \"The function clear_h maps any point on E to a point in the subgroup of prime order r ({{bg-curves}}); it is described in {{cofactor-clearing}}.\" (No need for G.)",
              "createdAt": "2019-06-11T05:45:23Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 152,
              "body": "Also, \"provides a list of\" -> \"defines\"",
              "createdAt": "2019-06-11T05:46:37Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 154,
              "body": "\"required to instantiate ... of interest\" -> \"for standard elliptic curves.\"",
              "createdAt": "2019-06-11T05:48:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODUyOTI5",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:44:44Z",
          "updatedAt": "2019-06-12T15:44:45Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Agreed!",
              "createdAt": "2019-06-12T15:44:44Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODUzOTUw",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:46:12Z",
          "updatedAt": "2019-06-12T15:46:13Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "+1 to this proposal.",
              "createdAt": "2019-06-12T15:46:13Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODU0NTU5",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:47:05Z",
          "updatedAt": "2019-06-12T15:47:06Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "@kwantam does it refer to the generator in the related work? If so, perhaps we could unify around `P` (or whatever we use in the rest of the document) for the generator?",
              "createdAt": "2019-06-12T15:47:05Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODU1NTc1",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:48:40Z",
          "updatedAt": "2019-06-12T15:48:40Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Or perhaps replace `A subgroup of E(F).` with `A prime-order subgroup of the curve`?",
              "createdAt": "2019-06-12T15:48:40Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjIwMTIw",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:11:58Z",
          "updatedAt": "2019-06-13T09:11:58Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "My reasoning to introduce G is because for a suite for pairing curves will refer to the same curve but different subgroups, say G1 and G2. \r\n\r\nI ack that, In some cases, it is more convenient to use only one character, and in others, a verbose text is better. However, G is a general letter used for groups, and we are proposing a way to hashing into a group. \r\n\r\nFinally, G also clashes with generator of curves, but in this draft no generators are used.\r\n",
              "createdAt": "2019-06-13T09:11:58Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjIxMzk3",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:14:26Z",
          "updatedAt": "2019-06-13T09:14:26Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I am not entirely sure if r always matches with the largest subgroup. It seems to be true. But let's double check in the case of pairing curves.",
              "createdAt": "2019-06-13T09:14:26Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjI0MDU2",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:19:09Z",
          "updatedAt": "2019-06-13T09:19:09Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "The arrow notation must be used between sets.\r\n\r\nIndeed, I tried all of these suggestions, but the text looked ugly. I decided to remove those comments and included the arrow notation in the description of the functions. Hope be more legible now.\r\n",
              "createdAt": "2019-06-13T09:19:09Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjI0Mzc1",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:19:47Z",
          "updatedAt": "2019-06-13T09:19:47Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I like this change.",
              "createdAt": "2019-06-13T09:19:47Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjI1MjQ5",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:21:29Z",
          "updatedAt": "2019-06-13T09:21:29Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I did not  understand entirely your comment, but let me know if the new version improves what you was pointing out.",
              "createdAt": "2019-06-13T09:21:29Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NDYxNjI1",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest changes look mostly good to me. Approving for now, since we can address some of the nits in follow up PRs. Thanks for making this change, @armfazh, and for the thorough and thoughtful review, @kwantam!",
          "createdAt": "2019-06-13T16:21:13Z",
          "updatedAt": "2019-06-17T18:09:25Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I'd drop \"since they lead to the more difficult...\" suffix of this sentence.",
              "createdAt": "2019-06-13T16:21:13Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 22,
              "body": "nit: s/to an elliptic/an elliptic",
              "createdAt": "2019-06-13T16:22:26Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 132,
              "body": "I think @kwantam's point was that this sentence doesn't add much value, since it doesn't describe what the properties are and just points below. I vote for removing it too!",
              "createdAt": "2019-06-13T16:23:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 140,
              "body": "nit: \"On the other hand, the second\" -> \"The second\"",
              "createdAt": "2019-06-13T16:24:01Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzgwODUx",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:37:01Z",
          "updatedAt": "2019-06-17T22:37:01Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Stashed a note about injective encodings suites in #126.",
              "createdAt": "2019-06-17T22:37:01Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg0MDA0",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:48:03Z",
          "updatedAt": "2019-06-17T22:48:04Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "You're right, it does make sense to use G, G1, G2 as you describe. :+1:\r\n\r\nThere is one conflicting use of `G` as a generator in the relwork section on the master branch. Also, the commit 1de5f6ebba134de9584e0d2fe8954ecd88a0e4ab introduced a conflict with the master branch, because it edits the \"Try-And-Increment\" appendix, which #122 removed.\r\n\r\nIt should be a quick fix to remove that piece of the commit (it's the very last line of the diff). @armfazh, when you fix the conflict, can you please at the same time rebase onto master and rename `G` to `P` in the relwork section? The only occurrence is in the second-last paragraph (the one that starts \"Brier et al. ...\")",
              "createdAt": "2019-06-17T22:48:03Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg1Nzg4",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:54:24Z",
          "updatedAt": "2019-06-17T22:54:24Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Great point! You're totally right that for the \"big\" group on pairing-friendly curves, r isn't necessarily the largest prime factor. Nice catch :+1:",
              "createdAt": "2019-06-17T22:54:24Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg2Njcy",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:57:33Z",
          "updatedAt": "2019-06-17T22:57:33Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Yes, these edits almost totally take care of my concerns :+1: ",
              "createdAt": "2019-06-17T22:57:33Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg3NDA4",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@armfazh great edits! A few very small nits and then things look great to me.",
          "createdAt": "2019-06-17T23:00:11Z",
          "updatedAt": "2019-06-17T23:31:02Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "nit: no need for comma before \"whose\"",
              "createdAt": "2019-06-17T23:00:11Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 42,
              "body": "nit: comma splice. I suggest either changing the comma to semicolon, or changing to a period and making \"This operation...\" a new sentence.",
              "createdAt": "2019-06-17T23:05:17Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 95,
              "body": "Nit: passive voice in first sentence. Maybe:\r\n\r\nThis section presents a general framework for mapping bit strings into points on an elliptic curve. To construct these mappings, we rely on three basic functions:",
              "createdAt": "2019-06-17T23:12:36Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 97,
              "body": "tiny nit: escape * with backslash (\"*\" => \"\\*\"). Otherwise there is ambiguity about whether this * starts an italicized section.",
              "createdAt": "2019-06-17T23:15:40Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 112,
              "body": "nit: called *an* injective encoding",
              "createdAt": "2019-06-17T23:19:43Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 114,
              "body": "Here I think \"hash function\" is confusing, because not all hash functions can be modeled as random oracles. Certainly collision resistance doesn't imply usability as a PRF, for example.\r\n\r\nMaybe \"behaves as a random oracle, since its output\" instead?",
              "createdAt": "2019-06-17T23:21:08Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 136,
              "body": "If we're going to use the terminology this way, the above sentence should appear earlier. But my preference would be to remove this sentence and just be careful to say \"random oracle\" in the text.",
              "createdAt": "2019-06-17T23:23:17Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 117,
              "body": "\"encodings\" -> \"encoding\"\r\n\r\nAlso, suggest active voice in the next sentence: \"This function maps bit strings to points in G. Note that the distribution of the output is not uniform.\"",
              "createdAt": "2019-06-17T23:24:17Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 134,
              "body": "I'd make this sentence mirror the one above: \"This function maps bit strings to points in G that are indistinguishable from uniformly random.\"\r\n\r\n\"Can be used as a random oracle\" is redundant with the immediately preceding label, \"Random Oracle,\" so I think it should be removed.",
              "createdAt": "2019-06-17T23:25:53Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 507,
              "body": "nit: \"Output\" -> \"return\" for consistency?",
              "createdAt": "2019-06-17T23:28:43Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 686,
              "body": "NOTE: this edit is causing the conflict with master. I suggest removing this edit and then rebasing onto master.",
              "createdAt": "2019-06-17T23:29:59Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 686,
              "body": "Also, ~20 lines above this point is where `G` is used as a point, and probably should be changed to `P`.",
              "createdAt": "2019-06-17T23:30:35Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwODU1ODE5",
          "commit": {
            "abbreviatedOid": "50425ec"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T04:35:32Z",
          "updatedAt": "2019-06-18T04:35:33Z",
          "comments": [
            {
              "originalPosition": 507,
              "body": "good catch",
              "createdAt": "2019-06-18T04:35:33Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMjE1MTcz",
          "commit": {
            "abbreviatedOid": "50425ec"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T16:25:56Z",
          "updatedAt": "2019-06-18T16:25:57Z",
          "comments": [
            {
              "originalPosition": 686,
              "body": "This is the only remaining issue: in the Related Work appendix, there are 5 uses of the symbol `G` to mean a point that generates a prime-order subgroup. I suggest changing these to `P`.",
              "createdAt": "2019-06-18T16:25:56Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMjY2NzQ5",
          "commit": {
            "abbreviatedOid": "d512754"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-18T18:01:09Z",
          "updatedAt": "2019-06-18T18:01:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0NzgwMTY5",
      "title": "pass over relwork",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/122",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit passes over the relwork, making it a bit more compact and improving coverage, including map-to-bitstring. Closes #113.\r\n\r\nThis commit also removes the appendix section that gives details on the Try-and-Increment method:\r\nsince try-and-increment is not recommended for any curve, there is no need to provide pseudocode, and doing so may have the unfortunate effect of encouraging its use. And since that section sans pseudocode is redundant with the description of MapToGroup from BLS01 in relwork, there's no need to include it. Of course, interested readers can follow the BLS01 cite.",
      "createdAt": "2019-06-04T01:03:13Z",
      "updatedAt": "2019-06-05T19:22:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "938c005eed80c9c457727470e209dfda02546a92",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "relwork_update",
      "headRefOid": "ec9b5c643d7d943241ca4f519e0f4a6fa89a23d3",
      "closedAt": "2019-06-04T21:16:53Z",
      "mergedAt": "2019-06-04T21:16:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "69e6cb39a11e798f59ef0d7d15043c40eb12d2d2"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great catches, thanks! Fixed now.",
          "createdAt": "2019-06-04T20:57:42Z",
          "updatedAt": "2019-06-04T20:57:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NTQwMzky",
          "commit": {
            "abbreviatedOid": "972e632"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a nice reduction in text without losing content. Interested readers can follow references for  more information should they want or need it. Thanks for the change!\r\n\r\n@armfazh, please have a look when you can.",
          "createdAt": "2019-06-04T15:51:00Z",
          "updatedAt": "2019-06-04T15:52:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1Njg2ODg5",
          "commit": {
            "abbreviatedOid": "972e632"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Small nits only.",
          "createdAt": "2019-06-04T20:32:36Z",
          "updatedAt": "2019-06-04T20:35:05Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "the characteristic is p",
              "createdAt": "2019-06-04T20:32:36Z",
              "updatedAt": "2019-06-04T20:57:09Z"
            },
            {
              "originalPosition": 206,
              "body": " q -> p",
              "createdAt": "2019-06-04T20:33:05Z",
              "updatedAt": "2019-06-04T20:57:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg1NDE3Mjc4",
      "title": "Clarify hash2base requirements for H.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/123",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kwantam, please have a look!",
      "createdAt": "2019-06-05T15:02:53Z",
      "updatedAt": "2022-02-18T16:42:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "69e6cb39a11e798f59ef0d7d15043c40eb12d2d2",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/clarification-crh",
      "headRefOid": "84ceebb620f40df0bd8f9e74d1ffb238377b6f7d",
      "closedAt": "2019-06-05T20:09:26Z",
      "mergedAt": "2019-06-05T20:09:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8465c6eefed7ed29f25e1a65d92226cd0c42743b"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam thanks for the comments! I think I've resolved both.",
          "createdAt": "2019-06-05T18:49:22Z",
          "updatedAt": "2019-06-05T18:49:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTcwMTk4",
          "commit": {
            "abbreviatedOid": "14c49c8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Nice, this PR does a great job clarifying.\r\n\r\nMaybe just a couple small tweaks, what do you think?",
          "createdAt": "2019-06-05T18:05:19Z",
          "updatedAt": "2019-06-05T18:29:38Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It might be slightly more accurate to say\r\n\r\n> H is modeled as a random oracle, so its output must be indistinguishable from a uniformly random bit string.\r\n\r\nbecause of course SHA doesn't *really* output a uniformly random bit string... :)\r\n\r\nAlso, maybe it would be good to pull the \"For example\" sentence below point (2), to make clear that SHA-256 satisfies both requirements.",
              "createdAt": "2019-06-05T18:21:42Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            },
            {
              "originalPosition": 20,
              "body": "\"as is generally assumed (in other words...\"\r\n\r\nis redundant with the new point (2). Probably can just cut from \", as is\" to the end of the sentence.",
              "createdAt": "2019-06-05T18:23:02Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTkxNjk0",
          "commit": {
            "abbreviatedOid": "14c49c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T18:47:08Z",
          "updatedAt": "2019-06-05T18:47:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Agreed -- fixed!",
              "createdAt": "2019-06-05T18:47:08Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTkyMTQz",
          "commit": {
            "abbreviatedOid": "14c49c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T18:48:03Z",
          "updatedAt": "2019-06-05T18:48:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yep, dropped!",
              "createdAt": "2019-06-05T18:48:04Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTk3ODcw",
          "commit": {
            "abbreviatedOid": "42f4075"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T18:59:25Z",
          "updatedAt": "2019-06-05T18:59:25Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Uh, oops. I'll revert this.",
              "createdAt": "2019-06-05T18:59:25Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MjA2NDc4",
          "commit": {
            "abbreviatedOid": "84ceebb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-05T19:17:44Z",
          "updatedAt": "2019-06-05T19:17:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MDA2MDkw",
      "title": "Remove hacspec code and reference the GitHub repository for more info.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/125",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-06T23:41:58Z",
      "updatedAt": "2022-02-18T16:42:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8465c6eefed7ed29f25e1a65d92226cd0c42743b",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/remove-hacspec",
      "headRefOid": "87a6b1c76806655358dd8c398474c5cb63ad7524",
      "closedAt": "2019-06-07T23:31:24Z",
      "mergedAt": "2019-06-07T23:31:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5c22f835dca8723435bc8f4e72a259119f0d668d"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1:",
          "createdAt": "2019-06-07T00:53:36Z",
          "updatedAt": "2019-06-07T00:53:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2ODc4MDU4",
          "commit": {
            "abbreviatedOid": "87a6b1c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-07T00:52:44Z",
          "updatedAt": "2019-06-07T00:52:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODQ2MTUw",
      "title": "clarifications and formatting fixes in the early part of the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR doesn't make major content changes, it just clarifies and simplifies the text.\r\n\r\nWhat's changed:\r\n\r\n- kramdown-rfc2629 seems to produce broken HTML output from fenced code inside bulleted lists. The first commit pulls the fenced code back to the left margin, which fixes the issue.\r\n\r\n- I reworked and streamlined the terminology section. It had been growing organically for a little while and needed some pruning and harmonizing with the terminology in the rest of the document\r\n\r\n- I renamed \"injective encoding\" to \"nonuniform encoding,\" because I realized that the term \"injective\" is not correct: by a simple counting argument, hash2base must produce collisions for some inputs, so composing hash2base with map2curve cannot produce an injective function. **I'm not fixed on \"nonuniform\"**---does anyone have a better suggestion?\r\n\r\n- bibliography cleanup: moved most cites to \"informative\" from \"normative\" bib, added a couple general cites for further reading on elliptic curves, corrected a couple labels, and got rid of redundant entries.\r\n\r\n- Some very small edits in roadmap for clarity.",
      "createdAt": "2019-06-19T19:23:18Z",
      "updatedAt": "2019-06-26T17:04:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "3504f0f759476c9e5a7eb9105d5196da64526f75",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "indent_fix",
      "headRefOid": "5736c8c3a4020ef579b34f1787fb2ce6d282ce81",
      "closedAt": "2019-06-26T17:04:03Z",
      "mergedAt": "2019-06-26T17:04:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "25b3a80a998c823ebd4d9aeedb4471a337134544"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "> I renamed \"injective encoding\" to \"nonuniform encoding,\" because I realized that the term \"injective\" is not correct: by a simple counting argument, hash2base must produce collisions for some inputs, so composing hash2base with map2curve cannot produce an injective function. I'm not fixed on \"nonuniform\"---does anyone have a better suggestion?\r\n\r\nPerhaps \"subset encoding\" or \"encoding to subset\"?\r\n\r\nAdditionally, perhaps we should specify that these are required to be \"well-distributed\", as specified by Farasahi et al., which is what permits their use in hash2curve. Which can be understood intuitively as meaning they are close to uniform over the target subset.",
          "createdAt": "2019-06-21T15:04:53Z",
          "updatedAt": "2019-06-21T15:04:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Perhaps \"subset encoding\" or \"encoding to subset\"?\r\n\r\nThis could work, but I have a couple concerns:\r\n\r\n- The way the encodings are described, the RO encodings are *also* encodings to subsets (namely, `G`), so this might be confusing.\r\n\r\n- \"Nonuniform\" emphasizes the important difference compared to ROs, which may be more helpful for implementors trying to choose the correct encoding for their application.\r\n\r\n> Additionally, perhaps we should specify that these are required to be \"well-distributed\", as specified by Farasahi et al., which is what permits their use in hash2curve. Which can be understood intuitively as meaning they are close to uniform over the target subset.\r\n\r\nThat's true for the `map2curve` functions---they are all well-distributed encodings---but the \"encodings\" as described here can't be, because their definitions are incommensurate. Specifically, for a function *f* to be well distributed, its type signature must be `F -> E(F)` [FFSTV, Def. 1]. (And this isn't a superficial syntactic distinction: the definition of a well-distributed encoding involves a character sum over F.)\r\n\r\nBut the above ties into [your other comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127#discussion_r296278246): it may be worth clarifying (perhaps in ~~the map2curve section~~ an appendix---#128) that the mapping functions are (in general) invertible, well distributed, etc. Thoughts?",
          "createdAt": "2019-06-22T01:51:12Z",
          "updatedAt": "2019-06-23T14:10:46Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that all makes sense. Apologies for the mixing of language, in my head encoding still refers to map2curve, and hashing for hash2curve :) \r\n\r\n> The way the encodings are described, the RO encodings are also encodings to subsets (namely, G), so this might be confusing.\r\n\r\n> \"Nonuniform\" emphasizes the important difference compared to ROs, which may be more helpful for implementors trying to choose the correct encoding for their application.\r\n\r\nCounter-point: the RO constructions aren't uniform either, just indifferentiable from one :) Also, defining something in terms of the absence of a feature seems slightly odd.\r\n\r\nAlthough, I suppose describing the encodings as non-uniform is slightly more intuitive than thinking about hashing to \"the whole group\" vs a \"subset of the group\", and what that means for security. Non-uniform sounds scarier and thus hopefully causes implementors to pause before using.",
          "createdAt": "2019-06-24T00:55:57Z",
          "updatedAt": "2019-06-24T00:55:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": " > Counter-point: the RO constructions aren't uniform either, just indifferentiable from one :)\r\n\r\nHah! true :+1:\r\n\r\n> Also, defining something in terms of the absence of a feature seems slightly odd.\r\n>\r\n> Although, I suppose describing the encodings as non-uniform is slightly more intuitive than thinking about hashing to \"the whole group\" vs a \"subset of the group\", and what that means for security. Non-uniform sounds scarier and thus hopefully causes implementors to pause before using.\r\n\r\nAs you say, the hope is to make sure that people *know* they're not getting a (pseudo)random element. I don't want to *scare* anyone per se, but I'll be happy if everyone who reads \"nonuniform\" pauses and thinks \"hmm, is that OK?\"",
          "createdAt": "2019-06-24T17:06:29Z",
          "updatedAt": "2019-06-24T17:06:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've thought more about this and I believe I have a solution that closes #128 and addresses both @armfazh's and @samscott89's concerns about the above.\r\n\r\nAlso, @samscott89's comment above made me realize that the document isn't yet consistent on the use of \"encoding\" vs \"mapping.\" I'll address that, too.\r\n\r\nSo: I'm going to push an update tonight.",
          "createdAt": "2019-06-24T17:10:57Z",
          "updatedAt": "2019-06-24T17:10:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, the changes I'm about to push are slightly more extensive than I'd anticipated. But I believe they address the concerns about precision with respect to discussing invertibility, injectivity, etc., and should close #128. Comments very much appreciated.",
          "createdAt": "2019-06-25T05:32:06Z",
          "updatedAt": "2019-06-25T05:32:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am currently reviewing the document, let me do a pass on it to match with the latest changes (9180fc1)",
          "createdAt": "2019-06-25T21:46:52Z",
          "updatedAt": "2019-06-25T21:46:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, rebased onto master. Should be good to go now.",
          "createdAt": "2019-06-26T17:02:32Z",
          "updatedAt": "2019-06-26T17:02:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMTQ2OTg2",
          "commit": {
            "abbreviatedOid": "e91688d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-20T08:09:11Z",
          "updatedAt": "2019-06-20T08:38:48Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "This paragraph is correct but difficult to read. \r\nSuggestion or something similar to\r\n> Encodings may be invertible, thus there is an efficient method that recovers the bit strings from the points produced by the encoding.",
              "createdAt": "2019-06-20T08:09:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 227,
              "body": "we cover invertible encodings, but it must be stated that this property is not relevant for hash to curve.",
              "createdAt": "2019-06-20T08:11:52Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyNDA5NjU5",
          "commit": {
            "abbreviatedOid": "e91688d"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T16:48:46Z",
          "updatedAt": "2019-06-20T16:48:47Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "The `map2curve` functions are generally invertible, but since we're using \"encoding\" to refer to the whole pipeline (`hash2base \u2218 map2curve \u2218 clear_cofactor`), isn't it the case that the \"encodings\" in this document are not invertible (since `hash2base` isn't)?",
              "createdAt": "2019-06-20T16:48:47Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyODgwMjk2",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-21T15:11:12Z",
          "updatedAt": "2019-06-21T15:11:12Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Perhaps it's worth making that clarification somewhere: properties like injectivity/invertability of the encoding would apply to the inner `map2curve` definition, and are not of relevance for the outer `hash2curve` and `encode2curve` definitions. Probably good to be clear, since in the future other docs might want to reference the same `map2curve` definitions and think about those properties.",
              "createdAt": "2019-06-21T15:11:12Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMDc3NjYz",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-22T02:00:34Z",
          "updatedAt": "2019-06-22T02:00:34Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Perhaps it would be useful to do this in the map2curve section. (See also my comment below.)\r\n\r\nThe reason I suggest leaving it until that section is that, at this point in the document, the three pieces of an encoding (hash2base, map2curve, clear_cofactor) have not yet been defined.",
              "createdAt": "2019-06-22T02:00:34Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMTM0NjE4",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-23T14:10:22Z",
          "updatedAt": "2019-06-23T14:10:23Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "I've created #128 to capture this issue; let's discuss further there.",
              "createdAt": "2019-06-23T14:10:22Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNTQ3Mzg3",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-24T17:17:38Z",
          "updatedAt": "2019-06-24T17:17:38Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "heads up on the use of variables, `msg` and `x` do not match.",
              "createdAt": "2019-06-24T17:17:38Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNTYzNzc1",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-24T17:50:10Z",
          "updatedAt": "2019-06-24T17:50:10Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Thanks! I'll hit this tonight, too :)",
              "createdAt": "2019-06-24T17:50:10Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNzY3NTE2",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good! I only have a couple small comments. Otherwise, it\u2019s good to go.",
          "createdAt": "2019-06-25T04:40:52Z",
          "updatedAt": "2019-06-25T04:48:13Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "As written, this is a bit confusing, since `2^L < n` is a case where `2^L != n`. Perhaps the former sentence should explicitly say that the encoding cannot be bijective on all points on the curve? ",
              "createdAt": "2019-06-25T04:40:52Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 230,
              "body": "This last sentence seems to imply that encodings have properties akin to cryptographic hash functions, which isn\u2019t true, right? I\u2019d trim everything after \u201cdoes not discuss inversion algorithms;\u201d",
              "createdAt": "2019-06-25T04:42:21Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 246,
              "body": "Nit: random-oracle or random oracle?",
              "createdAt": "2019-06-25T04:43:21Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNzc3NTc2",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-25T05:31:07Z",
          "updatedAt": "2019-06-25T05:31:07Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "The grammer-nerdiest answer is, both! If \"random oracle\" is a noun, no hyphen, if it's an adjective, hyphen (per Chicago manual of style).\r\n\r\nBut this can get annoying. If we decide we want to go with just one or the other, I'd vote no hyphen.",
              "createdAt": "2019-06-25T05:31:07Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MDk1MzU0",
          "commit": {
            "abbreviatedOid": "7e2a332"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Latest changes look good!",
          "createdAt": "2019-06-25T15:39:20Z",
          "updatedAt": "2019-06-25T15:46:15Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Perhaps clarify that this is because collisions are possible?",
              "createdAt": "2019-06-25T15:39:20Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 118,
              "body": "Should we be explicit about what invertible encodings, similar to what we do for mappings above? That is, something similar to:\r\n\r\n```\r\nAn encoding is said to be invertible if, for any point P output by the encoding, there is an efficient algorithm to recover a bit string s such that encoding s yields P. Since the hash function(s) H used by encodings in this document are not invertible, all specified encodings are also not invertible.\r\n```",
              "createdAt": "2019-06-25T15:40:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0Mjg3ODA2",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-25T21:46:55Z",
          "updatedAt": "2019-06-25T21:46:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MjY2MTUx",
          "commit": {
            "abbreviatedOid": "7e2a332"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I request minimal changes and made suggestions. It might be possible that some of them were already addressed in the latest commit. ",
          "createdAt": "2019-06-25T20:58:03Z",
          "updatedAt": "2019-06-25T22:18:30Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "> Sample code for each algorithm is presented in {{samplecode}}.\r\n\r\nThis reference is too early in this part. Some concepts (curves, encodings, RO, etc) must be understood first before jump in source code.",
              "createdAt": "2019-06-25T20:58:03Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 148,
              "body": "I suggest to reordering these two paragraphs to something like this:\r\n\r\n> This document aims to bridge this gap by providing a thorough set of recommended hashing algorithms for a range of curve types. Each algorithm conforms to a common interface: it takes as input an arbitrary-length bit string and produces as output a point on an elliptic curve.  Additionally, we describe the security rationale behind each recommendation, and give guidance for elliptic curves that are not explicitly covered.\r\n\r\nAfter that, it might be worth to have a sentence that points to Background, terminology and Roadmap sections.",
              "createdAt": "2019-06-25T21:02:13Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 168,
              "body": "\r\n```suggestion\r\nFor further reference about elliptic curves, consult {{CFADLNV05}} or {{W08}}.\r\n```",
              "createdAt": "2019-06-25T21:04:13Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 168,
              "body": "Regarding the following paragraph, \r\n\r\n> The curve E forms an algebraic group whose elements are the\r\npoints (x, y) satisfying the curve equation, where x and y are elements of F.\r\nThis group has order n, meaning that there are n distinct points.\r\n\r\nFirst suggestion is to change to `an additive group`. it is clear that `additive` and `algebraic` terms refer to different things, but including `additive` reminds the reader that points can be added.\r\n\r\nSecond suggestion is to change to \r\n```\r\n  whose elements are the points P=(x, y) with coordinates satisfying the curve equation. Each coordinate is an element of F.\r\n```\r\n",
              "createdAt": "2019-06-25T21:18:49Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 168,
              "body": "> An elliptic curve E is specified by a cubic equation in two variables and a finite field F. An elliptic curve equation takes one of several standard forms, including (but not limited to) Weierstrass, Montgomery, and Edwards.\r\n\r\nAlthough all elliptic curves can be put in Weierstrass form (which is a cubic equation), sometimes we use the non-cubic version of the curve (e.g. Edwards curve).",
              "createdAt": "2019-06-25T21:26:14Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 229,
              "body": "```suggestion\r\nIn general, a mapping may produce only a subset of the points on an elliptic curve\r\n```",
              "createdAt": "2019-06-25T21:31:48Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 232,
              "body": "```suggestion\r\nIn addition, a mapping may produce the same point for distinct inputs\r\n```",
              "createdAt": "2019-06-25T21:33:42Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 239,
              "body": "which word fits better? outputted, produced, or calculated ",
              "createdAt": "2019-06-25T21:36:28Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 242,
              "body": "In connection with this [comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127/files#r297256934), and according to this new categorization between mappings and encodings. \r\nWe _do_ work with invertible mappings. But a proper sentence for the document should say that we _do not_work with invertible encodings (as pointed in the link).",
              "createdAt": "2019-06-25T21:44:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 725,
              "body": "This implementation is optimized for the case that q = 3 (mod 4), which applies to P-256\r\nThis implementation is optimized for the case that q = 3 (mod 4). ~~which applies to P-256~~",
              "createdAt": "2019-06-25T22:07:45Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 752,
              "body": "Here it is not clear which of the previous methods is referred by `this`.",
              "createdAt": "2019-06-25T22:11:07Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzA3MTUz",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-25T22:43:05Z",
          "updatedAt": "2019-06-25T22:43:05Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "I'd prefer it be near the top rather than hidden at the end of the section.",
              "createdAt": "2019-06-25T22:43:05Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzA3NTA5",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-25T22:44:16Z",
          "updatedAt": "2019-06-25T22:44:16Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "I vote for `output`.",
              "createdAt": "2019-06-25T22:44:16Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDAzMzk0",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:29:11Z",
          "updatedAt": "2019-06-26T06:29:12Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "For now I removed the forward ref.\r\n\r\nWe could bring it back, but it seems unnecessary to have the stereotypical \"this document is organized as follows...\" paragraph as long as the section titles are descriptive, since there's an autogenerated table of contents.",
              "createdAt": "2019-06-26T06:29:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDAzODQz",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:30:30Z",
          "updatedAt": "2019-06-26T06:30:30Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Regarding the middle comment: I made some changes that are close but not exactly what you asked for. The changes I made are slightly more verbose (for clarity) but I think respond to the spirit of the suggestion.",
              "createdAt": "2019-06-26T06:30:30Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA0NTM3",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:32:52Z",
          "updatedAt": "2019-06-26T06:32:52Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I made a change along the lines of what you're suggesting, but not exactly the one above.\r\n\r\nThe reason is, it's important to be clear that we're talking about the image of the mapping, and not its output on a given execution. Said another way, the mapping produces one point when executed, so saying that it produces a subset without specifying \"over all possible inputs\" could confuse readers.",
              "createdAt": "2019-06-26T06:32:52Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA0NjM0",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:33:06Z",
          "updatedAt": "2019-06-26T06:33:07Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Ditto, \"output\" is my preference, too.",
              "createdAt": "2019-06-26T06:33:07Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA0ODI4",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:33:43Z",
          "updatedAt": "2019-06-26T06:33:43Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "I've clarified this, I think. Does it look OK now?",
              "createdAt": "2019-06-26T06:33:43Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA1Mjgz",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:35:00Z",
          "updatedAt": "2019-06-26T06:35:00Z",
          "comments": [
            {
              "originalPosition": 725,
              "body": "Can we leave this alone until we go back through and do curve-specific reference code, then update all of these examples? The reason is that there are similar examples given in other mappings, so it would be better to make this change systematically.",
              "createdAt": "2019-06-26T06:35:00Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA4MzE4",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:44:10Z",
          "updatedAt": "2019-06-26T06:44:11Z",
          "comments": [
            {
              "originalPosition": 725,
              "body": "Added a note in #111 so that we don't lose this.",
              "createdAt": "2019-06-26T06:44:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDE2MDk3",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T07:05:39Z",
          "updatedAt": "2019-06-26T07:05:39Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "Now it is clearer.",
              "createdAt": "2019-06-26T07:05:39Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDE3MjM2",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T07:08:30Z",
          "updatedAt": "2019-06-26T07:08:30Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "it is 0K.",
              "createdAt": "2019-06-26T07:08:30Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDE4MTg1",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-26T07:10:51Z",
          "updatedAt": "2019-06-26T07:10:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkxNzYzMzQ4",
      "title": "Replace foo2bar with foo_to_bar, and add Riad as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/130",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-25T23:08:25Z",
      "updatedAt": "2022-02-18T16:42:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6893c4d1b38627ebf98a2443333566c071294f36",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/naming-and-names",
      "headRefOid": "d52c95a53c0935a5b81a0cdc4431780d1c9b5c4e",
      "closedAt": "2019-06-26T12:55:18Z",
      "mergedAt": "2019-06-26T12:55:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3504f0f759476c9e5a7eb9105d5196da64526f75"
      },
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like you got all the x2y occurrences I can find, other than inside some of the links/anchors. But those are still consistent (`#hash2base-{impl,perf,repo,sec}`).",
          "createdAt": "2019-06-26T01:20:04Z",
          "updatedAt": "2019-06-26T01:20:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzQzNjMw",
          "commit": {
            "abbreviatedOid": "72da9f5"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. Made suggestions for the links if it you think it's worthwhile.",
          "createdAt": "2019-06-26T01:28:12Z",
          "updatedAt": "2019-06-26T01:37:54Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n## Security considerations {#hashtobase-sec}\r\n```",
              "createdAt": "2019-06-26T01:28:12Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n{{hashtobase-impl}} details the hash\\_to\\_base procedure.\r\n```",
              "createdAt": "2019-06-26T01:28:28Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n## Performance considerations {#hashtobase-perf}\r\n```",
              "createdAt": "2019-06-26T01:28:44Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nSince hash\\_to\\_base may invoke H multiple times ({{hashtobase-sec}}), its\r\n```",
              "createdAt": "2019-06-26T01:28:56Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 137,
              "body": "```suggestion\r\n## Implementation {#hashtobase-impl}\r\n```",
              "createdAt": "2019-06-26T01:29:09Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA2NzI0",
          "commit": {
            "abbreviatedOid": "d52c95a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look good to me. Thanks!",
          "createdAt": "2019-06-26T06:39:21Z",
          "updatedAt": "2019-06-26T06:39:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDEzMTg5",
          "commit": {
            "abbreviatedOid": "d52c95a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-06-26T06:57:53Z",
          "updatedAt": "2019-06-26T06:57:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMDgzMzQ1",
      "title": "section 6, missed a few instances of 'encoding'",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/131",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Oops. This is minor, just missed a few words. Sorry @chris-wood, spoke too soon when I said \"good to go.\"",
      "createdAt": "2019-06-26T17:13:32Z",
      "updatedAt": "2019-06-26T17:14:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "25b3a80a998c823ebd4d9aeedb4471a337134544",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "indent_fix",
      "headRefOid": "190c875932804962dbc34c0347fabc570bf608a3",
      "closedAt": "2019-06-26T17:14:29Z",
      "mergedAt": "2019-06-26T17:14:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "89f8dde0d8fc81708669be3eb1c0473cc558e04d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NzU3Mzg2",
          "commit": {
            "abbreviatedOid": "190c875"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-26T17:14:24Z",
          "updatedAt": "2019-06-26T17:14:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMTkyNTI3",
      "title": "update description of Edwards map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/132",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit separates the description of the birational map from Montgomery to Edwards from the description of the Edwards mapping.\r\n\r\nIt also clarifies that the correct birational map to use for existing standardized curves is the one from the standard, which addresses a stashed TODO from #107.\r\n\r\nThis addresses one of the outstanding issues w.r.t. VRF inclusion.",
      "createdAt": "2019-06-26T23:16:06Z",
      "updatedAt": "2019-07-02T20:13:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "89f8dde0d8fc81708669be3eb1c0473cc558e04d",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "edwards_maps",
      "headRefOid": "5ad2439683af33645431700d3b7789dede5c1c7f",
      "closedAt": "2019-07-02T16:01:35Z",
      "mergedAt": "2019-07-02T16:01:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f20f8c73fa60cbbcdb40b68f5ac6f9cf877117fd"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Let's hold this up a tiny bit longer: I'm going to push a commit that makes @armfazh's suggested clarification from #134.~~\r\n\r\nOK, made the clarification.",
          "createdAt": "2019-06-29T02:13:04Z",
          "updatedAt": "2019-06-29T03:14:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTU5NTE0",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice refactor and cleanups! This LGTM. ",
          "createdAt": "2019-06-27T01:32:35Z",
          "updatedAt": "2019-06-27T01:41:56Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "naming: can we spell out elligator2, i.e., `map_to_curve_elligator2_edwards`?",
              "createdAt": "2019-06-27T01:32:35Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 90,
              "body": "Should we note that `sqrt` in those implementations MUST be chosen from the set we recommend in this document? (That is, must be constant time.)",
              "createdAt": "2019-06-27T01:34:58Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 90,
              "body": "Should we also specify that new Edwards curves SHOULD/MUST specify a corresponding Montgomery form and birational map?",
              "createdAt": "2019-06-27T01:36:05Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 89,
              "body": "Should we cite the sections, too? (4.1 and 4.2)",
              "createdAt": "2019-06-27T01:38:10Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 96,
              "body": "nit: this only derives one of the maps, right? (it seems left as an exercise for the reader to describe the reverse mapping)",
              "createdAt": "2019-06-27T01:40:46Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTcyNzcy",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:32:04Z",
          "updatedAt": "2019-06-27T02:32:05Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "This is a great catch.\r\n\r\nSince those square roots are constants, I would guess that most people will just hard code a constant in their implementation.\r\n\r\nBut: the sign of the square root isn't specified, so the sign of the resulting point is ambiguous!\r\n\r\nTo me, the best way to fix this is to do what we've done everywhere else: specify that the sign of the Edwards point should be equal to the sign of the input `u`, since this is both unambiguous and insensitive to whether future standards manage to find other ways to ambiguously specify rational maps.",
              "createdAt": "2019-06-27T02:32:04Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTcyOTEz",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:32:53Z",
          "updatedAt": "2019-06-27T02:32:53Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Not a bad idea, though I wonder if people might complain that trying to require this would be mission creep for this standard... thoughts?\r\n\r\n(But I suppose that's what SHOULD is for!)",
              "createdAt": "2019-06-27T02:32:53Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTczNDM2",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:35:53Z",
          "updatedAt": "2019-06-27T02:35:53Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Since we don't need the inverse map for this hash, I wasn't going to bother with it.\r\n\r\nBut it's pretty short to specify the inverse, and could make life easier in the future. I'll add it.",
              "createdAt": "2019-06-27T02:35:53Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTc1MTcx",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:45:21Z",
          "updatedAt": "2019-06-27T02:45:21Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yeah, I'm leaning towards SHOULD. :-)",
              "createdAt": "2019-06-27T02:45:21Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTc1MTg5",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:45:27Z",
          "updatedAt": "2019-06-27T02:45:27Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "That sounds good!",
              "createdAt": "2019-06-27T02:45:27Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTc1MjM3",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:45:46Z",
          "updatedAt": "2019-06-27T02:45:46Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I'm OK with either, so this works for me.",
              "createdAt": "2019-06-27T02:45:46Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MDIxMTI5",
          "commit": {
            "abbreviatedOid": "6546717"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T06:07:48Z",
          "updatedAt": "2019-06-27T06:07:48Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Argh, as I'm thinking about this more, I'm not super happy with this solution. But I'm not sure whether there's any other solution that's better.\r\n\r\nThe reason I'm not super happy is, if we don't tell folks how to resolve the ambiguity in RFC7748, then it may still break things in annoying ways. Specifically, I'm worried about a case where someone wants to interoperate between curve25519 and edwards25519, and wants to be able to hash to both of them.\r\n\r\nAs currently written, there's no guarantee that a conforming hash-to-Montgomery and a conforming hash-to-Edwards will give the same result, because the maps could disagree on sign. It gets worse in the case of the random oracle construction: since the maps may disagree on sign sometimes and agree on sign other times, there are 4 possible outputs:\r\n\r\n- P + Q\r\n- P - Q\r\n- -P + Q\r\n- -P - Q\r\n\r\nwhere P and Q are the first and second map evaluations, respectively.\r\n\r\nThis is bad! I think we want the curve25519 and edwards25519 hash functions to give exactly the same result, and I think for that purpose the only thing we can do is specify the sign of the birational map.\r\n\r\nI'm going to push a revert for the sign commit and push another commit with this solution. This will let us easily change from one to the other once we've decided.\r\n\r\nI think I favor resolving the ambiguity by telling implementors to use the positive branch for sqrt(-486664) rather than by fixing the sign of the x-coordinate after evaluating the map, for the reasons above. But I'll think about it some more.",
              "createdAt": "2019-06-27T06:07:48Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mzg4NTcz",
          "commit": {
            "abbreviatedOid": "f29f284"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T17:58:48Z",
          "updatedAt": "2019-06-27T17:58:49Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "To be sure I understand, the invariant you're after is:\r\n\r\n```\r\nphi(HM(x)) == HE(x)\r\n```\r\n\r\nwhere `HM`, `HE`, and `phi` are the hash-to-Montgomery, hash-to-Edwards, and Montgomery-to-Edwards functions, respectively. By asserting that each map uses positive constants, the goal is that `phi` would not change the point sign. Is that right? (I need to think through this more.)",
              "createdAt": "2019-06-27T17:58:48Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MzkyMDcy",
          "commit": {
            "abbreviatedOid": "f29f284"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Other than the thread on the sign, this looks good to me",
          "createdAt": "2019-06-27T18:05:24Z",
          "updatedAt": "2019-06-27T18:22:34Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nThe coordinates (x, y) specify a point on an elliptic curve defined over F.\r\n```",
              "createdAt": "2019-06-27T18:05:25Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDE3MzUw",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T18:53:54Z",
          "updatedAt": "2019-06-27T18:53:55Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "The goal of fixing the sign of the constants is just to make sure that everyone uses exactly the same definition of phi(), so that different implementations will interoperate. In the case of edwards25519, we'll have test vectors in the standard, so everything should be fine. The remaining concern is that future standardization efforts for Edwards curves will have the same ambiguity. Resolving all ambiguously-signed constants in one direction should suffice to prevent this.\r\n\r\nBut yeah, as long as everyone uses the same phi and phi-inverse, then Montgomery and Edwards implementations can totally interoperate. For example, you could imagine someone writing (say) a PAKE library based on Curve25519 that does all curve operations in Edwards coordinates to take advantage of the constant-time, exception-free addition formulas. It would be great if that implementation could interoperate with another one that uses the Montgomery ladder for better performance. Making sure that the Edwards and Montgomery hashes always give equivalent results helps with this kind of compatibility, because it means that the Edwards PAKE library could use any conforming hash-to-Edwards implementation.\r\n\r\nBy the way, positive constants don't guarantee that the sign is unchanged, because \"sign\" acts a little weird here: the product of two positive numbers can be negative, for example. (As a simple example, consider the integers mod 13. By our definition, both 2 and 6 are positive, but their product is negative.) But it's enough that phi() and phi-inverse() are actually inverses (which they are as long as they use the same sign for the constants), and that everyone's definition of phi() is exactly the same, including sign.",
              "createdAt": "2019-06-27T18:53:54Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDI4ODAw",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T19:17:41Z",
          "updatedAt": "2019-06-27T19:17:41Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "I was playing fast and loose with my words -- ensuring that everyone's phi implementation is the same is what I was after. I agree with the conclusion that fixing the sign ensures compatibility now and in the future.",
              "createdAt": "2019-06-27T19:17:41Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDM1ODky",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T19:32:48Z",
          "updatedAt": "2019-06-27T19:32:48Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": ":+1: sorry to be pedantic, just wanted to be sure we were on the same page. :)",
              "createdAt": "2019-06-27T19:32:48Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDYxMzIz",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T20:26:29Z",
          "updatedAt": "2019-06-27T20:26:29Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Why it was removed 'twisted'?\r\nTwisted Edwards are more generic than Edwards curves. ",
              "createdAt": "2019-06-27T20:26:29Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDYyOTAz",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T20:29:36Z",
          "updatedAt": "2019-06-27T20:29:37Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "here is an inaccuracy.\r\nthe `bi` prefix on birationality refers to the fact that there are two maps one from X -> Y and another from Y -> X .\r\nand the 'bi' prefix is not related to the dimension of the varieties (the number of coordinates to represent a point).",
              "createdAt": "2019-06-27T20:29:36Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDgyMDg3",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:09:43Z",
          "updatedAt": "2019-06-27T21:09:44Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "You're absolutely right, I was sloppy. Thanks for catching!",
              "createdAt": "2019-06-27T21:09:44Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDg3MjE3",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:21:39Z",
          "updatedAt": "2019-06-27T21:21:39Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "You're right, the wording is confusing here. I'll fix.\r\n\r\nJust to make sure we're on the same page: X -> Y is a birational map just if it's a rational map *and* if the inverse map Y -> X also exists and is rational. In other words, it is correct to call the map M -> E birational.\r\n\r\nSo the objection here is that the wording seems to imply that \"bi\" and dimensionality are related, which of course as you say is not true.",
              "createdAt": "2019-06-27T21:21:39Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDkwNzQz",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:29:56Z",
          "updatedAt": "2019-06-27T21:29:56Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "> Just to make sure we're on the same page: X -> Y is a birational map just if it's a rational map and if the inverse map Y -> X also exists and is rational. In other words, it is correct to call the map M -> E birational.\r\n\r\n^ This is true.\r\n\r\nYes, the objection is in this part: \r\n\r\n> by evaluating **a pair** of rational functions called a birational map\r\n\r\nIn fact, we only evaluate **one** rational map, the one that goes from M -> E.\r\n\r\n\r\n",
              "createdAt": "2019-06-27T21:29:56Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDkzMTc1",
          "commit": {
            "abbreviatedOid": "f8f81f0"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:36:13Z",
          "updatedAt": "2019-06-27T21:36:13Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "To address this, I added a parenthetical clarifying that we say \"Edwards\" to mean both twisted (a != 1) and untwisted (a = 1).\r\n\r\nThis isn't a perfect solution, because Bernstein et al. (in the paper that introduced Twisted Edwards Curves, BBJLP08) use \"Edwards curve\" to mean \"a = 1\" (i.e., untwisted), and \"twisted Edwards curve\" to refer to the more general case that a may not be equal to 1.\r\n\r\nThe alternative, which is strictly correct but probably much more annoying to read, is to use the term \"twisted Edwards curve\" everywhere in the document. To me, this likely *reduces* clarity. (One reason for this is that, in general, adjectives like \"twisted\" intuitively appear to *restrict* rather than to *generalize* the word that they modify. While this isn't a hard-and-fast rule, most readers will assume this is true without even realizing they're doing it.)\r\n\r\nI'd rather annoy the small handful of people who both understand and care about the above distinction than confuse the much larger number of people who don't, but I understand the argument either way.",
              "createdAt": "2019-06-27T21:36:13Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDk2MzIw",
          "commit": {
            "abbreviatedOid": "f8f81f0"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:44:27Z",
          "updatedAt": "2019-06-27T21:44:28Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I prefer to name curves by their canonical name. As you can see in RFC7748 and RFC8032, the full name `twisted Edwards curves` is used without confusion.\r\n\r\nWhen referring to a twisted Edwards curve, they are also included the Edwards curves (a=1). So, no distinction must be done, since the birational map applies generally.\r\n\r\n",
              "createdAt": "2019-06-27T21:44:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDk5Mzk1",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:52:54Z",
          "updatedAt": "2019-06-27T21:52:55Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "OK, I just pushed a commit that writes \"twisted Edwards\" everywhere.\r\n\r\nI suggest that each of us compares the clarity with and without this commit. If it's clearer to slightly abuse terminology, is that extra clarity worth the abuse? Alternatively, maybe my thoughts on clarity above are a bit alarmist, and we should just use the correct terminology.\r\n\r\nI'm happy to go with whichever one people like.",
              "createdAt": "2019-06-27T21:52:54Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTIzNTcz",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:14:03Z",
          "updatedAt": "2019-06-27T23:14:03Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "This paragraph can be omitted or be in another place. Montgomery's trick is a well-known technique. The pseudo-code below already contain the trick.",
              "createdAt": "2019-06-27T23:14:03Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTI0NTIy",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:17:59Z",
          "updatedAt": "2019-06-27T23:18:00Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Consider to refactor as follows:\r\n```\r\nmap_to_curve_elligator2_edwards(u)\r\nInput: u, an element of F.\r\nOutput: (x, y), a point on E.\r\n\r\n1. (x1, y1) = map_to_curve_elligator2(u)    // (x1, y1) is on M\r\n2. t1 = y1 * B'\r\n3. t2 = x1 + 1\r\n4. t3 = t1 * t2\r\n5. t3 = inv0(t3)\r\n6.  x = t2 * t3\r\n7.  x = x * x1\r\n8.  y = x1 - 1\r\n9.  y = y * t3\r\n10.  y = y * t1\r\n11. e = y == 0\r\n12. y = CMOV(y, 1, e)\r\n13. return (x, y)\r\n```",
              "createdAt": "2019-06-27T23:17:59Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTI2MDM1",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:24:41Z",
          "updatedAt": "2019-06-27T23:24:42Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```\r\nphi(HM(x)) == HE(x)\r\n```\r\nI am not sure whether we can get this equation working at the hashing-to-curve level. The main reason is that both hashing methods are prefixed with different strings, which includes the name of curve in the prefix.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2019-06-27T23:24:41Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTI4MDM4",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:33:28Z",
          "updatedAt": "2019-06-27T23:33:28Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "> Making sure that the Edwards and Montgomery hashes always give equivalent results helps with this kind of compatibility, because it means that the Edwards PAKE library could use any conforming hash-to-Edwards implementation.\r\n\r\nIt is not clear to me, why to recommend two different hashes HE(x) and HM(x) that map to the \"same\" equivalent point (under certain birational mapping).\r\n\r\nWhat we need is 1 hash that covers any Montgomery curve and 1 hash that covers any Twisted Edwards curve.\r\n\r\nThe relation between curve25519 and edwards25519 is different to \r\nthe relation between curve448 and edwards448. These are special cases.\r\n\r\nI do not understand why the hash to curve method must carry with these relations. \r\n\r\n\r\n",
              "createdAt": "2019-06-27T23:33:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMwMTMy",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:42:46Z",
          "updatedAt": "2019-06-27T23:42:46Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I think I don't get it. The point of this PR is to break apart the definition of `birational_map` from the definition of `map_to_curve_elligator2_edwards`, and the above suggestion puts them back together. This is a problem because `birational_map` for existing curves is *not* the above map---see the map for Curve25519 from RFC7748, for example.",
              "createdAt": "2019-06-27T23:42:46Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMwODgy",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:45:56Z",
          "updatedAt": "2019-06-27T23:45:57Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Makes sense.",
              "createdAt": "2019-06-27T23:45:57Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMxNDY5",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:48:28Z",
          "updatedAt": "2019-06-27T23:48:28Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Or is the suggestion changing x' -> x1, and y' -> y1?",
              "createdAt": "2019-06-27T23:48:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMyNjAx",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:53:42Z",
          "updatedAt": "2019-06-27T23:53:43Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I want to understand all of this.\r\n\r\nFollowing the description of the document. It says that curve25519 and curve448 have special birational mappings and an implementor must follow them. Then, the document says that for all other cases, it should follow the `bitarional_map` you gave. \r\n\r\nSo let me rephrase in pseudo-code:\r\n```\r\nmap_to_curve_elligator2_edwards(u)\r\n(x1,y1) = elligator2(u)\r\n if curve == {edwards25519, edwards448}\r\n    use map \\phi from RFC7748\r\nelse\r\n   use map \\phi explicitly given as .....\r\nreturn (x,y) = \\phi(x1,y1)\r\n```\r\nIs this the recommendation given?",
              "createdAt": "2019-06-27T23:53:42Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM0ODcx",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:04:07Z",
          "updatedAt": "2019-06-28T00:04:07Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Question: how did you get B and B'? _or equivalently _ how do you convert between \r\n```\r\ny^2 = x^3 + A * x^2 + C * x\r\n```\r\nand\r\n```\r\nB y^2 = x^3 + A * x^2 +  x\r\n```\r\n?",
              "createdAt": "2019-06-28T00:04:07Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM1OTg2",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:10:01Z",
          "updatedAt": "2019-06-28T00:10:01Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "> I am not sure whether we can get this equation working at the hashing-to-curve level. The main reason is that both hashing methods are prefixed with different strings, which includes the name of curve in the prefix.\r\n\r\nThis is true *only* if hash-to-curve includes a ciphersuite tag. Right now it seems like most of the opinions expressed in #124 are against having a ciphersuite tag at the hash-to-curve level, so it's at least reasonable to believe that this could be made to work. But it's a good point that it's not clear that we're \"doing enough\" here.\r\n\r\n> It is not clear to me, why to recommend two different hashes HE(x) and HM(x) that map to the \"same\" equivalent point (under certain birational mapping).\r\n\r\nThe reason is that *in practice* people care about being able to use the Montgomery and Edwards forms of a curve interchangeably, so we should try to make sure that this standard accommodates this use-case.\r\n\r\nFor example, this issue came up as described in a comment in #107: initially the document suggested using a different birational map than the one in RFC7748, and we got pushback against this. So this is not just a hypothetical concern.",
              "createdAt": "2019-06-28T00:10:01Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM4MTk4",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:21:37Z",
          "updatedAt": "2019-06-28T00:21:37Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "See c56449fc41f0e0fdebfa3bd4e8e7e83cb6027a80",
              "createdAt": "2019-06-28T00:21:37Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM4NTE3",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:23:16Z",
          "updatedAt": "2019-06-28T00:23:16Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Not quite. The document says that *any* curve that already has a birational map specified in a standard should use that map. The examples we give are '25519 and '448, but it seems extremely likely that any Montgomery curve that gets standardized will end up standardizing an Edwards curve, too: if a curve is good enough for key exchange, it's good enough for EdDSA.\r\n\r\nSo the point is, if there's already a standardized birational map, use that one so that you get \"free\" compatibility between the Edwards and the Montgomery hashing. (As you pointed out above, this might break if we add a ciphersuite string---to me, this is all the more reason not to add one.)",
              "createdAt": "2019-06-28T00:23:16Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTQ0Nzg2",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:59:26Z",
          "updatedAt": "2019-06-28T00:59:26Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "OK, maybe I had too much caffeine earlier. Happy to stick with \"twisted\" everywhere :)",
              "createdAt": "2019-06-28T00:59:26Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTQ1MTc0",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T01:01:55Z",
          "updatedAt": "2019-06-28T01:01:55Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Also note: I implemented the described birational map for edwards448 in the `poc` directory. The map correctly transports points between edwards448 and an equivalent Montgomery curve (though not the one specified in RFC7748; that's a TODO for code update)",
              "createdAt": "2019-06-28T01:01:55Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg0MTg5",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T04:56:17Z",
          "updatedAt": "2019-06-28T04:56:18Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "FWIW, I was assuming we removed the ciphersuite string from this document, as @kwantam states above.",
              "createdAt": "2019-06-28T04:56:17Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MDE5Njg1",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-29T02:11:59Z",
          "updatedAt": "2019-06-29T02:11:59Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I think the conversation in #134 covers this now, right @armfazh?",
              "createdAt": "2019-06-29T02:11:59Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MDM4OTQ1",
          "commit": {
            "abbreviatedOid": "12194f7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2019-06-29T14:24:43Z",
          "updatedAt": "2019-06-29T14:24:49Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "\ud83d\udc4d thanks for adding the citation!",
              "createdAt": "2019-06-29T14:24:43Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NDg4MjQ3",
          "commit": {
            "abbreviatedOid": "d09fde5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks good, only few comments, but ready to move forward.",
          "createdAt": "2019-07-01T18:11:56Z",
          "updatedAt": "2019-07-01T18:39:07Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "When both `B` and `B'` are equal to 1, to avoid the case when `B' = -1`.",
              "createdAt": "2019-07-01T18:11:56Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            },
            {
              "originalPosition": 71,
              "body": "I am not sure where this restriction comes from \r\n```\r\nA^2 - 4 * B is non-square in F\r\n```\r\n",
              "createdAt": "2019-07-01T18:19:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n(a class of curves that includes Edwards curves)\r\n```",
              "createdAt": "2019-07-01T18:26:49Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            },
            {
              "originalPosition": 231,
              "body": "the input of `rational_map` function is always a point in Weierstrass form, so M cannot be in Montgomery form.",
              "createdAt": "2019-07-01T18:36:43Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTQ1Mzk5",
          "commit": {
            "abbreviatedOid": "d09fde5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T20:27:05Z",
          "updatedAt": "2019-07-01T20:27:05Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "It comes from Section 5.2 of the Elligator paper. This stipulation is necessary to ensure\r\n\r\n    v^3 + A * v^2 + B * v != 0\r\n\r\nwhich handles one exceptional case.\r\n\r\nNote that unlike Section 5.2 of Elligator, we do *not* stipulate that q = 1 mod 4, which means that it is possible for\r\n\r\n    1 + u * r^2 == 0\r\n\r\nThis is the remaining exceptional case for the mapping, and it is handled explicitly.",
              "createdAt": "2019-07-01T20:27:05Z",
              "updatedAt": "2019-07-01T20:37:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTQ3MzA4",
          "commit": {
            "abbreviatedOid": "5ad2439"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T20:31:45Z",
          "updatedAt": "2019-07-01T20:31:45Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Yes, I realized its purpose during the last part of my review, but I didn't remove this comment.",
              "createdAt": "2019-07-01T20:31:45Z",
              "updatedAt": "2019-07-01T20:31:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTQ5MzEx",
          "commit": {
            "abbreviatedOid": "5ad2439"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T20:36:28Z",
          "updatedAt": "2019-07-01T20:36:29Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "This isn't quite true: when using a standardized rational map (as in curve25519 or curve448), the rational map is from Montgomery to Edwards, not from Weierstrass to Edwards.\r\n\r\nBut: I've simplified the sentence in a way that (I think) addresses your concern.",
              "createdAt": "2019-07-01T20:36:28Z",
              "updatedAt": "2019-07-01T20:36:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzODk5MjIy",
      "title": "spacing around = and ==",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/136",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is minor. Just fixes some spacing issues in response to #105.",
      "createdAt": "2019-07-02T20:14:14Z",
      "updatedAt": "2019-07-02T21:08:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f20f8c73fa60cbbcdb40b68f5ac6f9cf877117fd",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "spacing_fixes",
      "headRefOid": "66e1bbd6e3f86c7902af4dabfb5add34221e2c35",
      "closedAt": "2019-07-02T20:20:44Z",
      "mergedAt": "2019-07-02T20:20:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8064073ef75c91b7ec5bf25877eb263f6d516832"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MTI3Njgz",
          "commit": {
            "abbreviatedOid": "66e1bbd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-02T20:20:38Z",
          "updatedAt": "2019-07-02T20:20:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTU5OTI4",
      "title": "ciphersuite table update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/138",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit is intended to address #95, #96, and #126.\r\n\r\n~~I'm pushing an early cut as @armfazh suggested in #129. I'll get the rest of the info into the document in the next couple hours, then we can talk about the formatting.~~",
      "createdAt": "2019-07-03T00:22:47Z",
      "updatedAt": "2019-08-14T01:36:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8064073ef75c91b7ec5bf25877eb263f6d516832",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "suite_table",
      "headRefOid": "adce053e2dd76762f83ad1ee75eb783b2221c667",
      "closedAt": "2019-07-08T18:47:39Z",
      "mergedAt": "2019-07-08T18:47:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4f6fbc6c6a12d55aa4680ab6555b95ea1c2e94ac"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've added the curves from my list in #126.\r\n\r\nThe last commit in this PR *removes* \"SIKEp503\" and \"SS132\" from the suites, though I'm not certain that we *must* do this. Why?\r\n\r\n- As far as I can tell (@armfazh, please correct me if I'm wrong, I know you've got lots of experience with SIDH/SIKE), the curve labeled SIKEp503 does not appear to be the curve in the SIKE proposal using the p503 parameters. Is this curve used somewhere else?\r\n   \r\n   The impl in poc/ell2supers.sage hashes to the curve y^2 = x^3 + 1 over F(2^250 * 3^159 - 1), but in general the SIKE curves appear to be over GF(p^2), not over GF(p).\r\n   \r\n   It also doesn't appear to be a curve specified for use with CSIDH (which *does* work over GF(p)). Maybe we can instead use the example y^2 = x^3 + x over the field defined by CSIDH/p511 (4 * 587 * k - 1), where k is the product of the first 73 odd primes, instead?\r\n\r\n- SS132 is pretty dismal security-wise, to the point where no one would ever use it... Maybe we can hash to y^2 = x^3 + 1 over the same p511 as above? This is also a supersingular curve that would work with the Boneh-Franklin method.\r\n\r\nOr: for now we can just leave both of the above out of the ciphersuites and concentrate on the others?",
          "createdAt": "2019-07-03T02:59:33Z",
          "updatedAt": "2019-07-03T03:31:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another thought with regard to the supersingular curves: maybe we can give optimized example code in the appendices for the two curves over CSIDH-p511 that I gave above, but not put them in the ciphersuites list. I realize that seems a bit strange, but I think it would be really nice to have at least one worked example for each mapping...",
          "createdAt": "2019-07-03T18:36:46Z",
          "updatedAt": "2019-07-03T18:36:46Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Or: for now we can just leave both of the above out of the ciphersuites and concentrate on the others?\r\nWe can stay with standardized curves for now. \r\n\r\n> Another thought with regard to the supersingular curves: maybe we can give optimized example code in the appendices for the two curves over CSIDH-p511 that I gave above, but not put them in the ciphersuites list. I realize that seems a bit strange, but I think it would be really nice to have at least one worked example for each mapping...\r\n\r\nI also agree that every mapping should have at least one curve example. Let's find well-known curves before creating artificial ones. \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-03T18:41:28Z",
          "updatedAt": "2019-07-03T18:41:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would be also great to have a list of suite string identifiers.\r\n\r\nIs the idea to put these in Section 8, maybe below the table that maps curve -> section?",
          "createdAt": "2019-07-03T22:05:46Z",
          "updatedAt": "2019-07-03T22:05:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh do the latest changes more or less address your concerns?\r\n\r\nI'd love if we could land this tomorrow so that we have time for some sanity-check passes before Monday (the deadline)!",
          "createdAt": "2019-07-07T05:37:01Z",
          "updatedAt": "2019-07-07T05:37:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDgwMDA5",
          "commit": {
            "abbreviatedOid": "dd3aefc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a great refactor! I quite like the new format. The suite parameters look good to me (I didn't check the NIST or pairing-friendly curve constants -- only curve25519 and curve448), and parsing them seems straightforward. ",
          "createdAt": "2019-07-03T13:19:20Z",
          "updatedAt": "2019-07-03T13:23:42Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Should we also explicitly note that \"-NU\" suites are for encodings?",
              "createdAt": "2019-07-03T13:19:20Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 239,
              "body": "Question: should we port these definitions to an appendix in this document to make things self contained (in IETF documents)? ",
              "createdAt": "2019-07-03T13:20:36Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 95,
              "body": "Should we leave a note that newly standardized curves SHOULD provide similar suites?",
              "createdAt": "2019-07-03T13:22:01Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjY4NzE2",
          "commit": {
            "abbreviatedOid": "dd3aefc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T18:32:52Z",
          "updatedAt": "2019-07-03T18:32:53Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Yes, this is a great idea. I'll add them.",
              "createdAt": "2019-07-03T18:32:52Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzE1ODk3",
          "commit": {
            "abbreviatedOid": "e7b4fb9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:19:56Z",
          "updatedAt": "2019-07-03T20:19:56Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Done!",
              "createdAt": "2019-07-03T20:19:56Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIxNjI4",
          "commit": {
            "abbreviatedOid": "a588965"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "It would be also great to have a list of suite string identifiers.\r\n\r\n",
          "createdAt": "2019-07-03T20:33:30Z",
          "updatedAt": "2019-07-03T20:53:18Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\n- A: 486662\r\n- B: 1\r\n```",
              "createdAt": "2019-07-03T20:33:30Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 173,
              "body": "```suggestion\r\n - a = -1\r\n - d = 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\r\n```",
              "createdAt": "2019-07-03T20:33:59Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 195,
              "body": "```suggestion\r\n- A = 156326\r\n- B = 1\r\n- f: Elligator 2 method, {{elligator2}}\r\n```",
              "createdAt": "2019-07-03T20:35:32Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 234,
              "body": "```suggestion\r\nThe suites BLS12381G1-SHA256-SSWU-RO and BLS12381G1-SHA256-SSWU-NU\r\n```",
              "createdAt": "2019-07-03T20:38:06Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 234,
              "body": "This is the same pattern used previously in P-256 curve. The (-) symbol was removed.",
              "createdAt": "2019-07-03T20:39:16Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 240,
              "body": "the curve equation of `E'` must be stated explicitly.",
              "createdAt": "2019-07-03T20:42:28Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nThe suites BLS12381G2-SHA256-SSWU-RO and BLS12381G2-SHA256-SSWU-NU\r\n```",
              "createdAt": "2019-07-03T20:43:08Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 250,
              "body": "I didn't check whether `Z` was generated using the method described above.",
              "createdAt": "2019-07-03T20:44:02Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 247,
              "body": "I think it is better to define the extension field and its irreducible polynomial before introduce curve parameters",
              "createdAt": "2019-07-03T20:45:15Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 83,
              "body": "what is the meaning of the `eff` part?\r\n`h` is simpler.\r\nEven tough, the distinction between `h` and `h_eff` only differs for pairing curves on the specific case of G2.\r\n",
              "createdAt": "2019-07-03T20:51:04Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUyODY2",
          "commit": {
            "abbreviatedOid": "a588965"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:57:10Z",
          "updatedAt": "2019-07-03T21:57:11Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "\"eff\" is for \"effective,\" because in some cases h_eff != h. I'm trying to avoid overloading h, which we use elsewhere to mean the integer such that n = h * r.\r\n\r\nDo you think there's a better alternative that doesn't overlap with h? maybe `h'`?",
              "createdAt": "2019-07-03T21:57:11Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUzMTQ2",
          "commit": {
            "abbreviatedOid": "a588965"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:58:05Z",
          "updatedAt": "2019-07-03T21:58:06Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Right now it's in the appendix. Do you prefer to pull it inline here, and only have the isogeny maps in the appendix?",
              "createdAt": "2019-07-03T21:58:06Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3MDY1",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:02Z",
          "updatedAt": "2019-07-03T22:12:02Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "rolled this into another edit",
              "createdAt": "2019-07-03T22:12:02Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3MDk2",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:10Z",
          "updatedAt": "2019-07-03T22:12:10Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "rolled this into another edit",
              "createdAt": "2019-07-03T22:12:10Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3MTQx",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:18Z",
          "updatedAt": "2019-07-03T22:12:18Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "rolled this into another edit",
              "createdAt": "2019-07-03T22:12:18Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3Mjc5",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:47Z",
          "updatedAt": "2019-07-03T22:12:48Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Better now?",
              "createdAt": "2019-07-03T22:12:47Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzYxMjQ1",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:28:18Z",
          "updatedAt": "2019-07-03T22:28:18Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Yes, it is.",
              "createdAt": "2019-07-03T22:28:18Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzYxOTg5",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:31:18Z",
          "updatedAt": "2019-07-03T22:31:19Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "For any suite for which `h=h_eff`, list only `h`.\r\nFor the special cases, you can list both constants: the cofactor, (e.g. `h=4`) and the effective cofactor (e.g. `h_eff = h * 10 = 40`) ",
              "createdAt": "2019-07-03T22:31:18Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzcwODg0",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T23:09:47Z",
          "updatedAt": "2019-07-03T23:09:48Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I prefer to have suite descriptions as explicit as possible.\r\nFor the case of the 11-isogeny, you can list only the point generator of the kernel, and cite to Vel\u00fa formulas for calculating the isogeny, which I assume is the method followed by the Sage script you provide in the paper.",
              "createdAt": "2019-07-03T23:09:47Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzcwOTAz",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T23:09:53Z",
          "updatedAt": "2019-07-03T23:09:53Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "```suggestion\r\n- H: SHA-256\r\n- iso\\_map: the isogeny map to E' from {{WB19}}; see {{appx-bls12381-g1}}\r\n```",
              "createdAt": "2019-07-03T23:09:53Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzkxMTgw",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:08:36Z",
          "updatedAt": "2019-07-04T01:08:36Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "It seems like specifying the isogeny via the kernel could work, but I have a couple concerns:\r\n\r\n- the target audience is implementors, who may not be familiar with Velu's formulas. My guess is that most would prefer being given the rational map explicitly rather than a more compact description that takes a lot more work to turn into code, and thus is more likely to cause errors.\r\n\r\n- specifying the kernel of the isogeny only specifies the rational map up to sign: negating the sign of the y-coordinate map must give an isogeny with the same kernel (because an isogeny is a group homomorphism, negating the point at infinity yields the point at infinity, and negating any other point does not).\r\n\r\nI suppose we could specify both the kernel and the rational map, but it's not obvious that the extra information is particularly useful: if someone *really* wants the kernel, they can easily compute it from E, E', and the degree of the isogeny, or they can just go look in the paper...",
              "createdAt": "2019-07-04T01:08:36Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzkxNTU0",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:11:11Z",
          "updatedAt": "2019-07-04T01:11:11Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "> I prefer to have suite descriptions as explicit as possible.\r\n\r\nE' is given in an appendix of *this document* (see e7b4fb9), which seems to me to be no less explicit than putting it in this section. But I think it's totally reasonable to put the description of E' here, if you think that's better.",
              "createdAt": "2019-07-04T01:11:11Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzkzNTU2",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:24:47Z",
          "updatedAt": "2019-07-04T01:24:48Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I think I didn't make my rationale clear (which probably means the text needs to be improved!):\r\n\r\n- `h` is *not* an explicit part of the description of a suite (though it's implicit in E and F, of course). This is intentional: it would be redundant to include it, and it would cause confusion in the case that `h_eff` != `h`.\r\n\r\n- In contrast, `h_eff` is not (always) implicitly defined by the other suite parameters, because some curves admit faster cofactor clearing methods.\r\n\r\n- The purpose of specifying `h_eff` is to ensure that all users of a suite clear the cofactor in a compatible way without demanding that everyone use the most optimal implementation. The reason to specify the cofactor clearing method as a scalar is that this is the \"least common denominator\": it seems reasonable to assume that anyone who can hash to the curve can also do scalar multiplication.\r\n\r\nSo: I think it would be both unnecessary and confusing to include `h` in any suite, and as a result I really don't like the idea of specifying `h_eff` in terms of `h`.\r\n\r\nI will make some edits, both here and potentially in {{cofactor-clearing}}, to make all of the above clearer.",
              "createdAt": "2019-07-04T01:24:48Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzk1MjQ1",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:35:15Z",
          "updatedAt": "2019-07-04T01:35:15Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "I think I don't understand this edit: `H` is common to G1 and G2, so it's specified in the \"common parameters,\" below.",
              "createdAt": "2019-07-04T01:35:15Z",
              "updatedAt": "2019-07-04T23:53:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODA3MTUx",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T02:46:47Z",
          "updatedAt": "2019-07-04T02:46:48Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I pushed some edits that I hope clarifies and addresses this concern.",
              "createdAt": "2019-07-04T02:46:47Z",
              "updatedAt": "2019-07-04T02:46:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODA3MjM5",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T02:47:21Z",
          "updatedAt": "2019-07-04T02:47:21Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I pushed a commit that pulls E' definitions inline and only refers to the appx for the iso_map definitions.",
              "createdAt": "2019-07-04T02:47:21Z",
              "updatedAt": "2019-07-04T02:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4Njk4NTIx",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T05:58:01Z",
          "updatedAt": "2019-07-08T05:58:01Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "Ok, disregard the suggestion.",
              "createdAt": "2019-07-08T05:58:01Z",
              "updatedAt": "2019-07-08T05:58:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4Njk4OTY3",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T06:00:05Z",
          "updatedAt": "2019-07-08T06:00:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NzAwMTI1",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T06:05:23Z",
          "updatedAt": "2019-07-08T06:05:24Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "it looks good",
              "createdAt": "2019-07-08T06:05:23Z",
              "updatedAt": "2019-07-08T06:05:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDIxMTUw",
      "title": "domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/139",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This essentially captures what's in #124:\r\n\r\n- add \"HASH-TO-CURVE\" literal in hash_to_base for H() separation\r\n\r\n- change ctr argument in encode_to_curve for free separation from hash_to_curve\r\n\r\n- add a new section in roadmap with requirements for domain separation\r\n\r\n- add a new definition for domain separation\r\n\r\nNote that this does *not* comprehend #137. I think we can treat that as a separate question for now.",
      "createdAt": "2019-07-03T06:30:39Z",
      "updatedAt": "2019-07-04T23:58:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "37d5f4dcb62b097af1afeb2ff3e8dd785bebf8b1",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "domain_separation",
      "headRefOid": "b500bffa40ceec2851191d483ccea17f21372c99",
      "closedAt": "2019-07-04T21:18:53Z",
      "mergedAt": "2019-07-04T21:18:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f764a27b30ca3cf1562636396bcde68ffe342b53"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDQ5MTg0",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:23:42Z",
          "updatedAt": "2019-07-03T12:23:43Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Would we consider making HASH-TO-CURVE shorter (e..g \"H2C\"/ \"HTC\"), and potentially truncating H(msg) such that we can fit m' into a single block in the loop below?\r\n\r\nE.g. the input to the hash in the loop becomes `\"H2C\" || H(msg)[..len(H) - 6] || I2OSP(ctr, 1)  || I2OSP(i, 1) || I2OSP(j, 1)`?",
              "createdAt": "2019-07-03T12:23:42Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDg0MzI0",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The initial text looks good to me. I think some more clarity and examples would help drive the point home, so approving for now. Thanks, @kwantam!",
          "createdAt": "2019-07-03T13:26:08Z",
          "updatedAt": "2019-07-03T13:50:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nCryptographic protocols that use random oracles are often analyzed\r\n```",
              "createdAt": "2019-07-03T13:26:09Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nunder the assumption that random oracles answer only queries generated\r\n```",
              "createdAt": "2019-07-03T13:28:21Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 11,
              "body": "Perhaps add:\r\n\r\n```\r\nThat is, let R() be a random oracle used by protocols P1 and P2. If P1 and P2 ever query R with the same value x, the assumption above is violated.\r\n```\r\n\r\nAnd maybe then show how P1 and P2 would use R1 and R2 (as defined below) to address this?",
              "createdAt": "2019-07-03T13:36:07Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nBecause of these domain separation tags, queries to R1 and R2 cannot yield identical queries to R.\r\n```",
              "createdAt": "2019-07-03T13:37:18Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nWhen invoking hash\\_to\\_curve in a higher-level protocol, implementors MUST use domain separation\r\n```",
              "createdAt": "2019-07-03T13:37:54Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nif possible, though it is not required in this case.\r\n```",
              "createdAt": "2019-07-03T13:38:25Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 50,
              "body": "Is the expectation that if one had two hash-to-curve functions H1 and H2 targeting the *same* curve, then H1 = H2? ",
              "createdAt": "2019-07-03T13:43:14Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 50,
              "body": "It'd be good to clarify why this requirement is needed. (That is, to avoid overlapping hash2base output IIUC.)",
              "createdAt": "2019-07-03T13:43:39Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 77,
              "body": "Would it help to give an example of a protocol that needs domain separation internally, too?",
              "createdAt": "2019-07-03T13:47:21Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 36,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-03T13:48:54Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 101,
              "body": "Perhaps in a separate issue?",
              "createdAt": "2019-07-03T13:49:29Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjY3NDA1",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, ",
          "createdAt": "2019-07-03T18:30:19Z",
          "updatedAt": "2019-07-03T18:30:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIzODg0",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:38:53Z",
          "updatedAt": "2019-07-03T20:38:53Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "we'd have to truncate a reasonable amount to avoid going past one block, because SHA-256 adds at least 65 bits of padding to the end of the message. Specifically, the padding is\r\n\r\n- append a single '1' bit\r\n- append k '0' bits where 0 <= k < 512 and bitlen(msg) + 1 + k + 64 is divisible by 512\r\n- append a 64-bit representation of bitlen(msg)\r\n\r\nso it would have to be something like H(msg)[..len(H) - 15], which is pretty extreme.\r\n\r\nAlso, we might want to resolve #137 first, since that would moot this discussion.",
              "createdAt": "2019-07-03T20:38:53Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzI4MDcw",
          "commit": {
            "abbreviatedOid": "1387d77"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:48:49Z",
          "updatedAt": "2019-07-03T20:48:49Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Yes, unless they're explicitly separated. I suppose I should clarify this point.",
              "createdAt": "2019-07-03T20:48:49Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzQwMTcx",
          "commit": {
            "abbreviatedOid": "c4ee7eb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:19:17Z",
          "updatedAt": "2019-07-03T21:19:17Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yeah, I think the first paragraph is unclear in a couple ways. I'll try to address and incorporate the above.",
              "createdAt": "2019-07-03T21:19:17Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMTM0",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:51:28Z",
          "updatedAt": "2019-07-03T21:51:29Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I pushed an edit to address this.",
              "createdAt": "2019-07-03T21:51:29Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMTcx",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:51:36Z",
          "updatedAt": "2019-07-03T21:51:36Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I pushed an edit to address this.",
              "createdAt": "2019-07-03T21:51:36Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMjEx",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:51:43Z",
          "updatedAt": "2019-07-03T21:51:43Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I pushed an edit to address this.",
              "createdAt": "2019-07-03T21:51:43Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMzI3",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:52:09Z",
          "updatedAt": "2019-07-03T21:52:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done, I think.",
              "createdAt": "2019-07-03T21:52:09Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NjMyMTIw",
      "title": "Replace hash_to_base PRG with HKDF-Expand.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #137.",
      "createdAt": "2019-07-04T15:49:15Z",
      "updatedAt": "2022-02-18T16:42:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f764a27b30ca3cf1562636396bcde68ffe342b53",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/hkdf",
      "headRefOid": "041994685c8c586994d659d325539c9b4bbbade0",
      "closedAt": "2019-07-06T13:27:44Z",
      "mergedAt": "2019-07-06T13:27:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "95e8aedb8db7a4bec2152f126d5e8c2f653842f2"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "An alternative suggestion:\r\n\r\nWhat if we did\r\n\r\n```\r\nm' = H(msg)\r\nfor i in (1, ..., m):\r\n  info = \"H2C\" || I2OSP(ctr, 1) || I2OSP(i, 1)\r\n  t = HKDF-Expand-H(m', info, L)\r\n  e_i = OS2IP(t) mod p\r\nreturn u = (e_1, ..., e_m)\r\n```\r\n\r\nThis guarantees that the HMAC key (`m'`) is shorter than the block length. Moreover, the `info` argument to HKDF-Expand is 5 bytes, which guarantees the minimum possible number of H invocations in HKDF-Expand (4 per iteration, because of HMAC) for the major hash functions I'm aware of (see below).\r\n\r\nAlso, aesthetically this is slightly nicer, since it moves all of the hash-to-curve--specific domain separation pieces (\"H2C\", ctr, i) into one place.\r\n\r\nFinally, this change sort of anticipates the suggestion in my next comment.\r\n\r\n---\r\n\r\nLet's check to make sure that HMAC uses the minimum number of H invocations in all cases.\r\n\r\nRecall that `HMAC(k, msg) = H( (k XOR OPAD) || H( (k XOR IPAD) || msg ) )`. For simplicity, I'm assuming that k is one block long (in reality, it's always padded or hashed-and-padded to that length, so this is a reasonable simplification).\r\n\r\nHKDF-Expand(k, info, L) in the worst case invokes\r\n\r\n    HMAC(k, H(something) || info || b)\r\n\r\nwhere b is 1 byte long. So what we need to check is that `H(something) || info || b` is short enough for each hash function of interest.\r\n\r\n- **SHA-2** adds at least 9 bytes (rounding up) of padding to its argument, so when H is a SHA-2 function, the argument to the inner invocation of H in the HMAC invocation in HKDF-Expand is block_len + hash_len + len(info) + 1 + 9 bytes long, and we want this value to be at most 2 * block_len. Worst case is SHA2-256, which has block_len = 64, hash_len = 32. In this case, len(info) must be at most 64 - 32 - 10 = 22 bytes. :heavy_check_mark:\r\n\r\n- **SHA-3** adds at least 1 byte (rounding up) of padding to its argument, so when H is a SHA-3 function, the argument to the inner H invocation is block_len + hash_len + len(info) + 1 + 1 bytes long. Worst case is SHA3-512, which has block_len = 72, hash_len = 64. In this case, len(info) must be at most 72 - 64 - 2 = 6 bytes :heavy_check_mark:\r\n\r\n- **BLAKE2** doesn't force padding, so when H is a BLAKE function, the argument to the inner H invocation is block_len + hash_len + len(info) + 1 bytes long. Worst case is BLAKE2s256, which has block_len = 64, hash_len = 32. In this case, len(info) must be at most 64 - 32 - 1 = 31 bytes :heavy_check_mark:\r\n\r\nSo it looks like \"H2C\" is preferred if we want to avoid another compression function invocation in the absolute worst case, which is SHA3-512.",
          "createdAt": "2019-07-04T23:03:15Z",
          "updatedAt": "2019-07-04T23:52:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another question to consider: should we use HKDF-Extract to compute `m'`?\r\n\r\n(Just spitballing here, not sure whether I like it or not. Also, I'm going to assume for concreteness that we're going with the suggested change in [my prior comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#issuecomment-508588103). This could work either way, though.)\r\n\r\nHKDF-Extract takes two arguments, `salt` and `msg`. In the spirit of @hoeteck's suggestion in #124 (and a suggestion from Dan out-of-band), we might require higher-level protocols to set the value for `salt` based on their domain separation string.\r\n\r\n~~~\r\nhash_to_base(msg, ctr)\r\n\r\nParameters:\r\n- DSS, a domain separation string chosen according to the\r\n  guidelines given in {{domain-separation}}.\r\n- H, a cryptographic hash function.\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter\r\n  of the cryptosystem (e.g., k = 128).\r\n- HKDF-Extract-H is the HKDF-Extract function of RFC5869\r\n  instantiated with hash function H.\r\n- HKDF-Expand-H is the HKDF-Expand function of RFC5869\r\n  instantiated with hash function H.\r\n\r\nInputs:\r\n- msg is the message to hash.\r\n- ctr is 0, 1, or 2.\r\n  This is used to efficiently create independent\r\n  instances of hash_to_base (see discussion above).\r\n\r\nOutput:\r\n- u, an element in F.\r\n\r\nSteps:\r\n1. m' = HKDF-Extract-H(H(DSS), msg)\r\n2. for i in (1, ..., m):\r\n3.   info = \"H2CURVE\" || I2OSP(ctr, 1) || I2OSP(i, 1)\r\n4.   t = HKDF-Expand-H(m', info, L)\r\n5.   e_i = OS2IP(t) mod p\r\n6. return u = (e_1, ..., e_m)\r\n~~~\r\n\r\nIf DSS is fixed, H(DSS) can be precomputed to save one invocation of H. Also, this lets people use domain separation strings of arbitrary length with effectively no performance penalty.",
          "createdAt": "2019-07-04T23:18:10Z",
          "updatedAt": "2019-07-04T23:55:24Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "As an aside, [STROBE](https://strobe.sourceforge.io/) would handle this role fairly cleanly too.",
          "createdAt": "2019-07-04T23:29:18Z",
          "updatedAt": "2019-07-04T23:29:18Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> As an aside, [STROBE](https://strobe.sourceforge.io/) would handle this role fairly cleanly too.\r\n\r\nGreat! Since this is a very general framework, is there a specific STROBE-related hash function that you have in mind here?\r\n\r\n(My guess is that our initial ciphersuite specs will all use hashes in the SHA2 family, but I'm certain that other people will eventually want to use, e.g., BLAKE. So probably the action item with respect to STROBE is just to make sure that we're not accidentally specifying something that's incredibly inefficient.)",
          "createdAt": "2019-07-04T23:49:34Z",
          "updatedAt": "2019-07-04T23:50:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> STROBE would handle this role fairly cleanly too.\r\n\r\nThat is good to know, though I don't think we could adopt it so easily at the moment.",
          "createdAt": "2019-07-05T03:51:22Z",
          "updatedAt": "2019-07-05T03:51:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Another question to consider: should we use HKDF-Extract to compute `m'`?\r\n>\r\n> (Just spitballing here, not sure whether I like it or not. Also, I'm going to assume for concreteness that we're going with the suggested change in [my prior comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#issuecomment-508588103). This could work either way, though.)\r\n> \r\n> HKDF-Extract takes two arguments, `salt` and `msg`. In the spirit of @hoeteck's suggestion in #124 (and a suggestion from Dan out-of-band), we might require higher-level protocols to set the value for `salt` based on their domain separation string.\r\n\r\nI'm fine with this change, though I think I'd remove the initial hash computation of DSS. My reasoning being that HKDF will compute this hash anyway if |DSS| > H's output size anyway. Thanks for the suggestion!\r\n\r\n> \r\n> ```\r\n> hash_to_base(msg, ctr)\r\n> \r\n> Parameters:\r\n> - DSS, a domain separation string chosen according to the\r\n>   guidelines given in {{domain-separation}}.\r\n> - H, a cryptographic hash function.\r\n> - F, a finite field of characteristic p and order q = p^m.\r\n> - L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter\r\n>   of the cryptosystem (e.g., k = 128).\r\n> - HKDF-Extract-H is the HKDF-Extract function of RFC5869\r\n>   instantiated with hash function H.\r\n> - HKDF-Expand-H is the HKDF-Expand function of RFC5869\r\n>   instantiated with hash function H.\r\n> \r\n> Inputs:\r\n> - msg is the message to hash.\r\n> - ctr is 0, 1, or 2.\r\n>   This is used to efficiently create independent\r\n>   instances of hash_to_base (see discussion above).\r\n> \r\n> Output:\r\n> - u, an element in F.\r\n> \r\n> Steps:\r\n> 1. m' = HKDF-Extract-H(H(DSS), msg)\r\n> 2. for i in (1, ..., m):\r\n> 3.   info = \"H2CURVE\" || I2OSP(ctr, 1) || I2OSP(i, 1)\r\n> 4.   t = HKDF-Expand-H(m', info, L)\r\n> 5.   e_i = OS2IP(t) mod p\r\n> 6. return u = (e_1, ..., e_m)\r\n> ```\r\n> \r\n> If DSS is fixed, H(DSS) can be precomputed to save one invocation of H. Also, this lets people use domain separation strings of arbitrary length with effectively no performance penalty.\r\n",
          "createdAt": "2019-07-05T04:04:41Z",
          "updatedAt": "2019-07-05T04:04:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It wasn't clear to me that it would be quite this easy to invoke HKDF, because I was thinking that the size of the PRK argument to HKDF was restricted to the output length of H, rather than the block size of H. But as far as I can tell, this mostly works for the hash functions we'd expect people to use (but see below).\r\n\r\nThis seems to resolve itself by just using Extract() before Expand(). :-)",
          "createdAt": "2019-07-05T04:07:13Z",
          "updatedAt": "2019-07-05T04:07:13Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I think only the keccak-f(1600) based STROBE variant has any implementations right now.  \r\n\r\n@chris-wood  Are you saying the hash-to-field functions call extract in a tree like way?  It's true STROBE does not add so much for trees where you'd clone the state all the time.  You'd need to impose an ordering on the extractions to exploit STROBE optimally.  And doing so encurages constraints on the order in which developers extract field elements.  \r\n\r\nIt's actually common to clone STROBE states, which may still save some stack space over HKDF, but not much, and maybe worse with hand optimizations.  I suppose the most efficient scheme for extracting a tree is to simply use ChaCha20, assigning nonces in a tree-like way using \"heap addressing\".\r\n\r\nAll this is moot because BLS is really for consensus protocols, not \"accounts\", so nobody will ever run BLS on ridiculously constrained devices anyways, like say a Ledger device. ",
          "createdAt": "2019-07-05T07:33:07Z",
          "updatedAt": "2019-07-05T07:33:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood Are you saying the hash-to-field functions call extract in a tree like way? It's true STROBE does not add so much for trees where you'd clone the state all the time. You'd need to impose an ordering on the extractions to exploit STROBE optimally. And doing so encurages constraints on the order in which developers extract field elements.\r\n\r\nNo, sadly, my comment was more reflective about IETF than it was about anything technical. (We'd need to fully specify STROBE here or elsewhere prior to adopting it.)",
          "createdAt": "2019-07-05T13:30:21Z",
          "updatedAt": "2019-07-05T13:30:21Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Right, I'm actually not convinced STROBE is optimal anyways.  I'd think the `meta_ad` used for domain separation could probably safely xor into another part of the state in parallel to the main data xor, thus reducing keccak invocations.  Also you'd want some fast input command analogous to kangarootwelve.  And some ChaCha based variant.  Anyways sorry for the derail..",
          "createdAt": "2019-07-05T17:31:56Z",
          "updatedAt": "2019-07-05T17:31:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Awesome!\r\n\r\nI just realized there's one more bit of inconsistency that this PR should fix: the description in {{hashtobase-perf}}. I opened #143 against the PR branch because suggested edits can't yet do multiline as far as I can tell.",
          "createdAt": "2019-07-05T18:27:49Z",
          "updatedAt": "2019-07-05T18:27:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Nice! Just one tiny annoyance, sorry...\r\n\r\nNits are always appreciated! No need to apologize.",
          "createdAt": "2019-07-06T13:28:05Z",
          "updatedAt": "2019-07-06T13:28:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MTc1NTk0",
          "commit": {
            "abbreviatedOid": "e58ee2b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is great.\r\n\r\nIt wasn't clear to me that it would be quite this easy to invoke HKDF, because I was thinking that the size of the `PRK` argument to HKDF was restricted to the *output* length of H, rather than the block size of H. But as far as I can tell, this mostly works for the hash functions we'd expect people to use (but see below).\r\n\r\n~~We will have to stage this and #139 because the definition of `m'` changes in that PR. (EDIT: #139 is now merged, so we'll have to do some conflict resolution here.)~~\r\n\r\nAssuming we go with the string \"HASH-TO-CURVE\" as in #139, the length of `m'` is 14 + H_output_len bytes. Just for sanity, let's see whether this works with the hash functions we might care to use:\r\n\r\n- 224-bit hashes: len(`m'`) = 42 bytes\r\n  - SHA2-224 block size = 64 bytes :heavy_check_mark:\r\n  - SHA3-224 block size = 144 bytes :heavy_check_mark:\r\n  - BLAKE2s224 block size = 64 bytes :heavy_check_mark:\r\n- 256-bit hashes: len(`m'`) = 46 bytes\r\n  - SHA2-256 block size = 64 bytes :heavy_check_mark:\r\n  - SHA3-256 block size = 136 bytes :heavy_check_mark:\r\n  - BLAKE2s256 block size = 64 bytes :heavy_check_mark:\r\n  - BLAKE2b256 block size = 128 bytes :heavy_check_mark:\r\n- 384-bit hashes: len(`m'`) = 62 bytes\r\n  - SHA2-384 block size = 128 bytes :heavy_check_mark:\r\n  - SHA3-384 block size = 104 bytes :heavy_check_mark:\r\n  - BLAKE2b384 block size = 128 bytes :heavy_check_mark:\r\n- 512-bit hashes: len(`m'`) = 78 bytes\r\n  - SHA2-512 block size = 128 bytes :heavy_check_mark:\r\n  - SHA3-512 block size = 72 bytes :x:    hmmmm\r\n  - BLAKE2b512 block size = 128 bytes :heavy_check_mark:\r\n\r\nSo the only one that's a little weird is SHA3-512. Maybe we should consider replacing \"HASH-TO-CURVE\" with \"H2CURVE\", which is 6 bytes shorter and thus works with SHA3-512, or even just \"H2C\" as @samscott89 has suggested elsewhere.\r\n\r\n(Note that len(`m'`) > block size isn't fatal---it just requires, per RFC2104, hashing `m'` *again* to give an HMAC key that is shorter than the block length. We should probably avoid this.)",
          "createdAt": "2019-07-04T21:55:59Z",
          "updatedAt": "2019-07-05T17:56:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think mentioning the counter here distracts from the point (security) and sort of breaks the organization of the section (`ctr` isn't actually introduced until ~25 lines down, so the reader wonders \"wait, did I miss something? what counter???\").\r\n\r\nAlso, I think it would be nice to retain the example.\r\n\r\nMaybe:\r\n\r\n```\r\nTo obtain such an integer, HKDF {{RFC5869}} is used to expand the input msg\r\nto a L-byte string, where L = ceil((ceil(log2(p)) + k) / 8); this string is then interpreted\r\nas an integer via OS2IP {{RFC8017}}.\r\nFor example, for p a 255-bit prime and k = 128-bit security, L = ceil((255 + 128) / 8) = 48 bytes.\r\n```",
              "createdAt": "2019-07-04T21:55:59Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter of the cryptosystem (e.g., k = 128).\r\n- HKDF-Expand-H is the HKDF-Expand function from RFC5869 instantiated with hash function H.\r\n```",
              "createdAt": "2019-07-04T21:58:33Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 44,
              "body": "Along with the suggestion to make L a parameter, I suggest removing this line and renumbering.",
              "createdAt": "2019-07-04T21:59:51Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n4.   t = HKDF-Expand-H(m', I2OSP(i, 1), L)\r\n```",
              "createdAt": "2019-07-04T22:00:23Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 20,
              "body": "Suggest removing the second sentence (\"It requires...\") and instead defining HKDF-Expand-H in the Parameters section below, per one of my other comments.",
              "createdAt": "2019-07-04T22:01:59Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExNjA4",
          "commit": {
            "abbreviatedOid": "e58ee2b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:45:58Z",
          "updatedAt": "2019-07-05T03:45:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I figured keeping \"counter\" (rather than a reference to `car`) as a parenthetical was enough for the curious, though you're right in that it's unnecessary information at this point. I'm fine with the example. I just took it out since it's a pretty trivial computation.",
              "createdAt": "2019-07-05T03:45:58Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExNzQ0",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:46:55Z",
          "updatedAt": "2019-07-05T03:46:56Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Works for me!",
              "createdAt": "2019-07-05T03:46:55Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExNzkz",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:47:20Z",
          "updatedAt": "2019-07-05T03:47:20Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Hmm, I'm not familiar with this way of indicating H. Typically it's is inferred from context, which I think is clear here.",
              "createdAt": "2019-07-05T03:47:20Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExOTAw",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:48:13Z",
          "updatedAt": "2019-07-05T03:48:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yep, that's cleaner! Will remove.",
              "createdAt": "2019-07-05T03:48:13Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjEyMTQ1",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:50:07Z",
          "updatedAt": "2019-07-05T03:50:07Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "(Read your suggestion below, and provided it's defined as a parameter then this works great. Will adopt it.)",
              "createdAt": "2019-07-05T03:50:07Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjMxMjk4",
          "commit": {
            "abbreviatedOid": "1736233"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great!\r\n\r\nThese are pretty small nits, even though they look like a bunch of comments...\r\n\r\nOne other small thing: should we add a forward ref from {{domain-separation}} to here?\r\n\r\nMaybe a standalone paragraph before the one that starts \"Care is required...\" that says something like\r\n\r\n~~~\r\n{{hashtobase}} specifies how to apply a domain separation tag.\r\n~~~",
          "createdAt": "2019-07-05T05:56:25Z",
          "updatedAt": "2019-07-05T06:23:59Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Argh. Just realized that references inside fenced code blocks don't work (but maybe there's some escape sequence syntax for them?).\r\n\r\nAlso, I just realized that calling it a \"string\" rather than a \"tag\" breaks with the terminology elsewhere. So maybe we should say \"DST\" instead?\r\n\r\nSeems like there are a couple options: either we write in \"Section 4.1\" (or whatever) and then just make sure to keep it up-to-date, or we add some words in {{hashtobase-sec}} discussing the DSS parameter, put the crossref to {{domain-separation}} there, and then say something like\r\n~~~\r\n- DST, a domain separation tag (see discussion above).\r\n~~~\r\nlike we currently do for `ctr`.\r\n\r\nI guess I lean towards the second choice. Thoughts?\r\n\r\n([I've proposed](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#discussion_r300552314) specific text for {{hashtobase-sec}}, in case you agree.)",
              "createdAt": "2019-07-05T05:56:26Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 12,
              "body": "Suggested text vis-a-vis my [other comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#discussion_r300548990):\r\n\r\n```suggestion\r\n\r\n{{domain-separation}} discusses requirements for domain separation and recommendations\r\nfor choosing domain separation tags.\r\nThe hash\\_to\\_curve function takes such a tag as a parameter, DST; this is the\r\nRECOMMENDED way of applying domain separation.\r\nAs an alternative, implementations MAY instead prepend a domain separation tag to the\r\ninput msg; in this case, DST SHOULD be the empty string.\r\n\r\n```",
              "createdAt": "2019-07-05T06:14:44Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 34,
              "body": "Super nitpicky (and totally my fault): maybe break \"parameter\" onto the next line to keep line lengths approximately equal?\r\n\r\n:sweat:",
              "createdAt": "2019-07-05T06:17:59Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 20,
              "body": "nit (sorry...)\r\n\r\n```suggestion\r\nThe following procedure implements hash\\_to\\_base.\r\n```",
              "createdAt": "2019-07-05T06:20:08Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 53,
              "body": "If we're renaming DSS -> DST,\r\n\r\n```suggestion\r\n1. m' = HKDF-Extract-H(DST, msg)\r\n```",
              "createdAt": "2019-07-05T06:20:29Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NDAzODQx",
          "commit": {
            "abbreviatedOid": "a166f86"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T13:26:58Z",
          "updatedAt": "2019-07-05T13:26:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Not your fault! Good catch.",
              "createdAt": "2019-07-05T13:26:58Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTE4Mjcz",
          "commit": {
            "abbreviatedOid": "2726950"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T18:48:06Z",
          "updatedAt": "2019-07-05T18:48:07Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I find this syntax a little confusing. Is the idea that the H in `HKDF-Extract-H` should be expanded to SHA2, etc, in each case?\r\n\r\nI suggest we stick to the same notation used in the original draft, and others like the TLS 1.3 draft. So, just use \"HKDF-Extract\" and specify under that the hash function used is given by the ciphersuite?",
              "createdAt": "2019-07-05T18:48:07Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTIwNzQz",
          "commit": {
            "abbreviatedOid": "2726950"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T18:57:29Z",
          "updatedAt": "2019-07-05T18:57:30Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "What if we just called it \"Extract\"?\r\n\r\n```\r\n- Extract is the HKDF-Extract function of RFC5869 instantiated with\r\n  hash function H.\r\n```\r\n\r\nIs that clearer?",
              "createdAt": "2019-07-05T18:57:30Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTI1MDA2",
          "commit": {
            "abbreviatedOid": "2726950"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T19:14:32Z",
          "updatedAt": "2019-07-05T19:14:32Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Maybe:\r\n\r\n```\r\n - HKDF-Expand and HKDF-Extract are as defined in {{rfc5869}}, instantiated with the hash function H\r\n```\r\nAgain, keeping it closer to notation used elsewhere.",
              "createdAt": "2019-07-05T19:14:32Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTQxNjg5",
          "commit": {
            "abbreviatedOid": "6ac003a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T20:28:01Z",
          "updatedAt": "2019-07-05T20:28:01Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I preferred the -H notation since it made clear that H determined Extract, though the expansion issue is a valid concern. I'm fine with the proposal!",
              "createdAt": "2019-07-05T20:28:01Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTU1MTQx",
          "commit": {
            "abbreviatedOid": "6ac003a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice! Just one tiny annoyance, sorry...",
          "createdAt": "2019-07-05T21:39:55Z",
          "updatedAt": "2019-07-05T21:40:56Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Got caught by this last time: hotlinks are broken inside fenced blocks :face_with_head_bandage:\r\n\r\n```suggestion\r\n- HKDF-Extract and HKDF-Expand are as defined in RFC5869, \r\n```",
              "createdAt": "2019-07-05T21:39:55Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 142,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzAwNDM1",
      "title": "remove out-of-date test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/142",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "...but promise to return them in the future :)\r\n\r\nIf we get the poc code updated in time, we can put these back before submitting the draft.",
      "createdAt": "2019-07-05T00:01:50Z",
      "updatedAt": "2019-07-05T18:42:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f764a27b30ca3cf1562636396bcde68ffe342b53",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "remove_test_vectors_for_now",
      "headRefOid": "e9c01b003747010360d69a0e5029b8803f3bcfbd",
      "closedAt": "2019-07-05T13:53:09Z",
      "mergedAt": "2019-07-05T13:53:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ad162f3ed2ccda85befeb8b3d9ec90e38d6261a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NDE2NDAw",
          "commit": {
            "abbreviatedOid": "e9c01b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-05T13:52:55Z",
          "updatedAt": "2019-07-05T13:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0OTU0MDY4",
      "title": "update description in {{hashtobase-perf}}",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/143",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(seems easier to do this way...)",
      "createdAt": "2019-07-05T18:27:07Z",
      "updatedAt": "2019-07-06T18:13:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "caw/hkdf",
      "baseRefOid": "2726950f38ccece49f8b6f586551f4ce77c23076",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "kwantam/hkdf",
      "headRefOid": "bb070f6b68c1271731a4cfdca0aef41855214a08",
      "closedAt": "2019-07-05T20:05:59Z",
      "mergedAt": "2019-07-05T20:05:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "958655a9727ffead84713ad2ca9af647c2c2a89b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTM2OTEz",
          "commit": {
            "abbreviatedOid": "bb070f6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-05T20:05:53Z",
          "updatedAt": "2019-07-05T20:05:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MDgwMjAx",
      "title": "small clarity fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/145",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit fixes some clarity issues that @reyzin pointed out in personal communication.\r\n\r\nAlso clarify which values are integer arithmetic and which are field arithmetic in implementations, which I think responds to #135.",
      "createdAt": "2019-07-07T05:34:44Z",
      "updatedAt": "2019-07-08T20:25:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "95e8aedb8db7a4bec2152f126d5e8c2f653842f2",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "clarity_fixes",
      "headRefOid": "0ef5698f6ecdefc9d5a7e68401a0d4a923b12e6b",
      "closedAt": "2019-07-08T20:18:55Z",
      "mergedAt": "2019-07-08T20:18:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "df4025608b9a7e1d1cab292b7cee7d3be816d941"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I'll include the clarification re +-1 for sgn0 in the pseudocode PR.",
          "createdAt": "2019-07-08T20:25:00Z",
          "updatedAt": "2019-07-08T20:25:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDIwNDAx",
          "commit": {
            "abbreviatedOid": "07469c6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:30:33Z",
          "updatedAt": "2019-07-08T16:30:34Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "```suggestion\r\n5.  e1 = (t2 ^ 2) == x\r\n```",
              "createdAt": "2019-07-08T16:30:34Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDU0NTc5",
          "commit": {
            "abbreviatedOid": "07469c6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am pointing some nits that I found on this PR.",
          "createdAt": "2019-07-08T17:36:21Z",
          "updatedAt": "2019-07-08T18:28:18Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "if `q` is removed from `sqrt(x, q)` , then it should be removed from `is_square(x, q)` too.",
              "createdAt": "2019-07-08T17:36:21Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            },
            {
              "originalPosition": 17,
              "body": "This paragraph can be improved with something like this: \r\n~~~\r\nFor security reasons, all field operations, comparisons, and assignments must be implemented in constant time (i.e., execution time must not depend on the values of the inputs), and without branching.\r\n~~~",
              "createdAt": "2019-07-08T17:40:10Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n    Commonly, implementations assume that the selector c is 1 for True, or 0 for False.\r\n```",
              "createdAt": "2019-07-08T17:42:28Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nOutput: s, an element of F such that s ^ 2 = x.\r\n```",
              "createdAt": "2019-07-08T17:44:25Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n1. c1 = sqrt(-1) in F, i.e., (c1 * c1) = -1 in F\r\n2. c2 = (q + 3) / 8        // Integer arithmetic\r\n```",
              "createdAt": "2019-07-08T17:46:07Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n 1. t1 = x ^ c2\r\n```",
              "createdAt": "2019-07-08T17:46:21Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\n2.  e = (t1 ^ 2) == x\r\n```",
              "createdAt": "2019-07-08T17:47:02Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\n3. c3 = sqrt(-c1) in F, i.e., (c3 * c3) == -c1 in F\r\n4. c4 = (q + 7) / 16\r\n```",
              "createdAt": "2019-07-08T17:48:30Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n 1.  t1 = x^c4\r\n```",
              "createdAt": "2019-07-08T17:48:39Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 113,
              "body": "Why not `-x` ?",
              "createdAt": "2019-07-08T17:50:39Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 126,
              "body": "Do we need to remark that `-1` is an integer instead of an element of the field?",
              "createdAt": "2019-07-08T17:52:53Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 206,
              "body": "This definition is correct but difficult to get.\r\n~~~\r\nZ, is a value such that abs(Z) is the smallest in F for which g( B/(Z*A) ) is square. If Z and -Z both meet the above criteria, choose Z such that sgn0(Z) == 1.\r\n~~~\r\n",
              "createdAt": "2019-07-08T18:20:05Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 229,
              "body": "Since the exceptional cases were handled, there is no need for testing again for `is_square(gx2)`. \r\n\r\n```suggestion\r\n8.  Else, set x = x2 and y = sqrt(gx2)\r\n```\r\n",
              "createdAt": "2019-07-08T18:23:50Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 236,
              "body": "Does the sign of the root must be specified here or in the suite?",
              "createdAt": "2019-07-08T18:25:50Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTA1MTQz",
          "commit": {
            "abbreviatedOid": "07469c6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good to me (modulo @armfazh's nits)!",
          "createdAt": "2019-07-08T13:35:15Z",
          "updatedAt": "2019-07-08T18:44:45Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-08T13:35:15Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            },
            {
              "originalPosition": 304,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-08T13:40:31Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDkwNTY5",
          "commit": {
            "abbreviatedOid": "d7dfde1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:46:08Z",
          "updatedAt": "2019-07-08T18:46:08Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "In principle it could be either, right?\r\n\r\nAlso, in the definition of abs we say `sgn0(x) * x`, which kind of implies interpreting sgn0 as returning an element of F.",
              "createdAt": "2019-07-08T18:46:08Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDkyMTk3",
          "commit": {
            "abbreviatedOid": "d7dfde1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:49:20Z",
          "updatedAt": "2019-07-08T18:49:20Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "No need to specify. Setting the sign of y gets the right result no matter which sign you choose for c3.",
              "createdAt": "2019-07-08T18:49:20Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDk2OTU2",
          "commit": {
            "abbreviatedOid": "99cb70a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:58:56Z",
          "updatedAt": "2019-07-08T18:58:56Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Yeah, I struggled with this one a lot.\r\n\r\nThe issue with the old wording (and I think with the suggested edit) is that it's not that abs(Z) is the smallest, it's that there's no other Z' smaller. In other words, it's `<=`, not `<`, and then we specify a way of breaking the possible tie from `<=`.\r\n\r\nMaybe a bulleted list makes it easier? I'll push an edit and let's see how that works.",
              "createdAt": "2019-07-08T18:58:56Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTAyNjYz",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T19:10:56Z",
          "updatedAt": "2019-07-08T19:10:57Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "OK, pushed new text using lists. Thoughts?",
              "createdAt": "2019-07-08T19:10:57Z",
              "updatedAt": "2019-07-08T19:10:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMxNDg0",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:13:30Z",
          "updatedAt": "2019-07-08T20:13:30Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "That's true.",
              "createdAt": "2019-07-08T20:13:30Z",
              "updatedAt": "2019-07-08T20:13:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMxODgx",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:14:21Z",
          "updatedAt": "2019-07-08T20:14:21Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "I think it looks better now.",
              "createdAt": "2019-07-08T20:14:21Z",
              "updatedAt": "2019-07-08T20:14:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMyNDA5",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:15:27Z",
          "updatedAt": "2019-07-08T20:15:28Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "It does, however, in the implementation side -1 \\in ZZ (or even -1 as a boolean) is different from -1 in F.\r\n",
              "createdAt": "2019-07-08T20:15:28Z",
              "updatedAt": "2019-07-08T20:15:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTM1NzUw",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:22:15Z",
          "updatedAt": "2019-07-08T20:22:16Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "True! Fixed.",
              "createdAt": "2019-07-08T20:22:16Z",
              "updatedAt": "2019-07-08T20:22:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MTc2NzM5",
      "title": "pseudocode for curve25519, edwards25519, curve448, edwards448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/146",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds optimized pcode for the above curves, plus an explanation of projective coordinate conversions.\r\n\r\ncloses #133\r\ncloses #4\r\n\r\nI'm going to do some extra proofreading tomorrow with fresh eyes, after which I'll mark it ready for merge. (Also,need to merge #145 first)\r\n\r\nReady for review now, though.",
      "createdAt": "2019-07-08T05:06:45Z",
      "updatedAt": "2019-11-05T18:26:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "df4025608b9a7e1d1cab292b7cee7d3be816d941",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "new_pseudocode",
      "headRefOid": "36fff9f1e13f761787a527c43f160e23a6b5da72",
      "closedAt": "2019-07-08T23:30:52Z",
      "mergedAt": "2019-07-08T23:30:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1f399042bff2912670aa72e6f3c3d6a9727a432c"
      },
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Ristretto's hash-to-curve differs slightly from Ed25519 btw:  https://doc.dalek.rs/src/curve25519_dalek/ristretto.rs.html#606 ",
          "createdAt": "2019-07-08T13:45:10Z",
          "updatedAt": "2019-07-08T13:45:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ristretto's hash-to-curve differs slightly from Ed25519 btw: https://doc.dalek.rs/src/curve25519_dalek/ristretto.rs.html#606\r\n\r\nThanks! I'll link this comment from the Ristretto issue.",
          "createdAt": "2019-07-08T20:14:45Z",
          "updatedAt": "2019-07-08T20:14:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've pushed sage tests for the text pseudocode.",
          "createdAt": "2019-07-08T20:50:00Z",
          "updatedAt": "2019-07-08T20:50:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to try and make the simplified SWU impl more generic and move the optimized P-256 to the appx, too. If I can't get it pushed within the hour I'll give up so that we have time before the deadline to finalize.",
          "createdAt": "2019-07-08T21:14:25Z",
          "updatedAt": "2019-07-08T21:14:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, pushed P-256 pcode. Now to push the corresponding sage checking script.",
          "createdAt": "2019-07-08T22:00:51Z",
          "updatedAt": "2019-07-08T22:00:51Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Checking script pushed, too.",
          "createdAt": "2019-07-08T22:20:25Z",
          "updatedAt": "2019-07-08T22:20:25Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "It should be warned somewhere in the main doc which sage scripts correspond to the version we will submit. ",
          "createdAt": "2019-07-08T22:45:39Z",
          "updatedAt": "2019-07-08T22:45:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It should be warned somewhere in the main doc which sage scripts correspond to the version we will submit.\r\n\r\nDo you think doing it the opposite way would work? Namely, put a README file in the code directory that tells people which code corresponds to which parts of the draft?\r\n\r\nThe reason to do it in the above way is that it doesn't tie us to a particular directory structure for the repository, whereas if we commit to filenames / directory structure / whatever, we're stuck with it until we update the document.",
          "createdAt": "2019-07-08T22:54:24Z",
          "updatedAt": "2019-07-08T22:54:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Also: that way we can do it after the deadline :) )",
          "createdAt": "2019-07-08T22:54:51Z",
          "updatedAt": "2019-07-08T22:54:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> Do you think doing it the opposite way would work? Namely, put a README file in the code directory that tells people which code corresponds to which parts of the draft?\r\n\r\nYes, good idea.",
          "createdAt": "2019-07-08T22:55:31Z",
          "updatedAt": "2019-07-08T22:55:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Do you think doing it the opposite way would work? Namely, put a README file in the code directory that tells people which code corresponds to which parts of the draft?\r\n> \r\n> Yes, good idea.\r\n\r\nAdded #151 to capture this",
          "createdAt": "2019-07-08T22:57:11Z",
          "updatedAt": "2019-07-08T22:57:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkwMzg0",
          "commit": {
            "abbreviatedOid": "92947e6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T22:35:08Z",
          "updatedAt": "2019-07-08T22:35:08Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "```suggestion\r\nmap_to_curve_simple_sswu_p256(u)\r\n```",
              "createdAt": "2019-07-08T22:35:08Z",
              "updatedAt": "2019-07-08T23:30:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkwOTAx",
          "commit": {
            "abbreviatedOid": "92947e6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T22:36:48Z",
          "updatedAt": "2019-07-08T22:36:48Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "\"s\" in \"sswu\" stands for \"Simple,\" so I think \"simple_sswu\" is redundant.\r\n\r\nIn {{simple-swu}}, the function name is \"map_to_curve_simple_swu\", too.",
              "createdAt": "2019-07-08T22:36:48Z",
              "updatedAt": "2019-07-08T23:30:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkxNzg0",
          "commit": {
            "abbreviatedOid": "92947e6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T22:39:58Z",
          "updatedAt": "2019-07-08T22:39:58Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "sorry it's correct.",
              "createdAt": "2019-07-08T22:39:58Z",
              "updatedAt": "2019-07-08T23:30:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDc5NjMy",
      "title": "Typo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/147",
      "state": "MERGED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-08T20:11:59Z",
      "updatedAt": "2019-07-08T20:17:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4f6fbc6c6a12d55aa4680ab6555b95ea1c2e94ac",
      "headRepository": "JustinDrake/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "patch-1",
      "headRefOid": "0e3bf4e062cd4209120fd3aeb299c107ea7b76e6",
      "closedAt": "2019-07-08T20:17:42Z",
      "mergedAt": "2019-07-08T20:17:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "173533ce583b98e0a02423314116ff10478dc56b"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: looks good to me\r\n\r\n@chris-wood?",
          "createdAt": "2019-07-08T20:17:04Z",
          "updatedAt": "2019-07-08T20:17:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Also: thanks!!!",
          "createdAt": "2019-07-08T20:17:15Z",
          "updatedAt": "2019-07-08T20:17:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 -- thank you!",
          "createdAt": "2019-07-08T20:17:47Z",
          "updatedAt": "2019-07-08T20:17:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMzNDM3",
          "commit": {
            "abbreviatedOid": "0e3bf4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T20:17:37Z",
          "updatedAt": "2019-07-08T20:17:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDg4NzM1",
      "title": "Remove a duplicated word",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/148",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-08T20:39:39Z",
      "updatedAt": "2019-07-08T21:04:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "df4025608b9a7e1d1cab292b7cee7d3be816d941",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "nit00",
      "headRefOid": "59de8bf2320a4d0fa73ac6f0554b59cd3546eac4",
      "closedAt": "2019-07-08T21:04:09Z",
      "mergedAt": "2019-07-08T21:04:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3cff06cb02d874bfd762c192a7e699845f6af473"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTQ1Njk4",
          "commit": {
            "abbreviatedOid": "56af65f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:43:09Z",
          "updatedAt": "2019-07-08T20:43:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n where \\<csid\\> is the ciphersuite string, and \\<xx\\> and \\<zz\\> are\r\n```",
              "createdAt": "2019-07-08T20:43:09Z",
              "updatedAt": "2019-07-08T20:43:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU1NjY0",
          "commit": {
            "abbreviatedOid": "59de8bf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T21:04:04Z",
          "updatedAt": "2019-07-08T21:04:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDkxNTU5",
      "title": "Typo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/149",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `hash_to_base` function has two parameters.\r\n\r\nNote: I'm note sure how new lines are determined. It looks like line 1260 is now longer than the others.",
      "createdAt": "2019-07-08T20:48:15Z",
      "updatedAt": "2019-07-08T22:26:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "df4025608b9a7e1d1cab292b7cee7d3be816d941",
      "headRepository": "JustinDrake/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "patch-2",
      "headRefOid": "2b2d25f342a83f30e8d2b576d140632b65146d95",
      "closedAt": "2019-07-08T22:26:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Similar problem with \"The function hash_to_base, {0, 1}^* -> F\"",
          "createdAt": "2019-07-08T21:05:01Z",
          "updatedAt": "2019-07-08T21:05:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Similar problem with \"The function hash_to_base, {0, 1}^* -> F\"\r\n\r\nMaybe here, `{0, 1}^\\* x {0, 1, 2} -> F` would be OK.\r\n\r\n(Though I really don't love loading up on notation that readers might not be familiar with...)",
          "createdAt": "2019-07-08T21:11:28Z",
          "updatedAt": "2019-07-08T21:11:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've combined both suggested fixes into #150",
          "createdAt": "2019-07-08T22:26:35Z",
          "updatedAt": "2019-07-08T22:26:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU2NTYy",
          "commit": {
            "abbreviatedOid": "2b2d25f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for catching this!\r\n\r\nI think maybe the fix is to go the other direction, though:",
          "createdAt": "2019-07-08T21:06:01Z",
          "updatedAt": "2019-07-08T21:06:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think it might be better not to introduce either parameter at this point. The sentence reads fine without them, and the ctr variable is a distraction at this point in the text.\r\n\r\n```suggestion\r\nThe hash\\_to\\_base function hashes a string msg of any length into an element of a\r\n```",
              "createdAt": "2019-07-08T21:06:02Z",
              "updatedAt": "2019-07-08T21:06:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU5NDQ4",
          "commit": {
            "abbreviatedOid": "2b2d25f"
          },
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T21:12:26Z",
          "updatedAt": "2019-07-08T21:12:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":+1:",
              "createdAt": "2019-07-08T21:12:26Z",
              "updatedAt": "2019-07-08T21:12:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NTE4MjA4",
      "title": "fix type signature issues with hash_to_base",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/150",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #149",
      "createdAt": "2019-07-08T22:25:46Z",
      "updatedAt": "2019-11-05T18:24:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "3cff06cb02d874bfd762c192a7e699845f6af473",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "typo_fix",
      "headRefOid": "0424ff0f280e4d49bde3f5b8fe66e4826e3abe4a",
      "closedAt": "2019-07-08T22:38:13Z",
      "mergedAt": "2019-07-08T22:38:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e5e9647e178cae923f25b6bb74b8b292a6394900"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTg5NDAx",
          "commit": {
            "abbreviatedOid": "0424ff0"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T22:31:41Z",
          "updatedAt": "2019-07-08T22:31:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkxMjgz",
          "commit": {
            "abbreviatedOid": "0424ff0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T22:38:08Z",
          "updatedAt": "2019-07-08T22:38:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NjU5NTM2",
      "title": "Fix off by one",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/152",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since `2**256 - 1 mod 2**255-19` is 37",
      "createdAt": "2019-07-09T09:12:32Z",
      "updatedAt": "2019-10-23T21:46:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "1f399042bff2912670aa72e6f3c3d6a9727a432c",
      "headRepository": "JustinDrake/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "patch-3",
      "headRefOid": "4f0773eb3ba415d9a2e55fca24e1d9e1f3d50b03",
      "closedAt": "2019-10-23T21:46:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyODk3NjMz",
          "commit": {
            "abbreviatedOid": "4f0773e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T00:20:07Z",
          "updatedAt": "2019-08-09T00:20:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzODQxNzM3",
          "commit": {
            "abbreviatedOid": "4f0773e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-04T19:25:09Z",
          "updatedAt": "2019-09-04T19:25:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1Njc2NDAy",
      "title": "Avoid rehashing msg",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/154",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`msg` can be large so we want to avoid rehashing it. As I understand it, `HKDF-Extract(DST, msg)` imposes an \"arbitrary\" hashing of `msg`, namely `H(DST XOR ipad, msg)` where `ipad` is the byte `0x36` repeated 64 times. (See section 2 in [RFC 2104](https://tools.ietf.org/html/rfc2104).) Since various applications will have `H(msg)` readily computed, it makes sense to use `H(msg)` in `HKDF-Extract` as a \"natural\" way to minimise the chances of hashing `msg` multiple times.",
      "createdAt": "2019-07-09T09:54:38Z",
      "updatedAt": "2019-09-04T09:20:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "1f399042bff2912670aa72e6f3c3d6a9727a432c",
      "headRepository": "JustinDrake/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "patch-4",
      "headRefOid": "64f5e30a1233e7631445e2ed511e5f17e8c5785b",
      "closedAt": "2019-09-04T09:20:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "In the invocation of HMAC, DST is the `key`, which is a short-length string, and the `text` corresponds to an arbitrary-length message `msg`. \r\n\r\n```fortran\r\nH(K XOR opad, H(K XOR ipad, text))\r\n```\r\n\r\nit seems to me that message is hashed once.",
          "createdAt": "2019-07-09T17:52:36Z",
          "updatedAt": "2019-07-09T17:52:36Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the application already hashed the message in the most natural way (i.e. computed `H(msg)`) then the signature forces *another* hashing of the message with `HKDF-Extract`.",
          "createdAt": "2019-07-09T18:08:16Z",
          "updatedAt": "2019-07-09T18:08:16Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Related https://github.com/pairingwg/bls_standard/issues/18 ",
          "createdAt": "2019-07-10T06:41:11Z",
          "updatedAt": "2019-07-10T06:41:11Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, #18 is related (may be worth reopening now that there is an issue with the current `hash_to_base`). I can see various ways to solve the double-hashing:\r\n\r\n1) The spec choose `H(msg)` as a \"best guess digest\" and feeds `H(msg)` into `HKDF-Extract`.\r\n2) The spec mandates that `msg` be 32 bytes (i.e. some sort of digest). The application layer can use any function that produces a 32-byte digest, including application-layer hash functions that are different to `H`, as well as Merkleisation functions which are common in blockchains.\r\n3) (status quo) Applications either consciously opt-in to option 2) or risk falling in the double signing trap.\r\n\r\nIt seems that option 3) is strictly worse than 2). As such, I'm inclined to favour option 1) or 2).",
          "createdAt": "2019-07-10T09:43:05Z",
          "updatedAt": "2019-07-10T09:43:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for bringing up this issue, Justin :+1:\r\n\r\nTerminology: let's use `H'` to mean the hash function that the invoking protocol is using, while `H` is the hash used inside hash_to_base.\r\n\r\n(I injected the above terminology in the below quote from Justin)\r\n> If the application already hashed the message in the most natural way (i.e. computed `H'(msg)`) then the signature forces _another_ hashing of the message with `HKDF-Extract`.\r\n\r\nTo be perfectly clear (this is of course implicit in your comments above): if an invoking protocol has already computed `H'(msg)`, it can hash that value to the curve rather than hashing `msg` to the curve, provided that `H'` meets essentially the same requirements that we impose on `H` in the definition of hash_to_base (collision resistance, sufficient output length).\r\n\r\nConsidering the options that Justin proposed:\r\n\r\n1. Using `H(msg)` doesn't appear to solve the problem, because there's no guarantee that `H` == `H'`, and if it doesn't then there's no opportunity for optimization. Am I correct in surmising that this is what you mean by \"best guess\"---it might be right, but no guarantees? And so the point is, if an application gets lucky and `H` == `H'`, it can bypass the `H(msg)` invocation in hash_to_base by passing this value in, thereby avoiding double hashing, right?\r\n\r\n2. From my perspective, forcing `msg` to a fixed length is something of a step backwards: not only does it make the primitive strictly less general, it means that the choice of `H'` is moved \"outside\" this document, which has potential security implications (what if the application uses MD5?)\r\n\r\n3. I kind of like the idea of letting the invoking protocol decide whether to hash `msg` or `H'(msg)`. Just to be clear, is your concern that someone will specify hashing `msg` to the curve, then later regret it when they realize they'd already computed `H'(msg)`? In this case, what if we add a note (probably in Section 5) making explicit the requirements on `H'` and stating that invoking protocols MAY use `H'(msg)` instead of `msg`?",
          "createdAt": "2019-08-09T00:17:27Z",
          "updatedAt": "2019-08-09T00:17:27Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Am I correct in surmising that this is what you mean by \"best guess\"\r\n\r\nYes :)\r\n\r\n> what if we add a note (probably in Section 5) making explicit the requirements on `H'` and stating that invoking protocols MAY use `H'(msg)` instead of `msg`\r\n\r\nAdding a note sounds good to me :) And nothing prevents a \"blockchain standard\" strictly less general than the CFRG spec to recommend only signing 32-byte messages.",
          "createdAt": "2019-08-12T21:27:15Z",
          "updatedAt": "2019-08-12T21:27:15Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The consensus after discussing this is to stick with the status quo. The expectation is that most implementors will make `msg` a short digest (but not necessarily a 32-byte hash output). We could add a note recommending `msg` be a short digest.\r\n\r\ncc @kirk-baird",
          "createdAt": "2019-09-04T09:20:15Z",
          "updatedAt": "2019-09-04T09:20:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1ODAxODUz",
      "title": "small fixes to address #160, #161, #162",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/163",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is mostly a minor edit to address the above.\r\n\r\nThe most major thing is a new (small) section laying out the convention for creating a new Suite ID. The reason for having the convention is that it's best if suite IDs are prefix-free, and this convention helps with that.",
      "createdAt": "2019-08-09T01:18:44Z",
      "updatedAt": "2019-08-14T01:36:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "1f399042bff2912670aa72e6f3c3d6a9727a432c",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "small_fixes",
      "headRefOid": "466df2a8d4f7923ff641f636e6f1eeb0576f6320",
      "closedAt": "2019-08-13T15:41:59Z",
      "mergedAt": "2019-08-13T15:41:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7e7ccaf7d20bae921c4726feb40aa908f012a711"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 I added a paragraph at the end of the new subsection on suite IDs that I think comprehends the worries in #140 and #161. Please let me know if it seems like I'm missing anything.",
          "createdAt": "2019-08-09T01:25:05Z",
          "updatedAt": "2019-08-09T01:25:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 please have a look!",
          "createdAt": "2019-08-11T15:13:23Z",
          "updatedAt": "2019-08-11T15:13:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDI0NDY1",
          "commit": {
            "abbreviatedOid": "d939b3f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2019-08-10T12:50:37Z",
          "updatedAt": "2019-08-10T12:52:26Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Should we reference the earlier section where we define the minimum value of L?",
              "createdAt": "2019-08-10T12:50:37Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDc1NzQy",
          "commit": {
            "abbreviatedOid": "af09765"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks like a great clarity/ambiguity win.",
          "createdAt": "2019-08-11T19:15:38Z",
          "updatedAt": "2019-08-11T19:21:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "We should probably avoid using \"var prime\" as a variable name. It's not representable in most programming languages, and easy to misread.\r\n\r\nCould this be \"info_prefix\" instead? ",
              "createdAt": "2019-08-11T19:15:38Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            },
            {
              "originalPosition": 91,
              "body": "Love the idea of adding the version to an existing field. But why the enc type field? To me this implies changing the entire definition of the random oracle construction, versus making, E.g., curve specific changes?",
              "createdAt": "2019-08-11T19:19:44Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            },
            {
              "originalPosition": 18,
              "body": "( I accept this is maybe not in scope for this PR) ",
              "createdAt": "2019-08-11T19:21:04Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDkwMDQw",
          "commit": {
            "abbreviatedOid": "af09765"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T01:05:47Z",
          "updatedAt": "2019-08-12T01:05:48Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Ah, this is a great question!\r\n\r\nIn my head, the reason was just that there's nothing else to go in the ENC field other than the two characters \"RO\" or \"NU\", so there's tons of room for subfields while still respecting the (somewhat arbitrary) 64 char per field size limit.\r\n\r\n(Regarding the size limit: I thought having an explicit size limit would make impls somewhat easier to reason about.)\r\n\r\nWhat if we renamed it to \"ENC_MISC\" and modified the description to make this more explicit?\r\n\r\nAn alternative is to have a separate \"misc\" field, but then it doesn't seem to make sense to allow 64 chars for the \"ENC_TYPE\" field, at which point the grammar gets more complex because some fields have different sizes than other fields, and it's honestly not obvious that we'll ever use the misc field...",
              "createdAt": "2019-08-12T01:05:48Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDkwMTA3",
          "commit": {
            "abbreviatedOid": "af09765"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T01:06:54Z",
          "updatedAt": "2019-08-12T01:06:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This is a great point. Totally easy to fix here (and `m'`, too).",
              "createdAt": "2019-08-12T01:06:54Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNzcyNDM3",
          "commit": {
            "abbreviatedOid": "d38e757"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T15:30:43Z",
          "updatedAt": "2019-08-12T15:30:44Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": ">  and it's honestly not obvious that we'll ever use the misc field...\r\n\r\nYeah, the following is very much TIOLI, since it does seem low importance.\r\n\r\nA few potential counter points: implementations might assume exactly 2 bytes for `RO` or `NU`. Although following this logic very much leads us into needing a GREASE-like system. \r\n\r\nI mostly just semantically find the idea of versioning the \"encoding type\" to feel weird. \r\n\r\n> What if we renamed it to \"ENC_MISC\" and modified the description to make this more explicit?\r\n\r\nHow about \"ENC_VAR\" ~ encoding variant? ",
              "createdAt": "2019-08-12T15:30:43Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczODE2NTI5",
          "commit": {
            "abbreviatedOid": "d38e757"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T16:47:00Z",
          "updatedAt": "2019-08-12T16:47:01Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "ENC_VAR sounds great to me. @chris-wood?",
              "createdAt": "2019-08-12T16:47:01Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczOTUyMTY5",
          "commit": {
            "abbreviatedOid": "d38e757"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T21:09:05Z",
          "updatedAt": "2019-08-12T21:09:05Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yep, sounds good to me, too! (Though I would be fine with either. :))",
              "createdAt": "2019-08-12T21:09:05Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczOTY0MDc1",
          "commit": {
            "abbreviatedOid": "466df2a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T21:35:50Z",
          "updatedAt": "2019-08-12T21:35:50Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "OK, changed. Thoughts?",
              "createdAt": "2019-08-12T21:35:50Z",
              "updatedAt": "2019-08-12T21:35:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczOTY4Mzk4",
          "commit": {
            "abbreviatedOid": "466df2a"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM! ",
          "createdAt": "2019-08-12T21:46:30Z",
          "updatedAt": "2019-08-12T21:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MDQ4NzMw",
      "title": "Promoting SW as a general map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/167",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The original construction of Shallue-van de Woestijne (SW, to avoid confusion with names) can be used as a (almost) generic method for hashing into **any** curve in short Weierstrass form.\r\n\r\nChanges:\r\n - SW stands now as a generic method.\r\n - SW costs 4 exponentiation (in affine coordinates).\r\n - Added SW suites for P-256, P-384, P-521, BN256, SECP256K1.\r\n - Added a PDF with the description of the formulas (it follows a combination of Fouque-Tibouchi and Wahby approaches) File: ([math/sw.pdf](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/a0c68c9c78e67d5019e7aa3659e5a9f0af2ba29a/math/sw.pdf)).",
      "createdAt": "2019-09-19T00:28:38Z",
      "updatedAt": "2019-10-23T21:54:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7e7ccaf7d20bae921c4726feb40aa908f012a711",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "addSW",
      "headRefOid": "a0c68c9c78e67d5019e7aa3659e5a9f0af2ba29a",
      "closedAt": "2019-10-23T21:54:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a great start! but I think there's a problem:\r\n\r\nIn math/sw.pdf and in the proposed edits, the requirements for Z are given as\r\n\r\n- `f(Z)` != 0\r\n- `f(Z)` is a QR\r\n- `-(3 Z^2 + 4A) != 0`\r\n- `-(3 Z^2 + 4A)` is a QR\r\n\r\nMy issue is that there certainly exist curves for which this parameterization **does not work**. In particular, if `A = 0`, then the fourth requirement is that `-3 Z^2` is a QR, which reduces to -3 is a QR, which is equivalent to requiring p = 1 mod 3. (You can convince yourself that -3 is a QR iff p = 1 mod 3 via some quadratic residuosity manipulations. FT point this out in FT12, too.)\r\n\r\nSo: any curve where p = 2 mod 3 and A = 0 simply cannot work with this parameterization.\r\n\r\nThat was the point of [my write-up](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/raw/generalized_svdw/svdw_general.pdf) --- to work (with high probability) for any curve. I realize it's slightly more complicated than what's described here, but I don't see a simpler approach that really works for any curve.",
          "createdAt": "2019-10-10T04:06:13Z",
          "updatedAt": "2019-10-10T04:06:13Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This method shows one parametrization to the conic equal to the one followed in FT paper. However, it fails when A=0 and p=2 mod 3, since -3 is a non square.\r\n ",
          "createdAt": "2019-10-23T21:54:53Z",
          "updatedAt": "2019-10-23T21:54:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MDUxNjE4",
      "title": "Removing Icart encoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/168",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The curve P384 is one example that uses Icart method. However, it can also be used SW and SSWU mappings instead.\r\n\r\nLets argue on this proposal.",
      "createdAt": "2019-09-19T00:47:13Z",
      "updatedAt": "2019-10-10T21:35:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7e7ccaf7d20bae921c4726feb40aa908f012a711",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "delIcart",
      "headRefOid": "6841e8c93af409c0ff090ea702c8b485e5297a05",
      "closedAt": "2019-10-10T21:35:08Z",
      "mergedAt": "2019-10-10T21:35:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a7128c32638684e9672aba289481810218561ab8"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d I agree, let's remove it! @kwantam @samscott89 @grittygrease, any objections?",
          "createdAt": "2019-09-19T15:18:58Z",
          "updatedAt": "2019-09-19T15:18:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a great idea to me! I was thinking we should do exactly the same thing!",
          "createdAt": "2019-10-10T01:42:11Z",
          "updatedAt": "2019-10-10T01:42:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5Nzg0Nzc0",
          "commit": {
            "abbreviatedOid": "47c0cf6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good to me other than a small consistency issue.",
          "createdAt": "2019-10-10T02:00:00Z",
          "updatedAt": "2019-10-10T02:01:05Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "```suggestion\r\n- Z: -1\r\n```\r\n\r\nIsn't `Z = -1` the value that meets the criteria given in `{{simple-swu}}`? -2 also works, but I think is not consistent with that part of the document.\r\n\r\nIs the idea to avoid -1 for reasons that Bjorn Haase has pointed out? If so, I think we should discuss that change in a separate PR, and this PR should stay consistent with the rest of the document.",
              "createdAt": "2019-10-10T02:00:30Z",
              "updatedAt": "2019-10-10T17:58:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjQzODU5",
          "commit": {
            "abbreviatedOid": "47c0cf6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved pending @kwantam's suggestion!",
          "createdAt": "2019-10-10T17:48:19Z",
          "updatedAt": "2019-10-10T17:48:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjcxODkw",
          "commit": {
            "abbreviatedOid": "6841e8c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1: ",
          "createdAt": "2019-10-10T18:35:30Z",
          "updatedAt": "2019-10-10T18:35:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyNDUwMzYw",
      "title": "Security consideration: brute-force attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/169",
      "state": "CLOSED",
      "author": "vanhoefm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This informs the reader of brute-force attacks if the output of hash_to_base (or derived values) is leaked. Suggested defence is to preprocess the input of hash_to_base.\r\n\r\nComments are welcome!",
      "createdAt": "2019-09-28T22:15:25Z",
      "updatedAt": "2019-10-23T21:46:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7e7ccaf7d20bae921c4726feb40aa908f012a711",
      "headRepository": "vanhoefm/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "5f174fa065a205aa8f69434a522f1f8d5e07140b",
      "closedAt": "2019-10-23T21:46:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the PR!\r\n\r\nIt's probably simpler (and certainly true) to point out that even the output of *hash-to-curve* (not just hash-to-base) enables such a brute-force attack.\r\n\r\nSo maybe the way to phrase the advice is that one should treat passwords the same with these hash functions as with any other: use salts, use expensive KDFs, etc.",
          "createdAt": "2019-10-10T16:43:58Z",
          "updatedAt": "2019-10-10T16:44:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3NDE1MzI4",
      "title": "roll-up of a few small-ish changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/170",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses a few TODOs from my list.\r\n\r\nThe most major one is that it addresses @cjpatton's suggestions regarding domain separation.\r\n\r\nIt also rolls in suggestions from @JustinDrake and @vanhoefm, and fixes some small editorial nits.\r\n\r\nOh, and it updates the acknowledgment sections.",
      "createdAt": "2019-10-12T02:15:25Z",
      "updatedAt": "2019-10-23T21:46:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a7128c32638684e9672aba289481810218561ab8",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "a36792de6791ee117e4d9fb9d6ef65fcd65650a6",
      "closedAt": "2019-10-23T21:46:33Z",
      "mergedAt": "2019-10-23T21:46:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4fbcead2d20cdc12f1b0d81fe56fe46c05bbdd8c"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looks good. Though I would double check with Benjamin Lipp about interpretation of his result for HKDF, just to be on the safe side.\r\n\r\n@kwantam are you OK with merging this PR as is, or do you want to wait?",
          "createdAt": "2019-10-17T19:52:47Z",
          "updatedAt": "2019-10-17T19:52:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> @kwantam are you OK with merging this PR as is, or do you want to wait?\r\n\r\nSorry for the late reply. I emailed Benjamin and he pointed out an issue: while it's true that this proposal fixes this specific problem with the indifferentiability proof, it unfortunately points to a different and potentially more pernicious one.\r\n\r\nThe issue is, since we've added a call to H(msg), we now need to ensure that no other invocation of H (*inside* HMAC) collides with this invocation! So we've kind of \"pushed the bubble.\"\r\n\r\nI chatted with Leo Reyzin about this, and we concluded that that we could fix this by instead computing\r\n\r\n    msg_prime = HKDF-Extract(DST, msg || 0x00)\r\n\r\nThis works because `0x00` (a 1-byte value) will never be the last byte of the input to any HMAC invocation inside HKDF-Expand, [by construction](https://tools.ietf.org/html/rfc5869#section-2.3).\r\n\r\nBut here's the problem: this notion that we have to worry about colliding inputs to `H` may go further than just hash-to-base, because arguably it implies that any protocol that uses hash-to-base in \"prehash mode\" (i.e., calls hash-to-base on `H(msg)` where `msg` is potentially an adversarially-supplied input) could break the indifferentiability simulator from the LBB19 proof.\r\n\r\nNow, it may be that this is not a realistic worry (in which case, there's no need to change hash-to-base at all). We ought to be able to make this statement more formally in terms of some concrete hardness assumption about H. I'll think about this over the weekend and report back.\r\n\r\nMeanwhile, @cjpatton, do the above \"fix\" make sense to you? (I'll also plan to ping Benjamin.)",
          "createdAt": "2019-10-18T22:56:29Z",
          "updatedAt": "2019-10-18T22:56:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, Benjamin Lipp sanity checked me and agrees that the above fix works in isolation.\r\n\r\nThe question of whether pre-hashing `msg` with the same `H` used in hash-to-base breaks indifferentiability remains open. At first blush, there *certainly* seem to be protocols in which the indifferentiability proof is broken: allowing arbitrary (adversarial) queries to both `H` and hash_to_base seems to be one example.\r\n\r\nMy hope is that we can at least resolve the \"prehash mode\" issue, since I suspect folks will definitely want that use-case to be secure!",
          "createdAt": "2019-10-22T02:36:48Z",
          "updatedAt": "2019-10-22T02:41:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "If I understand @kwantam correctly, the issue is that we can apply LBB19's indifferentiability Lemma, to get from HKDF to HMAC, but we now have to deal with simulating H(msg) when applying [[DRST12](https://eprint.iacr.org/2013/382.pdf), Thm.4.3] to get from HMAC to H. I'm not sure I see the difficulty here.\r\n\r\nIn particular, to apply [DRST12, Thm.4.3] we need only to restrict the usage of HMAC so that the key is in some \"allowed key set\" as defined in [DRST12, Sec.4.4]. In particular, I believe all we need to do is ensure that the length of the salt (i.e., DST) is equal to the output length of H. (Note that the same should suffice when applying [DRST12, Thm.4.4], which deals with length-extension attacks against Merkle-Damagard-type hash functions.)\r\n\r\nI might be missing something, however.\r\n\r\nIn any case, I think appending a `0x00` byte to the unhashed input would work.",
          "createdAt": "2019-10-22T18:16:15Z",
          "updatedAt": "2019-10-22T18:17:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton thanks for the sanity check.\r\n\r\nI'm going to update the PR to append the 0x00 to the unhashed input, because we *know* that meets the requirements. We can separately think about whether we need to add any specific recommendations when pre-hashing msg.\r\n\r\nFirst blush, I agree with you (@cjpatton) that I don't see an issue with the DRST12 result and H(msg), at least generically. Or, at least, it looks to me like any difficulty that arises is of the sort described by [RSS11](https://eprint.iacr.org/2011/339)---and that would be a problem with the invoking protocol, *not* with us. (For this reason, it's probably worthwhile to point to RSS11 in the security considerations.)",
          "createdAt": "2019-10-23T03:04:31Z",
          "updatedAt": "2019-10-23T03:04:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK @chris-wood @armfazh I changed the approach to one that's easily proven good.\r\n\r\n~~I'll open a separate issue where we can discuss whether to add words about pre-hashing security considerations.~~ Actually, on second thought, this isn't the right document for that conversation, because we don't have the necessary details. So higher-level protocols should worry about any kind of \"prehash\" mode, I'd say.",
          "createdAt": "2019-10-23T04:35:39Z",
          "updatedAt": "2019-10-23T04:52:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh any objections to merging?",
          "createdAt": "2019-10-23T21:18:20Z",
          "updatedAt": "2019-10-23T21:18:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> @armfazh any objections to merging?\r\n\r\nI have no objections, just few comments:\r\n-  As you mentioned #167  didn't work for curves A=0 and p=2 mod 3.\r\n-  I noticed that different ways to parametrize the conic leads to different mappings (which maybe equivalent).\r\n-  However, I am working on another parametrization, different from #167 and from this PR, which seems to be simpler. I will share with you some details.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-10-23T21:45:07Z",
          "updatedAt": "2019-10-23T21:45:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDIzMTg3",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "At a high-level, hashing the message first seems like a good idea, but I'm not 100% sure that the spec meets the requirements of [LBB19, Lemma 8]. (See detailed comment below.) You might want to reach out to the authors of that paper for feedback.",
          "createdAt": "2019-10-12T21:27:31Z",
          "updatedAt": "2019-10-12T22:22:01Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "More precisely: \"whose outputs are indifferentiable from a random oracle when XXX is modeled as a random oracle\", where XXX is the underlying construction.",
              "createdAt": "2019-10-12T21:27:32Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 74,
              "body": "nit: \"random oracle to G\" -> \"random oracle whose range is G\"",
              "createdAt": "2019-10-12T21:29:13Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 151,
              "body": "I feel this is a bit too informal. I would either punt on this (just say something like, \"so care must be taken when instantiating it\") or provide a deeper discussion about how the structure of H might (or mightn't) be exploited in the application of H described here. As a reader, I would be interested in whether Merkle-Damgard constructions (e.g., SHA2) are suitable instantiations of H. In particular, how do BCIMRT10 recommend instantiating the hash function? Does their analysis address length-extension attacks [[CDMP05](https://iacr.org/archive/crypto2005/36210424/36210424.pdf)]?",
              "createdAt": "2019-10-12T21:44:20Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 172,
              "body": "You should refer to Lemma 8 instead of Appendix A.2 here. (Note that I misquoted this as Lemma 7 in my paper :/)",
              "createdAt": "2019-10-12T21:58:15Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 170,
              "body": "My understanding is that the following are sufficient conditions for ensuring the usage of HKDF is indiferentiable from an RO when the hash function used by HMAC is modeled as an RO. These combine results from LBB19 (Lemma 8) and [[DRST12](https://eprint.iacr.org/2013/382.pdf)] (Theorems 4.3 and 4.4) See the discussion in [[PS19](https://eprint.iacr.org/2019/519.pdf), Appx. B] for details. Suppose that HMAC has output length `h` (in bits).\r\n\r\n1. The \"info\" string is always length `u` (in bits).\r\n2. The \"salt\" string is always length `h`.\r\n3. The \"key\" string (i.e., `msg`) has length other than `u + 8` he length of the input to HMAC for the first HKDF-extracted block) or `h + u + 8` (the length of the input to HMAC for each subsequent block).\r\n\r\nSo `H(msg)` is suitable as long as `u !=  h - 8`.\r\n\r\nBy the way, what is `H`? Is the same hash function as used with HKDF?",
              "createdAt": "2019-10-12T22:03:17Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 282,
              "body": "\"Chris\" -> \"Christopher\" (for look-up purposes)",
              "createdAt": "2019-10-12T22:18:57Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI2Nzc0",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-12T23:58:51Z",
          "updatedAt": "2019-10-12T23:58:51Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Great point. I've updated the wording.\r\n\r\nBCIMRT10 don't discuss the underlying hash function, because in their construction they assume that one has already managed to instantiate a random oracle whose domain is the base field of the target elliptic curve.\r\n\r\nFor our purposes, length extension isn't a problem because SHA-2 gets wrapped inside of HMAC inside of the HKDF construction, which plausibly eliminates this worry. More generally, as long as we're happy modeling HKDF as a random oracle outputting L-byte strings for sufficiently large L (i.e., log (p) + k bits, k the security parameter), then hash_to_base is a random oracle whose domain is Z/pZ giving at most 2^-k statistical distance from a uniform distribution over Z/pZ.",
              "createdAt": "2019-10-12T23:58:51Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI2OTkx",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T00:08:46Z",
          "updatedAt": "2019-10-13T00:08:46Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "H is indeed the same hash used with HKDF. I'll double check that this is clear in the text.\r\n\r\nThinking out loud here:\r\n\r\n- HMAC's output length is the same as H's output length, which is `h` (we used `b` in the document, but I'll stick with your terminology in this comment).\r\n\r\n- `u` is 40 bits for us: info is `H2Cxy`, where \"H2C\" is ASCII text, and x and y are 8-bit values.\r\n\r\n- As you say, input to the HMAC calls inside HKDF-Expand are either 48 or 48 + `h` bits, and so what we need is that `40 != h - 8` or, sufficiently, `h > 48`. But of course `h` will *definitely* be more than 48 because of the collision resistance requirements in this section.\r\n\r\nSo: I think we're in agreement here, and I think the text correctly states a sufficient requirement for `h`.",
              "createdAt": "2019-10-13T00:08:46Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI3MTYz",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T00:16:51Z",
          "updatedAt": "2019-10-13T00:16:51Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "(I've now added a cite to DRST12, too)",
              "createdAt": "2019-10-13T00:16:51Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI4Mzk2",
          "commit": {
            "abbreviatedOid": "c177dd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks for the cleanup, @kwantam!",
          "createdAt": "2019-10-13T01:17:34Z",
          "updatedAt": "2019-10-13T01:27:24Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Provided the sufficient conditions are correct, I agree with @kwantam's conclusion. (And thanks for writing that down, @cjpatton!)",
              "createdAt": "2019-10-13T01:17:35Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 91,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-10-13T01:25:55Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 159,
              "body": "Perhaps we should drop a reference to the ciphersuite section here? (One might read this and think of ciphersuites as part of the protocol in which h2c is used, whereas here we mean a single protocol using multiple h2c suites.)",
              "createdAt": "2019-10-13T01:27:14Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDMzMDI0",
          "commit": {
            "abbreviatedOid": "c177dd6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T05:10:09Z",
          "updatedAt": "2019-10-13T05:10:09Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Oh! Good point---but actually probably we should mean both! I'll update.",
              "createdAt": "2019-10-13T05:10:09Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDMzMjY1",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T05:19:31Z",
          "updatedAt": "2019-10-13T05:19:32Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Clearer now?",
              "createdAt": "2019-10-13T05:19:31Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDY3MzU0",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T21:10:30Z",
          "updatedAt": "2019-10-13T21:10:31Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Yep -- looks good!",
              "createdAt": "2019-10-13T21:10:30Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMzc1NTE3",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-14T15:19:21Z",
          "updatedAt": "2019-10-14T15:19:21Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Agreed.",
              "createdAt": "2019-10-14T15:19:21Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMzc2NTU0",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-14T15:20:59Z",
          "updatedAt": "2019-10-14T15:21:00Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "I would double check with Benjamin Lipp, just to be 100% we're interpreting his result correctly. (He's the lead author on the WireGuard analysis.)",
              "createdAt": "2019-10-14T15:21:00Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMzc3NjU5",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Looks good. Though I would double check with Benjamin Lipp about interpretation of his result for HKDF, just to be on the safe side.",
          "createdAt": "2019-10-14T15:22:48Z",
          "updatedAt": "2019-10-14T15:22:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNTQ2MTA5",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @cjpatton for your comments on the draft.",
          "createdAt": "2019-10-14T21:19:51Z",
          "updatedAt": "2019-10-14T21:19:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjMzNDA0",
          "commit": {
            "abbreviatedOid": "03d7ad2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for driving this forward! And thanks to @blipp and @cjpatton for their help.",
          "createdAt": "2019-10-23T05:01:16Z",
          "updatedAt": "2019-10-23T05:02:48Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Since we don't define indifferentiability framework here, might it make sense to say something such as, \"As Ristenpart et al. discuss in {{RSS11}}, however, security proofs in the Random Oracle model may not always hold when such functions are replaced with indifferentiable counterpart,\" or something? (That is, perhaps unroll the meaning of the framework inline so readers don't have to look at RSS11.)",
              "createdAt": "2019-10-23T05:01:16Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MDQ1OTg4",
          "commit": {
            "abbreviatedOid": "a36792d"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T17:00:41Z",
          "updatedAt": "2019-10-23T17:00:42Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Good call! Better now?",
              "createdAt": "2019-10-23T17:00:42Z",
              "updatedAt": "2019-10-23T17:00:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MTUwODY0",
          "commit": {
            "abbreviatedOid": "a36792d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T19:56:36Z",
          "updatedAt": "2019-10-23T19:56:36Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yep \u2014 perfect!",
              "createdAt": "2019-10-23T19:56:36Z",
              "updatedAt": "2019-10-23T19:56:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjExMTg3",
          "commit": {
            "abbreviatedOid": "a36792d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-23T21:45:56Z",
          "updatedAt": "2019-10-23T21:45:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMwNzk4NDU4",
      "title": "update Z selection, add pseudocode, promote SvdW map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/172",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the Z selection criteria to [avoid patent infringement](https://mailarchive.ietf.org/arch/msg/cfrg/jV4Wr4fbMKkd4vzsbEhKbous16Y) for S-SWU, and to add Sage scripts for generating parameters.\r\n\r\nI've also promoted the S-vdW map (using the more general parameterization, rather than the one in #167, which has issues I pointed out there), rewritten the pseudocode, etc.\r\n\r\nOne change from the prior version of this document is that this version no longer tries to establish a canonical Z. Rather, it gives the criteria, and then gives a Sage script for computing the RECOMMENDED Z.",
      "createdAt": "2019-10-22T04:24:01Z",
      "updatedAt": "2019-10-26T19:17:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4fbcead2d20cdc12f1b0d81fe56fe46c05bbdd8c",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "z_pseudocode",
      "headRefOid": "b60914d7f032452733ffd0f955267bbca3fee168",
      "closedAt": "2019-10-26T19:16:27Z",
      "mergedAt": "2019-10-26T19:16:27Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "33f4b05c3437af649bdc0f64860b596200af942c"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~OK, this is very close to ready to go @chris-wood @armfazh.~~\r\n\r\n~~I'm going to look at it again with fresh eyes, check the pseudocode against a Sage impl, and update all the ciphersuites as follows:~~ Done!\r\n- [x] add suites for SW map\r\n- [x] update Z for all maps to correspond to the newest requirements\r\n\r\nI should be able to push this tomorrow.",
          "createdAt": "2019-10-23T04:06:30Z",
          "updatedAt": "2019-10-25T04:22:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I think [this message](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/170#issuecomment-545649584) mostly pertains to this PR, so let's move conversation here.\r\n\r\nI'd be glad to look at details of the parameterization you're working on. I guess the main questions from this PR's point of view should be whether it's simpler and whether it will work in (almost) all cases.\r\n\r\nFrom my perspective, we probably shouldn't spend too much time honing this map since it's mostly a fallback...",
          "createdAt": "2019-10-23T21:54:09Z",
          "updatedAt": "2019-10-23T21:54:09Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes my comment should be posted in this thread.\r\nSo I also agree with this PR too. ",
          "createdAt": "2019-10-23T21:57:47Z",
          "updatedAt": "2019-10-23T21:57:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, from my perspective this is now good to go.\r\n\r\nHow about let's not wait on ePrinting the SvdW parameterization, since it'll take a few days for it to appear on ePrint and we can come back and change the URL later. This will let us get the other PRs done.",
          "createdAt": "2019-10-25T04:23:07Z",
          "updatedAt": "2019-10-25T04:23:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjM0NDYx",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T05:06:21Z",
          "updatedAt": "2019-10-23T05:08:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Is there any chance you can put this on ePrint? (The current link doesn't work, so I can't review the rest of the PR!)",
              "createdAt": "2019-10-23T05:06:21Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MDQ3NjQw",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T17:03:26Z",
          "updatedAt": "2019-10-23T17:03:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I can, though there will be some delay before it's accepted (probably makes sense as a way of documenting, though, so I'll plan to do this before we merge this PR)\r\n\r\nThe PDF is included in this PR, or you can find the same file at https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/raw/generalized_svdw/svdw_general.pdf\r\n",
              "createdAt": "2019-10-23T17:03:27Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE2NDc4",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-23T21:57:57Z",
          "updatedAt": "2019-10-23T21:57:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE2Nzkw",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:58:44Z",
          "updatedAt": "2019-10-23T21:58:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do you have a latex source for me to make a PR for that document?",
              "createdAt": "2019-10-23T21:58:44Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NzY1MTYx",
          "commit": {
            "abbreviatedOid": "8d8b974"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T18:06:18Z",
          "updatedAt": "2019-10-24T18:06:18Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The source isn't public right now because it relies on some LaTeX sources that I haven't scrubbed for release. If the proposed edits are small, we can probably handle them in this thread. If you don't think that will work, I'll need to spend some time to make a version of the sources that I can make public.",
              "createdAt": "2019-10-24T18:06:18Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDc2MDIx",
          "commit": {
            "abbreviatedOid": "a9598ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T22:16:31Z",
          "updatedAt": "2019-10-25T22:18:25Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n21.  e2 = is_square(gx2) AND NOT e1     // avoid short-circuit logic ops\r\n```",
              "createdAt": "2019-10-25T22:16:32Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyNzk0MTI5",
      "title": "requirements and guidelines for alternative hash_to_base functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/175",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch gives guidance on how to define a new hash_to_base function and use it\r\nin a way that won't interfere with existing suites.\r\n\r\ncloses #165 ",
      "createdAt": "2019-10-26T19:22:48Z",
      "updatedAt": "2019-10-30T21:29:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a44290412bb28eea77042458d79b28d8dda38756",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "alt_hash_to_base",
      "headRefOid": "2e784b2a36afab2a74d70aa6437337ead82e95c7",
      "closedAt": "2019-10-30T16:29:51Z",
      "mergedAt": "2019-10-30T16:29:50Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c69a465bfe8aae3b785539687d803c6694e4a706"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We *could* add an appendix with a hash_to_base from cSHAKE-128 and/or cSHAKE-256,\r\nbut that might be overkill. Thoughts?",
          "createdAt": "2019-10-26T19:22:58Z",
          "updatedAt": "2019-10-26T19:22:58Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> that might be overkill. Thoughts?\r\n\r\nAgreed :)",
          "createdAt": "2019-10-26T20:28:57Z",
          "updatedAt": "2019-10-26T20:28:57Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "iiuc, ( something might be inaccurate in my description)\r\n\r\nat a higher level, one can think that hash_to_base requires two functions: a hash function H1 and a pseudo-random function H2.\r\n\r\nit would be better to give a description of hash_to_base in terms of H1, H2; and give criteria to choose H1 and H2. This is in some sense already included, but it might be clear for a reader having a notion that 2 functions are required.\r\n\r\nAlso, the ciphersuite can contain another field indicating this choice.\r\n```\r\nCURVE_ID ' -' HASH_ID '-' PRF_ID '-' MAP_ID '-' ENC_ID '-' \r\n```\r\nSome examples:\r\nP256-SHA256-HKDF-SSWU-RO\r\nP256-SHA256-KMAC-SSWU-RO\r\nP256-SHA3256-HKDF-SSWU-RO\r\n\r\nAs side comment: the ciphersuite string is starting to look as a C-struct or a configuration file rather than a unique identifier.\r\n\r\n",
          "createdAt": "2019-10-29T00:09:26Z",
          "updatedAt": "2019-10-29T00:09:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> at a higher level, one can think that hash_to_base requires two functions:\r\n> a hash function H1 and a pseudo-random function H2.\r\n\r\nThis would be a nice thought, but I don't think it's possible to generalize in the way you've stated without putting unnecessary restrictions on alternative hash-to-base functions. The reason is that in general it's not even true that hash_to_base requires H1 and H2!\r\n\r\nAs a few examples:\r\n\r\n- How would you describe the current hash-to-base in terms of these two functions? We might be tempted to say that HKDF is H2 and (e.g.) SHA-256 is H1, but that doesn't work because there's no clean decomposition between HKDF and SHA-256---the former is built in terms of the latter.\r\n\r\n- We might instead be tempted to say that H2 is somehow parameterized over H1, but that *also* doesn't work, because then what would H1 be when H2 = KMAC128? I don't see any sensible assignment to H1 in that case, because KMAC isn't parameterized over a hash function at all.\r\n\r\n- What about the case where someone wants to use HMAC to combine msg, ctr, and DST, then somehow use the result as an AES key? But HMAC can't be H1 because it's not a hash, and AES can't be H2 because it's a PRG, not a PRF (using the distinction discussed above, from [K10](https://eprint.iacr.org/2010/265)).\r\n\r\nBacking up: **the point of this section is not to try and teach someone how to make up their own hash_to_base function**. The one we've got took a good bit of work to get to this point, and there are a lot of subtleties in designing a replacement. The point is to state the high-level *requirements*, and to show how to use it in a way that won't mess up security or interoperability for people using the hash_to_base function given in this document.\r\n\r\n---\r\n\r\nEDIT to add:\r\n\r\n>  P256-SHA256-KMAC-SSWU-RO\r\n\r\nRight, so this is an example of my second bullet above: KMAC doesn't work with SHA-256; it's not parameterized in terms of anything, it's built directly out of the Keccak sponge...\r\n\r\n(~~This also means, admittedly, that the current example of KMAC128 in the HASH_ID field in Suites isn't perfect. I'm not convinced that matters so much there since it's only intended to illustrate how to construct the field, but I'll think about whether there's something better to be said.~~ Fixed.)",
          "createdAt": "2019-10-29T00:25:55Z",
          "updatedAt": "2019-10-29T00:38:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @kwantam's comment above cleared this up, so I'm merging for now. @armfazh please file a separate issue if you think this section needs more work!",
          "createdAt": "2019-10-30T16:29:46Z",
          "updatedAt": "2019-10-30T16:29:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQzMTU1",
          "commit": {
            "abbreviatedOid": "f762e57"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-26T20:47:20Z",
          "updatedAt": "2019-10-26T21:23:59Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\n  It is RECOMMENDED to follow the guidelines for controlling bias\r\n```",
              "createdAt": "2019-10-26T20:47:20Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            },
            {
              "originalPosition": 105,
              "body": "A possible clarification:\r\n\r\n```\r\nThe hash\\_to\\_base function is suitable for use with a wide range of hash functions,\r\nincluding SHA-2 {{FIPS180-4}}, SHA-3 {{FIPS202}}, BLAKE2 {{!RFC7963}}, and others.\r\nIn some cases, however, implementors may wish to replace the HKDF-based function\r\ndefined in this section with one that uses a different underlying pseudorandom generator.\r\n(The function in this section uses HKDF-Expand as a variable-length pseudorandom function\r\nsince it accepts an additional context parameter as input. In practice, however, any pseudorandom\r\ngenerator would suffice provided context strings are supported.) Examples of different\r\npseudorandom functions include extendable-output functions like cSHAKE {{SP.800-185}}\r\nor BLAKE2X {{BLAKE2X}}.\r\n```\r\n\r\nI think this aligns the PRF vs PRG distinction that Hugo makes in his paper, and I hope avoids confusion. (Some readers might observe that HKDF-Expand is a PRF whereas we now refer to it as PRG.)",
              "createdAt": "2019-10-26T21:23:40Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ3NjIz",
          "commit": {
            "abbreviatedOid": "f594d29"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-26T23:23:57Z",
          "updatedAt": "2019-10-26T23:23:58Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "You're right, I was sloppy. We should probably use PRF throughout. Let me try again... :)",
              "createdAt": "2019-10-26T23:23:57Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5Mjc2",
          "commit": {
            "abbreviatedOid": "06ccf38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:39:35Z",
          "updatedAt": "2019-10-27T00:39:35Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "OK, I've pushed some clarifications.\r\n\r\nOne major change is that the section does not recommend any particular primitives, because it seems like not a great idea to recommend something unless we're quite sure it will work.\r\n\r\n(For example, thinking about it more, I think KMAC is a better option than cSHAKE---so I changed the one remaining example in the Suites section.)",
              "createdAt": "2019-10-27T00:39:35Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5MzY2",
          "commit": {
            "abbreviatedOid": "06ccf38"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest changes LGTM!",
          "createdAt": "2019-10-27T00:42:31Z",
          "updatedAt": "2019-10-27T00:42:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyNzk2NTEw",
      "title": "make sgn0 definition per-suite ; improve descriptions of sgn0 and sqrt functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/176",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch does three (roughly) related things:\r\n\r\n1. It defines two variants of sgn0, \"little endian\" (LE) and \"big endian\" (BE).\r\n  - LE is a generalization of IEEE P1363a-2004 Section 5.5.6.1.1, ANSI X9.62-1998, Section 4.2.1, and [SEC 1 Section 2.3.3](https://secg.org/sec1-v2.pdf). (All three of these use the same notion of sign: the value of the least significant bit.)\r\n      \r\n      This is the notion of sign used by most widely-deployed curves. For example, it's the one specified in RFC 8032 (Sections 5.1.3 and 5.2.3) and the one used in TLS (per [RFC 4492, Section 5.1.2](https://tools.ietf.org/html/rfc4492#section-5.1.2)).\r\n\r\n  - BE is equivalent to the method given in IEEE P1363a-2004, Section 5.5.6.1.2.\r\n\r\n      This is the form used by [BLS12-381](https://github.com/zkcrypto/pairing/blob/master/src/bls12_381/README.md), and is the same as what we used to call sgn0.\r\n\r\n2. It adds a sgn0 parameter to each suite that specifies which sgn0 function to use. All suites use sgn0_le except BLS12-381, which corresponds with widely-used notions of sign for each curve.\r\n\r\n3. It clarifies the sqrt functions and gives a constant-time version of Tonelli-Shanks (which works for any p) due to Sean Bowe, Jack Grigg, Eirik Ogilvie-Wigley, and Michael Scott. It also moves these to the appendix, since we treat sqrt as non-normative (in particular, we don't care about how implementors compute the sign).",
      "createdAt": "2019-10-26T19:57:12Z",
      "updatedAt": "2019-10-30T21:29:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a44290412bb28eea77042458d79b28d8dda38756",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sqrt_sgn0_variants",
      "headRefOid": "28961d5e940bb3855b7bb02e4593a9a4141ebd5f",
      "closedAt": "2019-10-30T16:30:12Z",
      "mergedAt": "2019-10-30T16:30:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "46cecc5624cd4ebe63b1e94875afb58d71e7ca36"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased on new master)",
          "createdAt": "2019-10-27T02:19:56Z",
          "updatedAt": "2019-10-27T02:19:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased again. Phew!",
          "createdAt": "2019-10-27T05:54:43Z",
          "updatedAt": "2019-10-27T05:54:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ0NzQ1",
          "commit": {
            "abbreviatedOid": "24e1fd0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-26T21:33:34Z",
          "updatedAt": "2019-10-26T21:41:47Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "```suggestion\r\nOther sgn0 variants are possible, but the two given below cover\r\n```",
              "createdAt": "2019-10-26T21:33:35Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\ncommonly used notions of sign.\r\n```",
              "createdAt": "2019-10-26T21:33:51Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nIt is RECOMMENDED to select the variant that matches the point decompression\r\n```",
              "createdAt": "2019-10-26T21:34:06Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 173,
              "body": "```suggestion\r\nsign, since this may permit simpler implementations.\r\n```",
              "createdAt": "2019-10-26T21:34:38Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 484,
              "body": "Can we drop a reference for this somewhere?",
              "createdAt": "2019-10-26T21:38:10Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 516,
              "body": "`b_is_good` is unused (looks like it should replace `tmp` below!)",
              "createdAt": "2019-10-26T21:38:49Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 77,
              "body": "Hmm, the version of TS in that file seems to only work for certain values of `p`, unless I'm misreading?",
              "createdAt": "2019-10-26T21:41:44Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NDY3",
          "commit": {
            "abbreviatedOid": "7ecb071"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:46:34Z",
          "updatedAt": "2019-10-27T00:46:35Z",
          "comments": [
            {
              "originalPosition": 516,
              "body": "argh, great catch.",
              "createdAt": "2019-10-27T00:46:35Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NTE5",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:49:28Z",
          "updatedAt": "2019-10-27T00:49:28Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "It really does work for any value of p. I think the point is that they only use it for p = 1 mod 16 because otherwise there are the faster special-purpose versions.\r\n\r\n(I confirmed this with Michael Scott, too.)",
              "createdAt": "2019-10-27T00:49:28Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NTY3",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:51:35Z",
          "updatedAt": "2019-10-27T00:51:36Z",
          "comments": [
            {
              "originalPosition": 484,
              "body": "To clarify: do you mean cite the zcash codebase? Happy to do it, though it's possible the link won't age well... :)",
              "createdAt": "2019-10-27T00:51:36Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NzI4",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:00:27Z",
          "updatedAt": "2019-10-27T01:00:27Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "\ud83d\udc4d got it -- the comment in their code was just a bit misleading. Thanks!",
              "createdAt": "2019-10-27T01:00:27Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NzM3",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:00:55Z",
          "updatedAt": "2019-10-27T01:00:56Z",
          "comments": [
            {
              "originalPosition": 484,
              "body": "I'm just trying to give credit where credit is due, though, yeah, not sure how to do that here... :-\\",
              "createdAt": "2019-10-27T01:00:55Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwMTE5",
          "commit": {
            "abbreviatedOid": "707be34"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:18:06Z",
          "updatedAt": "2019-10-27T01:18:07Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We probably could make `m=2` for this example -- there's three redundant zeros!",
              "createdAt": "2019-10-27T01:18:06Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwODI4",
          "commit": {
            "abbreviatedOid": "aa2e077"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:53:18Z",
          "updatedAt": "2019-10-27T01:53:18Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Good point!",
              "createdAt": "2019-10-27T01:53:18Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwODk5",
          "commit": {
            "abbreviatedOid": "eb99c63"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:56:39Z",
          "updatedAt": "2019-10-27T01:56:39Z",
          "comments": [
            {
              "originalPosition": 484,
              "body": "Makes sense! Even if the link dies, it's better to have than not.\r\n\r\nOK now?",
              "createdAt": "2019-10-27T01:56:39Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA4MDgzNTYx",
          "commit": {
            "abbreviatedOid": "28961d5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-28T19:08:25Z",
          "updatedAt": "2019-10-28T19:08:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 177,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE1OTUz",
      "title": "Style nits.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/177",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I combed the document for #105. It all looks good! Though I did notice a couple other inconsistencies and fixed them here.",
      "createdAt": "2019-10-27T01:33:42Z",
      "updatedAt": "2022-02-18T16:42:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "79e2b9d9e05b42effad8d9277a45cb21d746dd37",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/style",
      "headRefOid": "a3df87ba82fb86abdb1ba22a42e00482636db3a4",
      "closedAt": "2019-10-27T02:08:57Z",
      "mergedAt": "2019-10-27T02:08:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d5a6df047322d7ac2b34e2859c69b3d4c6ce3e3d"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just one tiny thing that's my fault!\r\n\r\nEagle eye!",
          "createdAt": "2019-10-27T02:00:56Z",
          "updatedAt": "2019-10-27T02:00:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me. Shall we merge, or do you want to handle #110 here, too?",
          "createdAt": "2019-10-27T02:08:18Z",
          "updatedAt": "2019-10-27T02:08:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's merge, keeping PRs small.",
          "createdAt": "2019-10-27T02:08:53Z",
          "updatedAt": "2019-10-27T02:08:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwOTk3",
          "commit": {
            "abbreviatedOid": "b69e2b0"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Just one tiny thing that's my fault!",
          "createdAt": "2019-10-27T01:59:43Z",
          "updatedAt": "2019-10-27T02:00:09Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n3.   xd = t1 + 1              // Nonzero: -1 is square mod p, t1 is not\r\n```\r\n\r\nOops! I think that was my typo :)",
              "createdAt": "2019-10-27T01:59:44Z",
              "updatedAt": "2019-10-27T02:00:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUxMDg5",
          "commit": {
            "abbreviatedOid": "a3df87b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-27T02:04:19Z",
          "updatedAt": "2019-10-27T02:04:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE3MTA3",
      "title": "fix p256 map in appx for new Z value in suites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/178",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also updated the sage impl and tested to make sure it's correct.",
      "createdAt": "2019-10-27T02:00:45Z",
      "updatedAt": "2019-10-27T02:03:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "79e2b9d9e05b42effad8d9277a45cb21d746dd37",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fix_p256_map",
      "headRefOid": "e00dfc5a7ef63d64aeb5c0f93a4f07bfab4f7eb2",
      "closedAt": "2019-10-27T02:02:06Z",
      "mergedAt": "2019-10-27T02:02:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f294fed3f361d9ed5f4410f190a56f4fcd2f659f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUxMDQ4",
          "commit": {
            "abbreviatedOid": "e00dfc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-27T02:01:51Z",
          "updatedAt": "2019-10-27T02:01:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE4NjI1",
      "title": "consistency: (mod N) in parens",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/179",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Very tiny consistency issue I noticed.\r\n\r\nI guess we could go the other way and get rid of the parens... what looks better to you?",
      "createdAt": "2019-10-27T02:32:37Z",
      "updatedAt": "2019-10-27T05:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d5a6df047322d7ac2b34e2859c69b3d4c6ce3e3d",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "mod_notation",
      "headRefOid": "d2e794750b6baf116367f541295a8c835298e31c",
      "closedAt": "2019-10-27T03:01:28Z",
      "mergedAt": "2019-10-27T03:01:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d2e794750b6baf116367f541295a8c835298e31c"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm used to seeing parentheses. Does this cover all of them, including ones in pseudocode? I see it without parens in the hash_to_base definition, for example. A couple other spots I noticed:\r\n\r\n- `mod 2^255 - 19`\r\n- `Nonzero: -1 is square mod p, xd is not`",
          "createdAt": "2019-10-27T02:48:55Z",
          "updatedAt": "2019-10-27T02:48:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops! Thanks---I'll fix these later tonight. :+1:\n\nOn Sat, Oct 26, 2019, 7:49 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* requested changes on this pull request.\n>\n> I think a couple were missed!\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/179?email_source=notifications&email_token=AAFO6MMGREOG4HZKFNHJD6DQQT6SJA5CNFSM4JFPXHP2YY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCJKN5IA#pullrequestreview-307551904>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAFO6MJLO42GT5MKAHFT3UTQQT6SJANCNFSM4JFPXHPQ>\n> .\n>\n",
          "createdAt": "2019-10-27T02:57:15Z",
          "updatedAt": "2019-10-27T02:57:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I can just fix it here :-) Done and merged!",
          "createdAt": "2019-10-27T03:01:53Z",
          "updatedAt": "2019-10-27T03:01:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUxOTA0",
          "commit": {
            "abbreviatedOid": "d2e7947"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think a couple were missed!",
          "createdAt": "2019-10-27T02:49:07Z",
          "updatedAt": "2019-10-27T02:49:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 180,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE5ODY3",
      "title": "More mods!",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/180",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-27T03:01:17Z",
      "updatedAt": "2022-02-18T16:42:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d5a6df047322d7ac2b34e2859c69b3d4c6ce3e3d",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/mode-mod",
      "headRefOid": "94cf0597d75c1f2b7dcfe51fb4ebf7a46088fd37",
      "closedAt": "2019-10-27T03:01:27Z",
      "mergedAt": "2019-10-27T03:01:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a44290412bb28eea77042458d79b28d8dda38756"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 182,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODgyNTkw",
      "title": "Clarifications around S-SWU map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/182",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a small cleanup:\r\n\r\n- Clarify some text regarding optimized S-SWU implementations.\r\n- Rename \"S-SWU for pairing-friendly\" to \"S-SWU for AB==0\", since it's not really limited to pairing-friendly curves.\r\n- Move the renamed S-SWU,AB==0 section to the Weierstrass subsection of the mappings section.",
      "createdAt": "2019-10-27T18:56:59Z",
      "updatedAt": "2019-10-28T18:33:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a44290412bb28eea77042458d79b28d8dda38756",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "clarify_sswu_opt",
      "headRefOid": "ed23ad17aa66c5194eb2c97941af8e0c6564cc17",
      "closedAt": "2019-10-28T18:27:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing and incorporating into #183, since the two are somewhat related.",
          "createdAt": "2019-10-28T18:27:38Z",
          "updatedAt": "2019-10-28T18:27:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyOTA4MTMy",
      "title": "S-SWU clarifications; example code tests and fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/183",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "High-level summary: this PR adds Sage code that tests all of the example code in the document. In adding these tests, I found some bugs; this PR also fixes those. Details:\r\n\r\nThis PR does a few things related to the document's handling of S-SWU:\r\n\r\n- Clarify some text regarding optimized S-SWU implementations.\r\n- Rename \"S-SWU for pairing-friendly\" to \"S-SWU for AB==0\", since it's not really limited to pairing-friendly curves.\r\n- Move the renamed S-SWU,AB==0 section to the Weierstrass subsection of the mappings section.\r\n- Generalizes S-SWU example code for P-256 to any curve over p = 3 (mod 4), and forward refs from the relevant ciphersuites.\r\n- Makes the \"generic mapping\" approach used for the SvdW sage impl in #172 into a more general-purpose framework.\r\n- Implements the SSWU mapping in the generic mapping framework.\r\n- Parameterizes the optimized S-SWU sage impl.\r\n- Adds tests for the optimized vs. generic sage impl for P-256, P-384, P-521, secp256k1, and BLS12-381 G1.\r\n\r\nIn addition, it:\r\n\r\n- implements Elligator2 in the generic mapping framework discussed above\r\n- fixes bugs in the straight-line Elligator2 impl from Section 6\r\n- fixes bugs in the optimized Elligator2 and Edwards->Montgomery maps in the appendix\r\n- implements Elligator2 for Edwards curves in the generic mapping framework\r\n- fixes the straight-line Montgomery->Edwards mapping\r\n- implements Boneh-Franklin in the generic mapping framework\r\n- implements Elligator 2, A == 0 in the generic mapping framework\r\n\r\nAll of the bugs mentioned above are now tested in the Sage implementations of the optimized maps.",
      "createdAt": "2019-10-28T00:02:58Z",
      "updatedAt": "2019-10-31T21:28:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "46cecc5624cd4ebe63b1e94875afb58d71e7ca36",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sswu_generic",
      "headRefOid": "b79dc33d4f54d8c58d85b83da6f092cc263f4c2c",
      "closedAt": "2019-10-31T21:26:08Z",
      "mergedAt": "2019-10-31T21:26:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6cf678ac3c92083b7934dafb8d8a2f8fefd3d884"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Hmm, we could also use the NIST sample impl as a sample impl for secp256k1. I'll update the text a bit later tonight.~~",
          "createdAt": "2019-10-28T00:11:37Z",
          "updatedAt": "2019-10-28T06:05:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased onto master)",
          "createdAt": "2019-10-30T21:35:53Z",
          "updatedAt": "2019-10-30T21:35:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh thanks! :+1:",
          "createdAt": "2019-10-31T05:59:19Z",
          "updatedAt": "2019-10-31T05:59:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTg5NzA2",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:06:28Z",
          "updatedAt": "2019-10-31T00:06:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The reference [KSS08] is not used in the document",
              "createdAt": "2019-10-31T00:06:28Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTg5ODYw",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:07:00Z",
          "updatedAt": "2019-10-31T00:07:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "BLAKE has a wrong reference",
              "createdAt": "2019-10-31T00:07:00Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTk0NzU4",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:27:53Z",
          "updatedAt": "2019-10-31T00:27:53Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\n8.  y = y * y'\r\n```",
              "createdAt": "2019-10-31T00:27:53Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTk1NTQx",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:31:11Z",
          "updatedAt": "2019-10-31T00:31:12Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n Output: (x, y), a point on an equivalent twisted Edwards curve.\r\n```",
              "createdAt": "2019-10-31T00:31:11Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NjU3NzUz",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T05:39:47Z",
          "updatedAt": "2019-10-31T05:39:47Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Oops! Fixed the BLAKE reference, removed KSS08 from the bib (it isn't used on master either; we can bring it back if we need it later).",
              "createdAt": "2019-10-31T05:39:47Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMTI2ODc4",
          "commit": {
            "abbreviatedOid": "b79dc33"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T19:21:19Z",
          "updatedAt": "2019-10-31T19:21:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMTkwNzI1",
          "commit": {
            "abbreviatedOid": "b79dc33"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I haven't checked the scripts entirely, but the main text is ok. \r\n",
          "createdAt": "2019-10-31T21:24:10Z",
          "updatedAt": "2019-10-31T21:24:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NTYzNjAw",
      "title": "domain separation requirement: simplify",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/184",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Slight text improvement in the DST section, I think.",
      "createdAt": "2019-10-30T23:09:44Z",
      "updatedAt": "2019-10-31T17:05:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "46cecc5624cd4ebe63b1e94875afb58d71e7ca36",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "dst_clarity",
      "headRefOid": "280da4451f19b053c308054b7466c30d68120618",
      "closedAt": "2019-10-30T23:10:34Z",
      "mergedAt": "2019-10-30T23:10:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7fa6e255e55a1ddc497a3271a2236f7076bc1d15"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTczODQ3",
          "commit": {
            "abbreviatedOid": "280da44"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T23:10:29Z",
          "updatedAt": "2019-10-30T23:10:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1MTc0NzE3",
      "title": "howtos: using the document, picking a mapping, creating a suite",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/185",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds some text to make the document a bit more friendly:\r\n\r\n- in the intro, \"how to use this document\"\r\n- in the mappings section, \"how to pick a map for a given curve\"\r\n- in the suites section, \"how to define a new suite\"\r\n\r\nThese are pretty brief, but I think they'll make things a bit clearer.",
      "createdAt": "2019-10-31T21:53:31Z",
      "updatedAt": "2019-11-01T19:47:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6cf678ac3c92083b7934dafb8d8a2f8fefd3d884",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "howto",
      "headRefOid": "74d94acc3dc3420a0518ec952dc78a792f3a3c1d",
      "closedAt": "2019-11-01T19:40:26Z",
      "mergedAt": "2019-11-01T19:40:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bccdbd1cc9cd0be0f18d593737e8b614379d256e"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The last commit in this PR changes variable names like `x', y'` and `x'', y''` to names like `s, t` and `v, w`. This makes things significantly easier to read (in my opinion), which is nice. I need to run away for a bit, but I'm going to take a careful pass over the document and make sure I've got the variables named correctly everywhere (and more eyes on this would be appreciated!)\r\n\r\nIn particular, I've tried to follow the convention that Weierstrass curves use `x, y`, Montgomery curves use `s, t`, and Edwards curves use `v, w`. I know that in other contexts `u, v` is preferred, but we use `u` throughout the document as the input to mapping functions, and I wanted to avoid confusion.",
          "createdAt": "2019-10-31T22:40:31Z",
          "updatedAt": "2019-10-31T22:42:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, there is now a clash in the Interface and Notation sections.\r\n\r\nThanks for the super detailed comments! :+1:\r\n\r\nIt's true that there is a very small clash, in the case of the twisted Edwards maps. (Everything else---including Elligator---is actually working on a Weierstrass curve.) It's a very small thing, and I don't think it will cause confusion, but I will think about how we can resolve it.\r\n\r\n--\r\n\r\nEDIT: added a quick parenthetical in the one spot where there's a notational weirdness.",
          "createdAt": "2019-11-01T06:13:29Z",
          "updatedAt": "2019-11-01T06:25:54Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One other action item for me before we merge this PR is to copy-paste all of the rational map specs into sage and make sure that they work correctly. I'll do this tomorrow.",
          "createdAt": "2019-11-01T06:48:28Z",
          "updatedAt": "2019-11-01T06:48:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you OK with the changes? ",
          "createdAt": "2019-11-01T17:11:51Z",
          "updatedAt": "2019-11-01T17:11:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjYwMDgy",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the clarifying notation and guidance! I only have on comment on content. I'd like to hear from @armfazh before we merge.",
          "createdAt": "2019-11-01T01:51:54Z",
          "updatedAt": "2019-11-01T01:53:21Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I wonder if this paragraph is needed, or if it can be replaced with something a bit lighter, e.g., \"Note that the Shallue-van de Woestijne method ({{svdw}}) works with any curve and may be used in cases where a specific curve is not targeted.\" I read this as sort of recommending this as a viable alternative, which I don't think is a goal. Rather, targeting specific curves seems best. @armfazh, what do you think?",
              "createdAt": "2019-11-01T01:51:54Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjgwMzE5",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I general I liked to use different pair (x,y) for denoting a point, it makes more clear to read when referring to different models. However, there is now a clash in the Interface and Notation sections.\r\n\r\nAlso, I left other comments concerning to the readability of the document.  ",
          "createdAt": "2019-11-01T03:43:26Z",
          "updatedAt": "2019-11-01T05:18:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "recommending the implementation of test vectors is not the main objective of this document. This paragraph adds few information.",
              "createdAt": "2019-11-01T03:43:26Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 4,
              "body": "The important thing that must be presented in the Introduction is the purpose of the document, basically it\r\n1) shows how to perform hashing to elliptic curve points, \r\n2) proposes two encodings with different statistical properties,\r\n3) describes how to construct a ciphersuite for hashing, and \r\n4) recommends ciphersuites for well-known curves.\r\n\r\n",
              "createdAt": "2019-11-01T03:52:30Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 6,
              "body": "There shouldn't be specific distinctions, our audience is  _anyone_ who wants to hash a string into a point.\r\nSo I feel that these paragraphs do not focus on the high level speech required at the Introduction section.",
              "createdAt": "2019-11-01T03:56:17Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 4,
              "body": "I consider that the how-to section is the roadmap section, which could be renamed if needs to be clearer.",
              "createdAt": "2019-11-01T04:25:27Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n As an example, consider a fictional protocol named Quux\r\n```",
              "createdAt": "2019-11-01T04:30:37Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 42,
              "body": "I missed why should be at least 8 bytes. ",
              "createdAt": "2019-11-01T04:32:06Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 59,
              "body": "This could be said using a more natural language. Something like this : \"Each mapping produces a different set of points\" ",
              "createdAt": "2019-11-01T04:41:55Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\n or random oracle encodings using the constructions of {{roadmap}}.\r\n Certain mappings restrict the form of the curve or its parameters.\r\n For each mapping presented, this document lists the relevant restrictions.\r\n```",
              "createdAt": "2019-11-01T04:42:41Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 231,
              "body": "A shorter version can appear at section 6.0 or after Section 6.4, in which recommends the mapping to use according to the type of curve, and thus give forward pointers.\r\n",
              "createdAt": "2019-11-01T04:57:42Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 238,
              "body": "Reverse the order. first Weierstrass, -> Montgomery/Edwards, -> supersingular -> none of the above (Shallue-van de Woestijne)",
              "createdAt": "2019-11-01T04:59:23Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 258,
              "body": "I agree, it would be better to say \" use the Shallue-van de Woestijne mapping if none of the above mappings applies to your curve\" . ",
              "createdAt": "2019-11-01T05:01:17Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 290,
              "body": "```suggestion\r\n1. E, F, p, and m are determined by the elliptic curve and the field.\r\n```",
              "createdAt": "2019-11-01T05:08:25Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 294,
              "body": "```suggestion\r\n3. Choose a hash function H meeting the requirements in {{hashtobase-sec}},\r\n```",
              "createdAt": "2019-11-01T05:11:11Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 304,
              "body": "```suggestion\r\n6. Construct a Suite ID following the guidelines in {{suiteIDformat}}.\r\n```",
              "createdAt": "2019-11-01T05:12:29Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 306,
              "body": "it is not common to standardize curves. Using curves, on the other hand, is more often the case.",
              "createdAt": "2019-11-01T05:14:33Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5Mjg4",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:42:06Z",
          "updatedAt": "2019-11-01T05:42:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I understand your concern here, and it makes a lot of sense. That said, I added these paragraphs for a couple specific reasons:\r\n\r\n1. A couple people asked me to add them! The feedback was basically, \"this document is huge; is there some way to add a small section telling me how to begin implementing a hash-to-curve suite?\"\r\n\r\n2. Related to the above: my guess is that very few people will read the whole document end-to-end (or even close!). Rather, most people will read it either because they're specifying a new protocol or because they're implementing one, hence the quick \"getting started\"--style pointers geared towards those specific audiences.\r\n\r\nI think it would be great if lots of people read the document end to end! but adding this small section certainly won't discourage those people from reading, whereas people who just want to get in and out will really appreciate the quick pointers. Or, at least, that seems to be the case based on the feedback I've gotten recently.",
              "createdAt": "2019-11-01T05:42:06Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5NjQx",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:44:11Z",
          "updatedAt": "2019-11-01T05:44:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "These are good points, and in general I agree. See [my comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/185#discussion_r341457421) below, though: I think adding something along the lines of these two paragraphs will make it easier for people to use the document. And, importantly, having \"how to use this document\" right up front will make it easier to find, and thus more useful.",
              "createdAt": "2019-11-01T05:44:11Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5NjU3",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:44:19Z",
          "updatedAt": "2019-11-01T05:44:20Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Good point. I'll remove this.",
              "createdAt": "2019-11-01T05:44:20Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5OTYw",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:46:12Z",
          "updatedAt": "2019-11-01T05:46:12Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Hmm, I was looking at some old notes earlier and had this as a TODO item, but now that I go back and double check it, I think you're right. I'll remove the minimum size.",
              "createdAt": "2019-11-01T05:46:12Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzAwODQ4",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:51:02Z",
          "updatedAt": "2019-11-01T05:51:02Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "Hmmm.... I'm not sure I understand how this suggestion would work.\r\n\r\nSpecifically, I think going from least specific (Weierstrass) to most specific (supersingular) would be confusing, and would lead people to make incorrect decisions. The reason for the current ordering is that it presents effectively a simple decision tree: the most specific cases should come *first*, and then other cases \"fall through.\"",
              "createdAt": "2019-11-01T05:51:02Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzAxMDY3",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:52:12Z",
          "updatedAt": "2019-11-01T05:52:12Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "You're totally right that it's not common! That said, I think it's a *good* thing to recommend that people standardizing curves generate their own hash-to-curve suites. No? Is there a reason not to include this suggestion?",
              "createdAt": "2019-11-01T05:52:12Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzAxMjA0",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:52:56Z",
          "updatedAt": "2019-11-01T05:52:56Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Good point! Edited.",
              "createdAt": "2019-11-01T05:52:56Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzA0NzY1",
          "commit": {
            "abbreviatedOid": "bafe982"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:11:31Z",
          "updatedAt": "2019-11-01T06:11:32Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "OK, I pushed an edit that tones this down as suggested. Better?",
              "createdAt": "2019-11-01T06:11:32Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzA1NDgx",
          "commit": {
            "abbreviatedOid": "bafe982"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:15:09Z",
          "updatedAt": "2019-11-01T06:15:09Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "Yeah, I think you're totally right that it's best if it lives at the top of 6 rather than the bottom.",
              "createdAt": "2019-11-01T06:15:09Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzA4MDc2",
          "commit": {
            "abbreviatedOid": "f661bfb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:28:31Z",
          "updatedAt": "2019-11-01T06:28:31Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "(Also note: this suggestion was in prior versions of the document---I just moved it here because it seemed to be the right place for it.)",
              "createdAt": "2019-11-01T06:28:31Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzExNDEx",
          "commit": {
            "abbreviatedOid": "2314366"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:43:47Z",
          "updatedAt": "2019-11-01T06:43:48Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "My point is that the suggestion must be broader, not only when someone is stardardizing a curve. \r\nThe suggestion could say something like :  \"anyone using a curve that is not listed in this document should generate a hash to curve method following this recommendation\"\r\n  ",
              "createdAt": "2019-11-01T06:43:47Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzExNjEx",
          "commit": {
            "abbreviatedOid": "2314366"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:44:39Z",
          "updatedAt": "2019-11-01T06:44:40Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "Ah, got it!",
              "createdAt": "2019-11-01T06:44:40Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzExNzUy",
          "commit": {
            "abbreviatedOid": "2314366"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:45:21Z",
          "updatedAt": "2019-11-01T06:45:22Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "I am fine with going from specific to general. I suggested to reverse the order to follow the order of the sections.\r\n ",
              "createdAt": "2019-11-01T06:45:22Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzEyMTM2",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:47:00Z",
          "updatedAt": "2019-11-01T06:47:01Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "Ah, got it. Yeah, I tried to do that for the same reason and it got really messy...",
              "createdAt": "2019-11-01T06:47:00Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzIwMjgy",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T07:22:33Z",
          "updatedAt": "2019-11-01T07:22:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Aligned to those requests, you can consider these paragraphs:\r\n\r\n```\r\nThis document covers a wide range of aspects regarding the security and implementation of hashing to elliptic curves. \r\n\r\nIn particular, protocol designers looking for a hashing method should either choose an existing suite or follow the guidelines to specify a new one (see {{new-suite}}). \r\nAlso, anyone implementing one of these methods could find more interesting going directly to Section X and Y that describe exact parameters for standard curves.\r\n\r\nIn brief summary, once an elliptic curve has been targeted, a hash-to-curve suite requires implementing an encoding function ({{roadmap}}), its constituent subroutines  ({{hashtobase}}, {{mappings}}, {{cofactor-clearing}}), and a few utility functions ({{utility}}).\r\n\r\nIn all cases, special attention is needed to handle domain separation {{domain-separation}}.\r\n```\r\n",
              "createdAt": "2019-11-01T07:22:34Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzIwNjAz",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T07:23:59Z",
          "updatedAt": "2019-11-01T07:23:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The comments for the introduction section (those suggested in this thread) still apply.",
              "createdAt": "2019-11-01T07:23:59Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzIzOTg2",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T07:37:59Z",
          "updatedAt": "2019-11-01T07:37:59Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "The previous paragraph repeats almost the same words.\r\n",
              "createdAt": "2019-11-01T07:37:59Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc1NjIy",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:01:08Z",
          "updatedAt": "2019-11-01T17:01:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Hmm, I think I don't understand the difference between the proposed edit and what's there. The content is almost exactly the same, just presented in a different order. And whereas the version I proposed gives people actionable instructions (do this, then do this, then do that), the version here seems less clear in its purpose.\r\n\r\nSo maybe let's take a step back: what *precisely* is the objection to the current text? In other words, what does the above proposed edit fix? Because, as far as I can tell, the proposed edit no longer tells people \"how to use this document.\"",
              "createdAt": "2019-11-01T17:01:08Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc2OTU0",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:03:30Z",
          "updatedAt": "2019-11-01T17:03:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe I've been unclear. The reason to add this text is that the document needs a friendly entry point that tells people what to do. The scenarios I'm trying to address with these two paragraphs are:\r\n\r\n1. Someone is implementing standard ABC, which says to use hash-to-curve suite XYZ and links to the hash-to-curve document. The implementor follows the link and ends up at this 60 page monster of a document, and has no idea what to do. \"How to use this document\" would tell that implementor, you need to implement this, this, this and this. Done.\r\n\r\n2. Someone is writing standard DEF, and needs a hash function to a curve. So they open the hash-to-curve document and start reading---and they just have no idea what to do. \"How to use this document\" would tell them to find or define a suite (see section X), decide on a domain separation tag, and you're done.\r\n\r\nThe key problem with the document in its current form is that both of the above use-cases require reading essentially the whole document. That should not be true.\r\n\r\nI'm happy to move this content to the roadmap section. Maybe that would help clear up some of these objections, though I still think it's less useful than if it were in the introduction.",
              "createdAt": "2019-11-01T17:03:31Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc3NDg4",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:04:33Z",
          "updatedAt": "2019-11-01T17:04:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Also would like to hear @chris-wood's opinion on putting \"howto\" in the intro vs in the roadmap.",
              "createdAt": "2019-11-01T17:04:33Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc5OTgx",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:09:37Z",
          "updatedAt": "2019-11-01T17:09:37Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "Yep, thanks!",
              "createdAt": "2019-11-01T17:09:37Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNjQ2MTc1",
          "commit": {
            "abbreviatedOid": "74d94ac"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am ok with these changes.",
          "createdAt": "2019-11-01T19:14:11Z",
          "updatedAt": "2019-11-01T19:14:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1NjMyNzE4",
      "title": "fix errors in map appx ; add script to check maps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/186",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Made a script and found a couple typos / errors in the maps appx. Phew!",
      "createdAt": "2019-11-01T21:54:37Z",
      "updatedAt": "2019-11-01T22:23:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "bccdbd1cc9cd0be0f18d593737e8b614379d256e",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "map_fix",
      "headRefOid": "2a8bf2d5cef00bf56d42832c447cd5fe26bbc0f1",
      "closedAt": "2019-11-01T21:58:17Z",
      "mergedAt": "2019-11-01T21:58:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ba064645fdb654de9ffeaf27e749c75a7f9b4dff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzE0NjM0",
          "commit": {
            "abbreviatedOid": "2a8bf2d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-01T21:58:12Z",
          "updatedAt": "2019-11-01T21:58:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1Njk5NTIw",
      "title": "add one more quick map check function",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/187",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This only adds a couple functions to poc/map_check.sage that might be useful in the future.",
      "createdAt": "2019-11-02T02:33:33Z",
      "updatedAt": "2019-11-03T04:41:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "ba064645fdb654de9ffeaf27e749c75a7f9b4dff",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "one_more_map_test",
      "headRefOid": "a6e8e8b588e61308bc600a95a2c1d06cedb21669",
      "closedAt": "2019-11-02T14:04:09Z",
      "mergedAt": "2019-11-02T14:04:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a68a2ab66e2524ac4c68389ce658098684842eac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzcyMDA1",
          "commit": {
            "abbreviatedOid": "a6e8e8b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-02T14:04:04Z",
          "updatedAt": "2019-11-02T14:04:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1OTkwNTY0",
      "title": "code cleanup ; implement suites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/188",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR:\r\n\r\n- moves all old code (i.e., not based on the \"generic map\" concept) into `poc_old`\r\n\r\n- adds support for different sgn0 functions (sgn0_le and sgn0_be) in the generic map framework\r\n\r\n- adds a testing sqrt function that randomizes the returned sign (to ensure that all maps really don't care about sign)\r\n\r\n- brings in an implementation of hash_to_base (borrowed from kwantam/bls_sigs_ref, which has been thoroughly cross-checked against Rust and Python3 impls)\r\n\r\n- implements a generic h2c-suite framework (see `poc/h2c_suite.sage`)\r\n\r\n- implements \"native\" Montgomery and Edwards curve operations for cross-checking the suites (see `poc/curves.sage`)\r\n\r\n- implements all of the suites in the document using the above frameworks (see `poc/suite_*.sage`)",
      "createdAt": "2019-11-03T04:12:24Z",
      "updatedAt": "2019-11-20T03:49:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a68a2ab66e2524ac4c68389ce658098684842eac",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "code_cleanup",
      "headRefOid": "e0292717a903b20a4ab9130d7c0eedb7fb8fdfe6",
      "closedAt": "2019-11-17T03:35:05Z",
      "mergedAt": "2019-11-17T03:35:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d6d786a150ca407e11f2b6e875d462801c139895"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, this is more or less ready for review.\r\n\r\nFrom here it's a pretty simple task (probably quick edits in `poc/h2c_suite.sage`) to output test vectors for any suite. I'm happy to do that in this PR or wait for another one. Thoughts?",
          "createdAt": "2019-11-05T07:22:09Z",
          "updatedAt": "2019-11-05T07:22:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Probably should add a README (which would also handle #151) before merging~~ Done",
          "createdAt": "2019-11-05T07:22:56Z",
          "updatedAt": "2019-11-05T08:09:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Reorganized. This PR does not touch the document, only the code. I'll open a separate PR for the document.",
          "createdAt": "2019-11-05T16:39:25Z",
          "updatedAt": "2019-11-05T16:39:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments @armfazh! I've pushed responses.\r\n\r\n@chris-wood, shall we merge this now and then handle test vector generation in another PR? That way we can decide things like which DSTs to use, what inputs to use, etc. separately from the code changes.",
          "createdAt": "2019-11-16T21:42:58Z",
          "updatedAt": "2019-11-16T21:42:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It'll take me a while to get through these changes, so in order to move things along let's just merge this now!",
          "createdAt": "2019-11-17T03:35:00Z",
          "updatedAt": "2019-11-17T03:35:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTExMDE5",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "So far, I have reviewed these files:\r\n- common.sage\r\n- curves.sage\r\n- map_check.sage\r\n- hash_to_base.py\r\n- ell2_448_opt.sage\r\n- ell2_25519_opt.sage\r\n\r\nI pointed small nits and will continue my review.",
          "createdAt": "2019-11-08T23:28:18Z",
          "updatedAt": "2019-11-09T01:35:45Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "\r\n```suggestion\r\n    p = F.characteristic()\r\n```\r\n\r\n",
              "createdAt": "2019-11-08T23:28:19Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            },
            {
              "originalPosition": 134,
              "body": "given `F = GF(p^m)`,  it should verify that `F.degree() is odd`",
              "createdAt": "2019-11-08T23:43:25Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            },
            {
              "originalPosition": 14,
              "body": "In Line 34:  # https://eprint.iacr.org/2008/013\r\n",
              "createdAt": "2019-11-09T00:18:00Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MDk2MTkz",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "one general recommendation is to make more explicit (for someone reading the code) that suites require of a DST parameter. For example, following the fictitious protocol `DST = \"QUUX-V<xx>-CS<yy>\"`.",
          "createdAt": "2019-11-11T19:06:44Z",
          "updatedAt": "2019-11-11T19:35:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "add a comment to recall the reader that Ap, Bp are parameters of the curve isogenous to E.",
              "createdAt": "2019-11-11T19:06:44Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            },
            {
              "originalPosition": 25,
              "body": "How does L=64 was calculated?",
              "createdAt": "2019-11-11T19:08:51Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5NTY3",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:22:36Z",
          "updatedAt": "2019-11-16T21:22:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "That's the value from the suite; it's calculated using the procedure described in the hash_to_base section. p = 381 bits, the curve gives ~128-bit security; 381 + 128 = 509. Ceil(509 / 8) = 64.",
              "createdAt": "2019-11-16T21:22:36Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTkwMjE2",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:40:34Z",
          "updatedAt": "2019-11-16T21:40:35Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Sorry, the above suggestion is not correct: it breaks the algorithm. Also, this algorithm works whether m is odd or even.",
              "createdAt": "2019-11-16T21:40:34Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTkwMjQ4",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:41:10Z",
          "updatedAt": "2019-11-16T21:41:10Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I have added tests for TS over p^2 and p^3 for random primes p in common.sage",
              "createdAt": "2019-11-16T21:41:10Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTUzMDc0",
      "title": "clarifications in document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes and clarifies a few things:\r\n\r\n- resolves ambiguity in sign of a sqrt in SvdW high-level procedural description\r\n\r\n- remove pairing-friendly draft cite (we can't go to last call with an I-D ref per Nick)\r\n\r\n- update variable names in elliptic curve equations (again, this time I think is better) and make corresponding changes in `map_check.sage`\r\n\r\n- clean up unused stuff: abs(x) is not used, one of the constants in the optimized sswu impl is not used\r\n\r\n- notational consistency throughout\r\n\r\n- slightly improved discussion of indifferentiability\r\n\r\n- other minor touch-up issues\r\n\r\nSee next post for discussion of notation",
      "createdAt": "2019-11-05T19:42:38Z",
      "updatedAt": "2019-12-14T00:33:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d6d786a150ca407e11f2b6e875d462801c139895",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "doc_clarifications",
      "headRefOid": "f3c0f20559b1030f684401d73a6a0474507095a5",
      "closedAt": "2019-12-13T16:08:08Z",
      "mergedAt": "2019-12-13T16:08:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "08541b53792013ac8815d7759d483afc953bd834"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I chose variable names for the elliptic curve equations based on existing notation in the document. Here's what I compiled for current notational usage:\r\n\r\n| letter | use | letter | use |\r\n|:------:|------|:-------:|------|\r\n| a | Edwards coeff | A | short Weierstrass coeff |\r\n| b | | B | short Weierstrass coeff |\r\n| c | pcode const | C | long Weierstrass coeff (NEW) |\r\n| d | Edwards coeff | D | long Weierstrass coeff (NEW) |\r\n| e | | E | an Elliptic curve |\r\n| f | map fn in suites | F | field |\r\n| g | y^2 = g(x) | G | group |\r\n| h | cofactor | H | hash fn |\r\n| i | pcode counter | I | primitive element in extension field |\r\n| j | pcode counter | J | Montgomery coeff (NEW) |\r\n| k | security parameter | K | Montgomery coeff (NEW) |\r\n| l | | L | length in hash_to_base |\r\n| m | extension degree | M | secondary curve in Ell2Edw |\r\n| n | group order | N | |\r\n| o | | O | |\r\n| p | field characteristic | P | EC point |\r\n| q | field order | Q | EC point |\r\n| r | subgroup order | R | EC point |\r\n| s | Montgomery coord (NEW) | S | |\r\n| t | Montgomery coord (NEW) | T | |\r\n| u | input to map_to_curve | U | |\r\n| v | Edwards coord | V |  |\r\n| w | Edwards coord | W |  |\r\n| x | short Weierstrass coord | X | long Weierstrass coord (NEW) |\r\n| y | short Weierstrass coord | Y | long Weierstrass coord (NEW) |\r\n| z | sqrt result in Appx | Z | map_to_curve parameter |\r\n\r\n`tvX` is now temporary variables.\r\n\r\n---\r\n\r\nCurve equations are now:\r\n\r\n- Short Weierstrass: y^2 = x^3 + A * x + B\r\n\r\n- Long Weierstrass: Y^2 = X^3 + C * X^2 + D * X\r\n\r\n- Montgomery: K * t^2 = s^3 + J * s^2 + s\r\n\r\n- twisted Edwards: a * v^2 + w^2 = 1 + d * v^2 * w^2\r\n\r\n---\r\n\r\nEDIT: I've updated to reflect latest commits.",
          "createdAt": "2019-11-05T19:52:24Z",
          "updatedAt": "2019-11-16T22:46:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd really appreciate a careful look at variable naming. I've done a couple passes and I'll do another one, but more eyes is always better.",
          "createdAt": "2019-11-05T19:54:32Z",
          "updatedAt": "2019-11-05T19:54:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm still reviewing all the changes. one first suggestion will be whether the equation `Long Weierstrass: Y^2 = X^3 + C * X^2 + D * X` can be removed.\r\nI know we added it for making explicit the transition between Montgomery -> W -> twisted Edwards. But, it might be better to provide the direct map, thus we release two variables.",
          "createdAt": "2019-11-06T02:07:26Z",
          "updatedAt": "2019-11-06T02:07:26Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "although is correct, Montgomery equation looks strange due to the variables used. We are familiar with this document, and somewhat understand thses choices, but I would prefer to use other variables. \r\nFor example, many people use (u,v) -- but u is already taken\r\n(x, y) -- for Weierstrass is ok\r\n(v,w) -- for Edwards looks good\r\n\r\nif t is needed, you can use T0,T1,T2.... for temporal variables.\r\n\r\n\r\n",
          "createdAt": "2019-11-06T02:12:22Z",
          "updatedAt": "2019-11-06T02:12:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Refactoring this document is not a simple task, but we can try to stick more closely to the literature, even the equations be correct.",
          "createdAt": "2019-11-06T02:13:41Z",
          "updatedAt": "2019-11-06T02:13:41Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the excellent points. I agree, I don't love the weird variable names.\r\n\r\n> if t is needed, you can use T0,T1,T2.... for temporal variables.\r\n\r\nOr tmp1, tmp2, which is anyway nice and intuitive.\r\n\r\nBut: does `K * t^2 = s^3 + J * s^2 + s` look better for Montgomery? Maybe... I think we agree that the capital letters are a bit jarring for variables. But then what do we do with long Weierstrass? Still thinking get rid of it? (But I have to admit that X, Y looks kind of OK, even though V, W doesn't.)\r\n\r\nOther random thoughts:\r\n\r\n- Are you OK with (X, Y) for long Weierstrass, assuming we don't remove it?\r\n\r\n- For coefficients, I guess we could do A, B for short Weierstrass, Aw, Bw for long Weierstrass, and Am, Bm for Montgomery. (I'm not proposing Al, Bl because the `l` is easy to confuse with a `1` or an `I`.) Since the document basically doesn't mix short and long Weierstrass at all, this might actually be OK. But on the other hand, I think the potential for confusing (A, B) with (Aw, Bw) is greater than confusing it with (C, D) or (J, K).\r\n\r\n- The idea of getting rid of long Weierstrass altogether is really interesting. If I'm understanding your suggestion correctly, this would mean we'd have to modify the Elligator map description. I haven't thought about what that would look like, but probably it would be fine---just change around the constants and add two more multiplications (by 1, in the case of 25519 and 448) to the map.\r\n\r\n---\r\n\r\n> Refactoring this document is not a simple task, but we can try to stick more closely to the literature, even the equations be correct.\r\n\r\nIt's a great point, so I went back and refreshed my memory. The paper where Montgomery introduces his curve shape uses `B * y^2 = x^3 + A * x^2 + x`. The twisted Edwards paper uses `B * v^2 = u^3 + A * u^2 + u` for Montgomery curves. The Elligator paper doesn't mention B != 1 for Montgomery curves, so it just uses `y^2 = x^3 + A * x^2 + x`.\r\n\r\nIn other words---the literature tends to disagree a lot.\r\n\r\n(I think RFC7748 follows the twisted Edwards paper---it uses (x, y) for Edwards and (u, v) for Montgomery.)",
          "createdAt": "2019-11-06T05:20:49Z",
          "updatedAt": "2019-11-06T05:24:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Or maybe just using tmp1, ... and then switching (V, W) -> (s, t) would already be enough of an improvement? Hmm. Not so hard to do...",
          "createdAt": "2019-11-06T05:26:35Z",
          "updatedAt": "2019-11-06T05:26:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've tried to resolve the worry about Montgomery coords. It's now back to (s, t), as it is in draft -05.\r\n\r\nTo make this happen, I renamed temporary variables \"tX\" to \"tvX\". I used this rather than \"tmpX\" because essentially all of our example code is already indented for three-character variable names (e.g., gx1), so this does the least damage. Also, this takes fewer columns, which is nice because we're sometimes squeezed for space.\r\n\r\nI also renamed \"s\" to \"z\" in the sqrt appendix, and at the same time I made the other changes I suggested in @chris-wood's recent PR. In doing this, I decided that the sample code to compute c1--c5 for Tonelli-Shanks was not useful (too simplistic, adding complexity to the document for no reason; people can look in example code if they need help).\r\n\r\nFinally, I added a commit that changes comments from `//` to `#` everywhere. This is because we're already giving essentially Python-ish pseudocode, so we may as well use the corresponding comment char. Also, again, it saves one column, which is helpful in a few spots.\r\n\r\nThoughts on this version? Happy to keep editing if you think there are further clarity issues @chris-wood @armfazh ",
          "createdAt": "2019-11-16T22:45:56Z",
          "updatedAt": "2019-11-16T22:45:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood if you're happy with this I'll merge (or you can, of course!)",
          "createdAt": "2019-12-13T05:24:21Z",
          "updatedAt": "2019-12-13T05:24:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with it -- merging away!",
          "createdAt": "2019-12-13T16:08:04Z",
          "updatedAt": "2019-12-13T16:08:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NDM3Mzg5",
          "commit": {
            "abbreviatedOid": "76b03ec"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Make sure to rebase with master.",
          "createdAt": "2019-11-20T00:10:14Z",
          "updatedAt": "2019-11-20T00:47:22Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "These break changes done in #193 .\r\n ",
              "createdAt": "2019-11-20T00:10:15Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 587,
              "body": "here it should be `(X, Y)` ? ",
              "createdAt": "2019-11-20T00:21:31Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 611,
              "body": "> When defining new twisted Edwards curves, a Montgomery equivalent and rational\r\n> map SHOULD be specified, and the sign of the rational map SHOULD be stated\r\n> unambiguously.\r\n\r\nAccording to the last modifications, this paragraph should be updated too with something like this:\r\n\r\n> When defining new twisted Edwards curves, a **Weierstrass** equivalent and rational\r\n> map SHOULD be specified, and the sign of the rational map SHOULD be stated\r\n> unambiguously.\r\n\r\n\r\n",
              "createdAt": "2019-11-20T00:28:13Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 707,
              "body": "Since elligator2 uses a Weierstrass curve defined above, then `M` (which previously referred to a Montgomery curve) got undefined.",
              "createdAt": "2019-11-20T00:30:00Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 1336,
              "body": "@kwantam: Could you please remind me why is required that `g(x)-Z` be irreducible in `find_z_sswu`?",
              "createdAt": "2019-11-20T00:41:58Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NDg0NjAx",
          "commit": {
            "abbreviatedOid": "76b03ec"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T03:00:44Z",
          "updatedAt": "2019-11-20T03:00:45Z",
          "comments": [
            {
              "originalPosition": 833,
              "body": "```suggestion\r\n1. c1 = (q + 1) / 4         # Integer arithmetic\r\n```",
              "createdAt": "2019-11-20T03:00:45Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NDk2MzAy",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T03:54:14Z",
          "updatedAt": "2019-11-20T03:54:14Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Thanks for the heads-up! I made sure to keep #193's changes when rebasing.",
              "createdAt": "2019-11-20T03:54:14Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTAwNTkw",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:14:18Z",
          "updatedAt": "2019-11-20T04:14:19Z",
          "comments": [
            {
              "originalPosition": 611,
              "body": "This is outside the scope of this PR, so I think we should fix it elsewhere---if we do. But:\r\n\r\nNote that this section is (and has been since we included it) a discussion of Edwards-to-Montgomery, not Edwards-to-Weierstrass. So what is written here *is* consistent with this section.\r\n\r\n---\r\n\r\nEDIT: ah, I see. This section *does* have an issue, as you've pointed out, because it's not consistent about Montgomery vs Long Weierstrass. Mea culpa.\r\n\r\nI've opened #195 about this; let's discuss separately from this issue and come up with a plan. In the meantime, we can get the rest of this PR integrated so it doesn't languish.\r\n\r\n---\r\n\r\nOn the other hand, you make a good point: maybe this is needlessly indirect! Why not just do Edwards-to-Weierstrass and then use Elligator2 directly? From my perspective, the answer is that most curves will have an Edwards-to-Montgomery map defined, and thus most readers will already be familiar with that map---so talking about it in those terms will be more familiar to the reader.\r\n\r\nAlso, remember: the reason we do Edwards-to-Montgomery in the first place is so that Edwards and Montgomery hashes are compatible, *and can share an implementation*. So the whole point is, once someone has a hash to a Montgomery curve, they just implement a map to the Edwards and they're done.\r\n\r\nFinally, in practice, most Montgomery curves that people use have B = 1, which means that they're already equivalent to the long Weierstrass form---so this distinction is mostly academic. But from my perspective it's cleaner to keep the internal details of the Montgomery map in the Montgomery section, and treat it as a black box here.\r\n\r\nIf you'd like to keep discussing this, maybe let's move it to its own issue?",
              "createdAt": "2019-11-20T04:14:19Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTAzNTQy",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:28:56Z",
          "updatedAt": "2019-11-20T04:28:57Z",
          "comments": [
            {
              "originalPosition": 707,
              "body": "Yeah, I see what you mean. We could call it E', I suppose.\r\n\r\nThe fundamental issue is that, as you have pointed out above, the \"Montgomery to Edwards\" section is inconsistent. Let's fix this after discussing in #195 rather than here, OK?",
              "createdAt": "2019-11-20T04:28:56Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTAzOTQ4",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:30:41Z",
          "updatedAt": "2019-11-20T04:30:41Z",
          "comments": [
            {
              "originalPosition": 1336,
              "body": "Sure thing! It's an attempt to avoid infringing on an existing patent. See [my post](https://mailarchive.ietf.org/arch/msg/cfrg/jV4Wr4fbMKkd4vzsbEhKbous16Y) from the cfrg mailing list.",
              "createdAt": "2019-11-20T04:30:41Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTA5NDkz",
          "commit": {
            "abbreviatedOid": "3566f35"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:57:15Z",
          "updatedAt": "2019-11-20T04:57:16Z",
          "comments": [
            {
              "originalPosition": 587,
              "body": ":+1: pushed a pass over the document that addresses this.",
              "createdAt": "2019-11-20T04:57:15Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwMjQ5NjAz",
          "commit": {
            "abbreviatedOid": "b183bd8"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Only small nits, you can merge after solving them.\r\nAlso, we will continue the discussion on #195 .",
          "createdAt": "2019-11-20T20:22:32Z",
          "updatedAt": "2019-11-20T20:41:13Z",
          "comments": [
            {
              "originalPosition": 683,
              "body": "Something shorter\r\n \r\n```suggestion\r\n(v, w) = (0, 1), which is the identity point \r\n```",
              "createdAt": "2019-11-20T20:22:32Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 684,
              "body": "```suggestion\r\non all twisted Edwards curves.\r\n```",
              "createdAt": "2019-11-20T20:22:59Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 1449,
              "body": "```suggestion\r\n3. tv2 = tv1 * c1\r\n4.   z = CMOV(tv2, tv1, e)\r\n5. return z\r\n```",
              "createdAt": "2019-11-20T20:32:44Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 1450,
              "body": "```suggestion\r\n```",
              "createdAt": "2019-11-20T20:32:56Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwMjYwNTcz",
          "commit": {
            "abbreviatedOid": "b183bd8"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T20:43:12Z",
          "updatedAt": "2019-11-20T20:43:12Z",
          "comments": [
            {
              "originalPosition": 611,
              "body": "Move discussion to 195",
              "createdAt": "2019-11-20T20:43:12Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTY4MDQx",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:08:31Z",
          "updatedAt": "2019-11-21T00:08:32Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "This constant can be omitted since calling to sqrt already includes this constant as q=3 (mod 4).\r\nReplace \r\n```\r\n6.   Y = gX1^c1\r\n```\r\nby \r\n```\r\n6.   Y = sqrt(gX1)\r\n```",
              "createdAt": "2019-11-21T00:08:31Z",
              "updatedAt": "2019-11-21T00:08:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTY5MzM3",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:12:58Z",
          "updatedAt": "2019-11-21T00:12:58Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "This would be a nice simplification, but I don't think it works in this context.\r\n\r\nThe reason is, gX1 is not guaranteed to be square, and we define our sqrt functions only for square inputs.\r\n\r\nTo be sure, we both know that the sqrt function we give for q = 3 mod 4 does the right thing in this context! The problem is that we've told the reader elsewhere that they can use whatever sqrt function they want---so we can't be sure that they're going to use the right one.\r\n\r\nThe point here is that we're *not necessarily* taking the sqrt of gX1---we might instead get back the sqrt of -gX1. So saying `sqrt(gX1)` won't connect to readers who don't already know this trick for `q = 3 mod 4`.",
              "createdAt": "2019-11-21T00:12:58Z",
              "updatedAt": "2019-11-21T00:17:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTc2NzEw",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:36:47Z",
          "updatedAt": "2019-11-21T00:36:47Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "oh, I got it.\r\nSo using the exponentiation you are preventing (for instance) the following case: someone implemeted sqrt in such a way that always returns error when the sqrt is not found.\r\n\r\n",
              "createdAt": "2019-11-21T00:36:47Z",
              "updatedAt": "2019-11-21T00:36:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTgxMzUy",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:51:42Z",
          "updatedAt": "2019-11-21T00:51:42Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "Yes, exactly right. Nicely put.",
              "createdAt": "2019-11-21T00:51:42Z",
              "updatedAt": "2019-11-21T00:51:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4MTk3OTIz",
      "title": "Add appendix section for `clear_cofactor` in BLS12-381 G2.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/191",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request fixes #166 specifying the algorithm of [BP18] for a fast cofactor clearing.",
      "createdAt": "2019-11-07T19:14:41Z",
      "updatedAt": "2020-04-17T23:04:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8e4b62bc2c615c9c8669d4d507c5dc1cc2cdc610",
      "headRepository": "mmaker/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "b4a94a8e3f1a3685b2d5cfadb3e570d78d382abe",
      "closedAt": "2020-04-17T23:04:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello @chris-wood  and @kwantam! I doublechecked the code in the pull request and the analogous rust implementation is now in https://github.com/zkcrypto/bls12_381. What do you think?",
          "createdAt": "2019-12-17T11:06:38Z",
          "updatedAt": "2019-12-17T11:06:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent! I finally should have some time to look at this in the next few days. I'll get back to you asap!",
          "createdAt": "2019-12-17T17:26:06Z",
          "updatedAt": "2019-12-17T17:26:06Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased onto master because diff tab was super confused :)",
          "createdAt": "2020-02-25T02:09:45Z",
          "updatedAt": "2020-02-25T02:09:45Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @kwantam, thanks a lot for this review! I updated the pull request integrating your comments, and rebasing it all on master to keep the git log tidied up :). What do you think?",
          "createdAt": "2020-03-11T13:25:26Z",
          "updatedAt": "2020-03-11T13:26:29Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hello @kwantam ! any updates on this?\r\n\r\n(hope you're doing fine during these crazy days!)",
          "createdAt": "2020-03-23T08:18:00Z",
          "updatedAt": "2020-03-23T08:18:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> hello @kwantam ! any updates on this?\r\n> \r\n> (hope you're doing fine during these crazy days!)\r\n\r\nHi! Thanks for the updates---I'll take another look asap (tomorrow, I hope).\r\n\r\nHope you're staying well, too :)",
          "createdAt": "2020-03-26T02:55:12Z",
          "updatedAt": "2020-03-26T02:55:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, but just to make sure I understand correctly: the pseudocode assumes homogeneous projective coordinates, right? In other words, the projective point (X : Y : Z) corresponds to the affine point (X/Z, Y/Z), yes?\r\n",
          "createdAt": "2020-03-29T02:02:35Z",
          "updatedAt": "2020-03-29T02:02:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I reformatted the code samples to better match the rest of the document, moved this section into the sample code appendix, and added a sage file to test the code. See #232.\r\n\r\nPlease let me know if anything there looks amiss, and thank you again for documenting this!",
          "createdAt": "2020-03-29T03:50:00Z",
          "updatedAt": "2020-03-29T03:50:00Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey, \r\n\r\nthanks a lot for the additional edits, overall it looks much better now!\r\n\r\n> Ah, but just to make sure I understand correctly: the pseudocode assumes homogeneous projective coordinates, right? In other words, the projective point (X : Y : Z) corresponds to the affine point (X/Z, Y/Z), yes?\r\n\r\n\r\nYes, I tested this code on jacobian coordinates (used by zkcrypto/bls12_381) and homogeneous projective coordinates  (used by sage).\r\n\r\nPerhaps you want to mention in `#clear-cofactor-bls12381-g2` that those coordinates are called \"homogeneous\" and that it is also applicable to \"jacobian coordinates\"? The SWE that will implement those will probably already know those names from the addition formulas.\r\n\r\nThe code seems fine too! \r\n(Although maybe using python's unittests module and `range(ntests)` would be a bit more pythonic :P)",
          "createdAt": "2020-04-11T10:09:48Z",
          "updatedAt": "2020-04-11T10:09:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODMwMzk0",
          "commit": {
            "abbreviatedOid": "41ed1e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Sorry for the delay in reviewing.\r\n\r\nIf you don't have cycles to make edits, I'm happy to edit and include. In either case, we really really appreciate your help with this!!!",
          "createdAt": "2020-02-25T02:16:55Z",
          "updatedAt": "2020-02-25T02:29:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nBudroni and Pintore ({{BP18}}, Section 4.1).\r\n{{clear-cofactor-bls12381-g2}} gives an example implementation of this method.\r\n```",
              "createdAt": "2020-02-25T02:16:56Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 16,
              "body": "The existence of faster methods is already stated in `{{cofactor-clearing}}`, so that fact should not be repeated here.\r\n\r\nIn addition, it does not seem correct to say that \"we propose\" this method---*Budroni and Pintore* proposed this method, based on `{{SBCDK09}}` and `{{FKR11}}`.\r\n\r\nBut: I wouldn't say any of that here, since it's redundant with the text in `{{cofactor-clearing}}`. Instead, I'd forward ref from the bullet there to here and then this section should jump right into example code.",
              "createdAt": "2020-02-25T02:20:14Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 23,
              "body": "As above, redundant. I'd also get rid of the second-level heading---one level of heading is enough.",
              "createdAt": "2020-02-25T02:20:42Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 36,
              "body": "This duplicates the definitions in `{{suites-bls12381-g2}}`. Instead, please refer to those definitions with a crossref, and then *only* define the constant you need (which I believe is `u = I + 1`, as `I` is defined in the appropriate Suites subsection).\r\n\r\nI wouldn't bother with the `EllipticCurve()` stuff here. The goal should be to present it in a way that is readable to a human, not as syntactically correct Sage code (we could *also* add that if we wanted, but for the spec document itself that's beside the point).",
              "createdAt": "2020-02-25T02:23:42Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 43,
              "body": "Here, we probably first need to define `frobenius` (because this subsection should be for human consumption, not for Sage's consumption).\r\n\r\nThen it would be useful to write out the values of x, y, and z on separate lines so that it's more easily understood.",
              "createdAt": "2020-02-25T02:25:49Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 48,
              "body": "Same as prior comment: x, y, z, one per line please",
              "createdAt": "2020-02-25T02:26:02Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 51,
              "body": "Maybe be explicit: `u^((p-1)/3)` and `u^((p-1)/2)`, or whatever. It might be even better to follow the format we use elsewhere, and call these constants `c1`, `c2`, ...",
              "createdAt": "2020-02-25T02:26:49Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 18,
              "body": "This is a collision in terminology. We use `E'` to mean a curve isogenous to `E`. This should be called \"Cofactor clearing for BLS12-381 G2\", or something like that.",
              "createdAt": "2020-02-25T02:27:56Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 53,
              "body": "`E'` (see comment above)",
              "createdAt": "2020-02-25T02:28:19Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 61,
              "body": "comment says `psi(psi(P))`, but code says `psi(psi(2 * P))` (issue continued in comments below)",
              "createdAt": "2020-02-25T02:28:49Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNjE0OTQ2",
          "commit": {
            "abbreviatedOid": "41ed1e1"
          },
          "author": "mmaker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-11T10:00:00Z",
          "updatedAt": "2020-03-11T10:00:00Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fixed, thanks! ",
              "createdAt": "2020-03-11T10:00:00Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzY0NDg2",
          "commit": {
            "abbreviatedOid": "b4a94a8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is great!\r\n\r\nThere are a couple small changes I'd like to make for consistency with the example code elsewhere, but they're very small and I'm happy to make them myself.",
          "createdAt": "2020-03-29T01:34:11Z",
          "updatedAt": "2020-03-29T01:34:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4NzcwNjY5",
      "title": "Clarify Tonelli-Shanks algorithm variable.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/192",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, remove unused extension degree parameters where not used.",
      "createdAt": "2019-11-08T17:06:30Z",
      "updatedAt": "2022-02-18T16:42:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a68a2ab66e2524ac4c68389ce658098684842eac",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/tonelli-shanks-fix",
      "headRefOid": "e31b0859a954d268cf4b50d5f1aa5f5240549ac5",
      "closedAt": "2019-11-12T18:47:38Z",
      "mergedAt": "2019-11-12T18:47:38Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "7f27a3dbfc74950f9cd5a116cb7a73175ea2ad01"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I'll just fix the T-S issues here. We can resolve the other stuff in a separate PR!",
          "createdAt": "2019-11-11T18:14:26Z",
          "updatedAt": "2019-11-11T18:14:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam please merge if you think it's good to go!",
          "createdAt": "2019-11-12T18:22:26Z",
          "updatedAt": "2019-11-12T18:22:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTA2Mjgx",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T23:10:12Z",
          "updatedAt": "2019-11-08T23:10:12Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Input: x, an element of F.\r\nOutput: r, an element of F such that r^2 == x, if x is a square in F.",
              "createdAt": "2019-11-08T23:10:12Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTA2Nzk1",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T23:12:08Z",
          "updatedAt": "2019-11-08T23:12:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't follow?",
              "createdAt": "2019-11-08T23:12:08Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTA3MDA1",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T23:12:50Z",
          "updatedAt": "2019-11-08T23:12:50Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Oh, you just want to rename. (This comment doesn't apply to the current line.)",
              "createdAt": "2019-11-08T23:12:50Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTQ5ODM5",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The edits look good. A few more things that could be fixed:\r\n\r\n1. The headings could be updated to say (e.g.) `q = 3 mod 4` rather than `p = 3 mod 4`.\r\n2. Could get rid of `p` in the parameters, too! (Notice that the constants are written in terms of q.)\r\n3. Could pull the `{{AR13}}` and `{{S85}}` cites to top of section.\r\n4. the \"Note that...\" in the 9 mod 16 case is redundant if p is renamed to q.\r\n5. As @armfazh points out, `r` in T-S should really be `s`; `r` is a reserved letter :)\r\n\r\nIf you'd like, I'm happy to make some of these edits and push them to this branch.",
          "createdAt": "2019-11-09T09:32:47Z",
          "updatedAt": "2019-11-09T09:32:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1NzU0MjQz",
          "commit": {
            "abbreviatedOid": "88aebd1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Sorry, one error that's my fault.",
          "createdAt": "2019-11-12T18:37:21Z",
          "updatedAt": "2019-11-12T18:37:35Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n7.      for j in (1, 2, ..., k - 2):\r\n```\r\n\r\nOops! This is my fault.\r\n\r\nI just mechanically translated the code from the latest commit into Sage and it runs correctly after the above change.",
              "createdAt": "2019-11-12T18:37:22Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1NzYwMjU4",
          "commit": {
            "abbreviatedOid": "e31b085"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T18:47:12Z",
          "updatedAt": "2019-11-12T18:47:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjMwODc0",
      "title": "Extension fields everywhere.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/193",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n- Matching polynomial basis with polynomial representation, like in FIPS 186-4 (Sec. D.1.1.3).\r\n- F is an extension field.\r\n\r\n",
      "createdAt": "2019-11-11T21:47:45Z",
      "updatedAt": "2019-11-17T03:28:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a68a2ab66e2524ac4c68389ce658098684842eac",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "polynomialRep",
      "headRefOid": "205660e89c42d438e5dff1a502d76cb392914299",
      "closedAt": "2019-11-17T03:28:30Z",
      "mergedAt": "2019-11-17T03:28:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6d956280c019ef4273a211f7f4012f7c3452a073"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I will review more carefully, but fundamentally I do not like \"polynomial\" in place of \"vector.\" It sounds more \"science-ey\" but is no more precise, and will be less intuitively familiar to readers.\r\n\r\n---\r\n\r\nEDIT to add: I'm on a deadline until Friday, so probably I won't have time to review until after that. Sorry...",
          "createdAt": "2019-11-12T18:22:01Z",
          "updatedAt": "2019-11-12T18:39:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1ODgzNTQx",
          "commit": {
            "abbreviatedOid": "9a32580"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I agree with @kwantam here. I think we should keep our use of the vector representation, perhaps with a note that says this is equivalent to a polynomial basis representation. ",
          "createdAt": "2019-11-12T22:17:59Z",
          "updatedAt": "2019-11-12T22:19:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "nit: missed `vector` usage here and elsewhere (L1354 below)",
              "createdAt": "2019-11-12T22:17:59Z",
              "updatedAt": "2019-11-14T21:43:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjczNDUy",
          "commit": {
            "abbreviatedOid": "e624edf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-14T21:31:45Z",
          "updatedAt": "2019-11-14T21:31:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This change should probably be reverted too, right?",
              "createdAt": "2019-11-14T21:31:45Z",
              "updatedAt": "2019-11-14T21:43:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3Mjc5OTU5",
          "commit": {
            "abbreviatedOid": "205660e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-14T21:43:36Z",
          "updatedAt": "2019-11-14T21:43:36Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "true.",
              "createdAt": "2019-11-14T21:43:36Z",
              "updatedAt": "2019-11-14T21:43:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTkwMzQx",
          "commit": {
            "abbreviatedOid": "205660e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1: ",
          "createdAt": "2019-11-16T21:44:14Z",
          "updatedAt": "2019-11-16T21:44:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyNjc1NDU4",
      "title": "Generation of test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/196",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is re-based on top of #189 and #201 .\r\n\r\nJSON test vectors for matching compatible implementations.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"ciphersuite\": \"P256-SHA256-SSWU-RO-\",\r\n  \"curve\": \"P256\",\r\n  \"dst\": \"QUUX-V01-CS02\",\r\n  \"field\": {\r\n    \"m\": \"0x1\",\r\n    \"p\": \"0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\"\r\n  },\r\n  \"hash\": \"sha256\",\r\n  \"map\": {\r\n    \"name\": \"SSWU\",\r\n    \"sgn0\": \"sgn0_le\"\r\n  },\r\n  \"randomOracle\": true,\r\n  \"vectors\": [\r\n    {\r\n      \"P\": {\r\n        \"x\": \"0x8beb73a82ebeb6b400456f4da126aacbfa9b8049b71b250d2b7e4885b6b466bd\",\r\n        \"y\": \"0x15826dc578f4fbc1ac5fc3f9e15da3ece18be914f332bce8ce5bf1371805d149\"\r\n      },\r\n      \"msg\": \"\"\r\n    },\r\n ]\r\n}\r\n```",
      "createdAt": "2019-12-13T00:52:15Z",
      "updatedAt": "2020-02-25T02:27:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "efd1b186af6fe8ca2b75058bf6ae8e1c6bbaa6a9",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "test_vectors",
      "headRefOid": "78c36c36d76c8338f1824724342d7401d7f62b75",
      "closedAt": "2020-02-25T02:27:41Z",
      "mergedAt": "2020-02-25T02:27:41Z",
      "mergedBy": "armfazh",
      "mergeCommit": {
        "oid": "2500e6c42c16ae719c92c4f60aac4b003662c24f"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice! I will take a more careful look in the next few days.\r\n\r\nTo be clear: the JSON wouldn't go into the document, right? (Of course, we can provide test vector files to be downloaded and mechanically processed.)\r\n\r\nSo probably we will also want a script to turn the JSON structures into whatever format will actually go into the appendix of the document. (Or have I missed it, and that's already here?)",
          "createdAt": "2019-12-13T04:38:22Z",
          "updatedAt": "2019-12-13T04:38:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> To be clear: the JSON wouldn't go into the document, right? \r\n\r\nNo, only ascii. JSON files are intended to be available at an external repo.\r\n\r\n> So probably we will also want a script to turn the JSON structures into whatever format will actually go into the appendix of the document.\r\n\r\nNow it supports both ascii and json formats.\r\n\r\n",
          "createdAt": "2019-12-14T01:59:46Z",
          "updatedAt": "2019-12-14T02:00:44Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This branch has been rebased including the Python3 updates. \r\nShould I also include in this PR the test vector  (json/ascii) files?\r\n",
          "createdAt": "2020-01-22T00:19:22Z",
          "updatedAt": "2020-01-22T00:19:22Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I know that I still need to review this. I'm sorry for the very long delay. I should have time this week.\r\n\r\nJust to double check: The Sage9/Python3 version generates the same test vectors as the Sage8/Python2 version, right?",
          "createdAt": "2020-01-22T01:40:32Z",
          "updatedAt": "2020-01-22T01:40:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The SHA512 suites for {curve/edwards}25519 are now included in Sage scripts.",
          "createdAt": "2020-01-29T02:15:04Z",
          "updatedAt": "2020-01-29T02:15:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I rebased this on top of master because the diff interface was very confused :)",
          "createdAt": "2020-02-25T01:46:33Z",
          "updatedAt": "2020-02-25T01:46:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODIyMzAx",
          "commit": {
            "abbreviatedOid": "5d30875"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. I re-ran test vector generation on my machine (sage9/python3) and got the same files back out. Just a few very small things.\r\n\r\nI assume once #212 lands and we update the code to the new suites we'll generate new test vectors, but it doesn't hurt to have these in the repo history anyway, IMO.",
          "createdAt": "2020-02-25T01:48:11Z",
          "updatedAt": "2020-02-25T01:59:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Probably not an issue here, but `-j` can totally thrash a machine, so I try to avoid suggesting it by default. Maybe out of an abundance of caution\r\n\r\n```suggestion\r\n1. `make -j4` --- This preprocesses the sage files. If you don't do this, you'll get\r\n```\r\n\r\n:man_shrugging:",
              "createdAt": "2020-02-25T01:48:12Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n        self.name = \"ELL2\"\r\n```\r\n\r\nMaybe use this to match the naming scheme in the Suites?",
              "createdAt": "2020-02-25T01:49:33Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-02-25T01:53:50Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-02-25T01:54:06Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-02-25T01:54:15Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODMwNjg1",
          "commit": {
            "abbreviatedOid": "5d30875"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I did a quick cursory scan -- looks good! (Riad having run them gives me confidence it's good to go.)",
          "createdAt": "2020-02-25T02:17:56Z",
          "updatedAt": "2020-02-25T02:17:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODMwNzQz",
          "commit": {
            "abbreviatedOid": "5d30875"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-25T02:18:10Z",
          "updatedAt": "2020-02-25T02:18:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzMTI0NTE2",
      "title": "tiny build fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/197",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new version of xml2rfc doesn't like empty dates, and something has started dumping out an empty metadata.min.js file.\r\n\r\nFix empty date, add metadata.min.js to .gitignore.",
      "createdAt": "2019-12-14T00:55:02Z",
      "updatedAt": "2019-12-15T20:03:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "08541b53792013ac8815d7759d483afc953bd834",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "small_fixes",
      "headRefOid": "6323fcb0b28de49994584cfd20e6114de38198f7",
      "closedAt": "2019-12-14T03:29:30Z",
      "mergedAt": "2019-12-14T03:29:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6cf7fa9742e2f85f5ee6454861afd462e38d4230"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMTkzNTY3",
          "commit": {
            "abbreviatedOid": "6323fcb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-14T03:29:26Z",
          "updatedAt": "2019-12-14T03:29:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzMTI4Njgw",
      "title": "remove Boneh-Franklin and Ell2C0 maps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/198",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Having chatted with folks at ECC and elsewhere, I've become convinced that there's no need to support Boneh-Franklin or Elligator2, C=0.\r\n\r\nAs far as I can tell, there are no applications that are geared specifically towards the very narrow class of curves that these maps support. Moreover, if anyone wants to map to such curves, they can just use one of the other maps---SvdW and SWU would both work (the latter via the isogeny trick).\r\n\r\nSo: from my perspective it's better to simplify the document and not include these. Of course, if anyone decides in the future they really want to use these maps, they can grab the text from draft-05 (or the git repo) and easily do so. But my guess is that no one will...\r\n\r\nI know this PR might be controversial, and I'll understand if y'all disagree! :)\r\n\r\n----\r\n\r\nEDIT: this pr is built on #197, so if we decide to merge it we should do so after that one",
      "createdAt": "2019-12-14T01:32:04Z",
      "updatedAt": "2020-01-23T22:13:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4bde0ada68d389ebf3a24bf0879bfb6db0d6351a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "remove_pfc",
      "headRefOid": "13c241f06dcee5ddeeafc4fad00cd3df859525b3",
      "closedAt": "2020-01-23T21:22:06Z",
      "mergedAt": "2020-01-23T21:22:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fcacfa4e2f1feec7754ae0ef3e8c8ed2b6418a90"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I checked, looks like this branch is up-to-date and ready for review.",
          "createdAt": "2020-01-21T16:50:57Z",
          "updatedAt": "2020-01-21T16:50:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, please take a look! Let's aim to merge this by the end of the week.",
          "createdAt": "2020-01-21T18:29:48Z",
          "updatedAt": "2020-01-21T18:29:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Some arguments on favor of keeping them.\r\nNote that these maps are faster and simpler of implementing than SvdW and SSWU+Isog. \r\nSomeone should be tempted to use them due to their efficiency.\r\nIf someone really needs them, this document specifies their correct usage and compatibility. Otherwise, nothing guarantees that the same specification will be followed.\r\n",
          "createdAt": "2020-01-22T01:03:36Z",
          "updatedAt": "2020-01-22T01:03:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased on master, tested against Sage 9 and Sage 8.1.)",
          "createdAt": "2020-01-22T15:27:47Z",
          "updatedAt": "2020-01-22T15:27:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, all of the points you make are good ones, and I fully agree that there would be good reason to keep these maps if anyone were interested in hashing to the curves they support. But as far as I can tell there is no such interest---so I think the advantages of keeping these maps are mostly hypothetical, while the advantage of simplifying the document by removing them appears to be real.\r\n\r\nThat said, I think we may have other, more important things to worry about (issue coming soon), so I don't want to get bogged down in a disagreement on this one; happy to go either way.",
          "createdAt": "2020-01-22T15:49:04Z",
          "updatedAt": "2020-01-22T15:49:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, I think we should remove them. If we later find an application that needs them, we can always spin a new document to include them. @armfazh, would that work?",
          "createdAt": "2020-01-23T17:57:41Z",
          "updatedAt": "2020-01-23T17:57:41Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm agree, also additionally to the changes of this PR, we could include a small paragraph just mentioning these maps in the Appendix.",
          "createdAt": "2020-01-23T18:07:47Z",
          "updatedAt": "2020-01-23T18:07:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I pushed an edit that mentions BLMP19 in the Related Work section. BF01 was already mentioned there. Does this work for you?",
          "createdAt": "2020-01-23T20:58:56Z",
          "updatedAt": "2020-01-23T20:58:56Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM, ",
          "createdAt": "2020-01-23T21:19:18Z",
          "updatedAt": "2020-01-23T21:19:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MDk2Mjcy",
          "commit": {
            "abbreviatedOid": "362e5a9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T18:28:56Z",
          "updatedAt": "2020-01-21T18:28:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTAxODM3",
          "commit": {
            "abbreviatedOid": "7cf3580"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T18:07:57Z",
          "updatedAt": "2020-01-23T18:07:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NTQ1Njcy",
      "title": "update poc/ code to be compatible with python3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/201",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the code to work with Python3/Sage9.\r\n\r\nI've tested with Sage9 and with Sage8.1, and both appear to work correctly.\r\n\r\n--\r\n\r\nSeems good to go now. Closes #199.",
      "createdAt": "2020-01-21T22:11:18Z",
      "updatedAt": "2020-01-22T15:18:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6cf7fa9742e2f85f5ee6454861afd462e38d4230",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "py3",
      "headRefOid": "4686684bc2b44d3e512cf441d0cf59e1d363c046",
      "closedAt": "2020-01-22T02:17:32Z",
      "mergedAt": "2020-01-22T02:17:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4bde0ada68d389ebf3a24bf0879bfb6db0d6351a"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "All tests pass in Sage v9. LGTM for merging\r\n",
          "createdAt": "2020-01-22T00:17:45Z",
          "updatedAt": "2020-01-22T00:18:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MzExODU3",
          "commit": {
            "abbreviatedOid": "4686684"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @kwantam! This LGTM, too.",
          "createdAt": "2020-01-22T02:17:24Z",
          "updatedAt": "2020-01-22T02:17:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2NjA1NDgw",
      "title": "define SHA512 suites for *25519",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/204",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Ed25519 pairs SHA-512 with the edwards25519 curve. Because of this, several other protocols use this combination of primitives, including the VRF draft and CPace. So probably it makes life easy for us to define this suite.",
      "createdAt": "2020-01-23T22:51:27Z",
      "updatedAt": "2020-02-16T01:22:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fcacfa4e2f1feec7754ae0ef3e8c8ed2b6418a90",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "curve25519_sha512",
      "headRefOid": "0104885b6943fda672d60a82a1d63b94da139a11",
      "closedAt": "2020-01-25T14:01:25Z",
      "mergedAt": "2020-01-25T14:01:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6ec26b0b97e760c2b8f960284d1207805c42ea1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjQ1MzIz",
          "commit": {
            "abbreviatedOid": "0104885"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't see any blockers on this.",
          "createdAt": "2020-01-24T21:51:12Z",
          "updatedAt": "2020-01-24T21:51:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzI3MzEx",
          "commit": {
            "abbreviatedOid": "0104885"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-25T14:01:18Z",
          "updatedAt": "2020-01-25T14:01:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3NzkyNDg0",
      "title": "Adding a link to a Go reference implementation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/205",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a link to a Go reference implementation.",
      "createdAt": "2020-01-28T02:05:58Z",
      "updatedAt": "2020-01-28T18:46:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6ec26b0b97e760c2b8f960284d1207805c42ea1c",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "refImpl",
      "headRefOid": "0ae507f12781c5d08b927e01c274030e3a7b5fb4",
      "closedAt": "2020-01-28T18:46:36Z",
      "mergedAt": "2020-01-28T18:46:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4966eb25336a89fe1c82a3203a2eec0dd87254d3"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh does the Go implementation produce outputs that match the Sage version? ",
          "createdAt": "2020-01-28T16:40:01Z",
          "updatedAt": "2020-01-28T16:40:01Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the files in `testdata` folder are json files produced by Sage and consumed by Go tests. ",
          "createdAt": "2020-01-28T18:36:26Z",
          "updatedAt": "2020-01-28T18:36:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes, the files in testdata folder are json files produced by Sage and consumed by Go tests.\r\n\r\nSweet!",
          "createdAt": "2020-01-28T18:39:34Z",
          "updatedAt": "2020-01-28T18:39:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NjEwODM5",
          "commit": {
            "abbreviatedOid": "f8caad8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-28T18:40:19Z",
          "updatedAt": "2020-01-28T18:40:25Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nThese implementations are for reference only. They MUST NOT be used in production systems.\r\n```",
              "createdAt": "2020-01-28T18:40:20Z",
              "updatedAt": "2020-01-28T18:45:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1Nzc0MjE5",
      "title": "Fix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/208",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-16T01:10:21Z",
      "updatedAt": "2022-02-18T16:42:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6893c4d1b38627ebf98a2443333566c071294f36",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fix",
      "headRefOid": "4966eb25336a89fe1c82a3203a2eec0dd87254d3",
      "closedAt": "2020-02-16T01:10:34Z",
      "mergedAt": "2020-02-16T01:10:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fe5e81ca440530467743a27a8d19ac67e906cf97"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1Nzc0ODky",
      "title": "Fix bug in appendix D.1.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/209",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #201.",
      "createdAt": "2020-02-16T01:19:26Z",
      "updatedAt": "2022-02-18T16:42:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fe5e81ca440530467743a27a8d19ac67e906cf97",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/appendix-tidy",
      "headRefOid": "dcbb49625d9a6d438c695ea3c8a53d5691f8cf0a",
      "closedAt": "2020-02-16T19:27:50Z",
      "mergedAt": "2020-02-16T19:27:50Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "efd1b186af6fe8ca2b75058bf6ae8e1c6bbaa6a9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NDIzNjE4",
          "commit": {
            "abbreviatedOid": "dcbb496"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-16T19:27:37Z",
          "updatedAt": "2020-02-16T19:27:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzAwMDY4",
      "title": "poc/sswu_*.sage: use sgn0_be with bls12381, as specified.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/211",
      "state": "CLOSED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "BLS12-381 suites are specified to use big-endian variant of sgn0, while sswu_*.sage scripts default to little-endian one in all cases. This pull request should probably be viewed rather as \"here is a problem\" than \"this is how to fix it,\" as there might be better way to achieve the goal. Cheers.\r\n",
      "createdAt": "2020-02-19T17:45:01Z",
      "updatedAt": "2020-02-28T09:56:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "efd1b186af6fe8ca2b75058bf6ae8e1c6bbaa6a9",
      "headRepository": "dot-asm/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "f8896705068cb1033ad50ee98dd767cca4c0eaae",
      "closedAt": "2020-02-28T09:56:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll follow up asap.",
          "createdAt": "2020-02-24T06:10:38Z",
          "updatedAt": "2020-02-24T06:10:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, looking into this more:\r\n\r\nThe suite definitions don't have any issues with this, because suites set the appropriate sgn0 variant as part of the suite definition (see h2c_suite.sage line 31).\r\n\r\nSo it looks to me like the only place that this could arguably be an issue is in the BLS12-381-isogenous curve in sswu_opt.sage. (To me, that doesn't matter much---it's a simple functionality test, not a suite definition---but I'm happy to fix it.)\r\n\r\nI'll take care of this when editing suites for #212.",
          "createdAt": "2020-02-24T23:42:00Z",
          "updatedAt": "2020-02-24T23:42:00Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (To me, that doesn't matter much---it's a simple functionality test, not a suite definition---\r\n\r\nWhile the test passes in so to say loopback mode, i.e. when both optimized and generic implementations use same variant of sgn0, I'd still argue that it's not insignificant difference. If an implementation fails to process test vector and you have to dig into it, rigid compliance with specification even at this level helps.\r\n\r\n> but I'm happy to fix it.)\r\n\r\nCool! Thanks!\r\n",
          "createdAt": "2020-02-28T09:56:50Z",
          "updatedAt": "2020-02-28T09:56:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODI1MjQ3",
      "title": "new hash_to_field definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR redefines hash_to_field in the way discussed in #202.\r\n\r\nNow ready for review, I believe.\r\n\r\nTodo:\r\n\r\n- [x] rename to hash_to_field\r\n- [x] write new definitions and security considerations\r\n- [x] update Security Considerations section\r\n- [x] update Roadmap section\r\n- [x] update Suites section\r\n- ~update implementations~  we can do this in a separate PR (or I'm happy to do it here... what do we think?)\r\n\r\n@armfazh @chris-wood @JustinDrake I'd appreciate comments on the WIP version. I'm sure I've left typos, things aren't super clear yet, etc.!",
      "createdAt": "2020-02-24T06:08:08Z",
      "updatedAt": "2020-02-28T22:46:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "2500e6c42c16ae719c92c4f60aac4b003662c24f",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "new-hash_to_field",
      "headRefOid": "821b9072e997f48543d7ffef171052e4d34e4187",
      "closedAt": "2020-02-28T22:45:15Z",
      "mergedAt": "2020-02-28T22:45:15Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "2b2ea54698b23aa9316b857f110c360ca6388d94"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood, @armfazh should we wait to update code until after we land #196?\r\n\r\n(I know that I need to review that code! Sorry!!! I will do it next...)",
          "createdAt": "2020-02-25T00:37:42Z",
          "updatedAt": "2020-02-25T00:37:50Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood, @armfazh should we wait to update code until after we land #196?\r\n\r\nWhat about merging 196 (modulo Riad's review). \r\nOnce this PR (212) be reviewed and approved, we can generate a new pr addressing only the new hash_to_field function. \r\n",
          "createdAt": "2020-02-25T01:22:14Z",
          "updatedAt": "2020-02-25T01:22:14Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I added `k`, the target security level, to the suite definition. It's needed in the definition of `expand_message_md`, so we need to specify it for compatibility.",
          "createdAt": "2020-02-25T06:52:50Z",
          "updatedAt": "2020-02-25T06:52:50Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "You have said that power analysis attacks are not in scope for this document (https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-581644873); you should note something about that in the security considerations.",
          "createdAt": "2020-02-25T14:57:12Z",
          "updatedAt": "2020-02-25T14:57:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've got updated code [ready to go](/kwantam/draft-irtf-cfrg-hash-to-curve/tree/new-h2f-code).\r\n\r\nShould I just add those commits to this PR, or should we handle them separately? @armfazh @chris-wood ",
          "createdAt": "2020-02-27T07:10:23Z",
          "updatedAt": "2020-02-27T07:10:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should I just add those commits to this PR, or should we handle them separately? @armfazh @chris-wood\r\n\r\nSeparately is fine by me!",
          "createdAt": "2020-02-27T13:13:53Z",
          "updatedAt": "2020-02-27T13:13:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What is the consensus about using octet rather than byte?\r\n\r\nI prefer byte. @kwantam?",
          "createdAt": "2020-02-27T23:06:26Z",
          "updatedAt": "2020-02-27T23:06:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I prefer byte. @kwantam?\r\n\r\nI think \"octet\" is a little awkward and annoying, but is more precise than \"byte\" (in the sense that octet is exactly 8 bits, but byte isn't necessarily).\r\n\r\nIn practice this probably mattered a lot more when RFC793 was written than it does now, so I'm fine switching everything to bytes and just noting somewhere that we assume bytes are 8 bits.",
          "createdAt": "2020-02-28T00:07:45Z",
          "updatedAt": "2020-02-28T00:07:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ach, there's one more issue I need to think about before we merge @chris-wood @armfazh\r\n\r\nWe want to use *a prefix-free encoding* of DST in both of the expand_message variants. This is easy: just prepend DST with its length. But I want to make sure the text reflects this throughout. ~So can we hold off until later today when I push an edit?~\r\n\r\n--\r\n\r\nDone now. By the way, I didn't give a good justification for this above, but the reason is that otherwise we don't meet our own requirement that all distinct (msg, DST, length_in_bytes) triplets give distinct outputs. Specifically, without a prefix-free DST encoding, it's possible to \"trade\" bytes between msg and DST to get two triplets that give the same output.",
          "createdAt": "2020-02-28T17:41:47Z",
          "updatedAt": "2020-02-28T18:35:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjg0MzM3",
          "commit": {
            "abbreviatedOid": "d66c81e"
          },
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T10:20:40Z",
          "updatedAt": "2020-02-24T10:28:42Z",
          "comments": [
            {
              "originalPosition": 441,
              "body": "The slicing notation `[0 : len_in_octets]` is straightforward with Python experience but isn't the length of the constructed `pseudo_random_octets` implied by construction of `ell = ceil((len_in_octets - k_in_octets) / b_in_octets)`?",
              "createdAt": "2020-02-24T10:20:41Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 547,
              "body": "There is no HKDF-Expand anymore",
              "createdAt": "2020-02-24T10:24:10Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 584,
              "body": "Change to `h2f/kmac128` and `SHA3:h2f/kmac128`",
              "createdAt": "2020-02-24T10:26:15Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDIwNTgz",
          "commit": {
            "abbreviatedOid": "d66c81e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks great! I quite like the new modularity, especially as it lets us more easily test things. (We can have different test vectors for hash_to_field and expand_message_md et al.)",
          "createdAt": "2020-02-24T14:19:13Z",
          "updatedAt": "2020-02-24T15:12:18Z",
          "comments": [
            {
              "originalPosition": 344,
              "body": "```suggestion\r\n2. pseudo_random_octets = expand_message(msg, DST, pro_length)\r\n```\r\n\r\nor the other way around!",
              "createdAt": "2020-02-24T14:19:13Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 343,
              "body": "nit: I might rename this to `expand_length`",
              "createdAt": "2020-02-24T14:20:11Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 379,
              "body": "Should we elaborate on why this is indifferentiable from a RO? Perhaps we can cite [1] and note that we encode the input `msg` in a prefix-free manner (by prepending the length and DST)? (And whatever else is needed?)\r\n\r\n[1] https://cs.nyu.edu/~dodis/ps/merkle.pdf",
              "createdAt": "2020-02-24T15:11:19Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzEwNDc1",
          "commit": {
            "abbreviatedOid": "d66c81e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T21:23:30Z",
          "updatedAt": "2020-02-24T21:23:30Z",
          "comments": [
            {
              "originalPosition": 441,
              "body": "Whoops, this comment made me realize there's a typo in the definition of `ell`---should be `len_in_octets + k_in_octets` (not subtraction). Thanks!!!\r\n\r\n---\r\n\r\nHowever:\r\n\r\n`ell` is the number of blocks that it takes to generate *at least* `len_in_octets + k_in_octets` bytes, but it can be that it gives slightly more than the necessary number of bytes (because we have to round up to a whole number of blocks).\r\n\r\nFor example, imagine `len_in_octets` = 128, `k_in_octets` = 16, and `b_in_octets` = 32. (This would be the case when hashing to two elements of the BLS12-381 G1 group using SHA-256.)\r\n\r\n    ell = ceil((len_in_octets + k_in_octets) / b_in_octets) = ceil(144 / 4) = 5\r\n\r\nThe length of `b_0_chopped` is `b_in_octets - k_in_octets` = 16, and the length of b_1 through b_4 are each 32, so in total `pseudo_random_bytes` is 144 bytes in length. We only need to return 128 bytes.",
              "createdAt": "2020-02-24T21:23:30Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzE2MTAx",
          "commit": {
            "abbreviatedOid": "3a69e3b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T21:32:30Z",
          "updatedAt": "2020-02-24T21:32:30Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "How about `len_in_octets` to match the `expand_message` prototype?",
              "createdAt": "2020-02-24T21:32:30Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzUwNDM4",
          "commit": {
            "abbreviatedOid": "2790581"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T22:34:10Z",
          "updatedAt": "2020-02-24T22:34:10Z",
          "comments": [
            {
              "originalPosition": 379,
              "body": "OK, I've added discussion on this in Security Considerations.\r\n\r\n(Does that seem like the right spot for it?)",
              "createdAt": "2020-02-24T22:34:10Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzUxMzg3",
          "commit": {
            "abbreviatedOid": "2790581"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T22:36:08Z",
          "updatedAt": "2020-02-24T22:36:09Z",
          "comments": [
            {
              "originalPosition": 379,
              "body": "Yep! I'll take a look. ",
              "createdAt": "2020-02-24T22:36:09Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzgwMzkx",
          "commit": {
            "abbreviatedOid": "3eca2aa"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T23:43:43Z",
          "updatedAt": "2020-02-24T23:43:43Z",
          "comments": [
            {
              "originalPosition": 584,
              "body": "this is now gone because of edits to the Suites section.",
              "createdAt": "2020-02-24T23:43:43Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Njc1MDAw",
          "commit": {
            "abbreviatedOid": "f19ef32"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest changes LGTM!",
          "createdAt": "2020-02-27T13:24:03Z",
          "updatedAt": "2020-02-27T13:24:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1ODQyMDQx",
          "commit": {
            "abbreviatedOid": "f19ef32"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks good, I just left few comments.\r\nWhat is the consensus about using octet rather than byte?",
          "createdAt": "2020-02-27T17:11:57Z",
          "updatedAt": "2020-02-27T18:57:42Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "```suggestion\r\nbyte-string and produces as output a point on an elliptic curve.\r\n```",
              "createdAt": "2020-02-27T17:11:58Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 166,
              "body": "idem",
              "createdAt": "2020-02-27T17:12:18Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 340,
              "body": "```suggestion\r\nFor example, for a 255-bit prime p and k = 128-bit security level,\r\n```",
              "createdAt": "2020-02-27T17:43:12Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 336,
              "body": "```suggestion\r\nis appropriate for targeting k-bit security level.\r\n```",
              "createdAt": "2020-02-27T17:44:05Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 428,
              "body": "To match with line 1614, the i-loop must start in 1.",
              "createdAt": "2020-02-27T17:52:55Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 475,
              "body": "```suggestion\r\nAs an example, for 128-bit security level, b >= 256 bits and either SHA-256 or\r\n```",
              "createdAt": "2020-02-27T17:57:49Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1086,
              "body": "```suggestion\r\n- E' is not required for this suite\r\n- iso\\_map is not required for this suite\r\n```",
              "createdAt": "2020-02-27T18:27:28Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1146,
              "body": "idem",
              "createdAt": "2020-02-27T18:28:59Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1216,
              "body": "I think this is not needed, since a hash function cannot be used as an extendable output function and vice versa (unless there is an special case).\r\nSo, specifying the `expand_message` variant must be done inside the suite parameters, but not in the suiteID.",
              "createdAt": "2020-02-27T18:34:15Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1225,
              "body": "I suggest we can change the main separator character, thus hyphen will be available in names.",
              "createdAt": "2020-02-27T18:35:37Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1251,
              "body": "I consider we must fix the suiteID name. I am still not convinced on using versions. what is the value added to have  suites XYZv01 and XYZv02?  \r\n\r\nIf some information is really needed to append in the suiteID, then it should be after the last separator. \r\nex: `P256-SHA256-SSWU-RO-<here>` ",
              "createdAt": "2020-02-27T18:41:36Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 416,
              "body": "`str[ a : b ]` means the bytes from str[a] to str[b] both included and `b>=a`? ",
              "createdAt": "2020-02-27T18:52:13Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 513,
              "body": "Q: what is the maximum length of input the messages? ",
              "createdAt": "2020-02-27T18:54:51Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 345,
              "body": "somebody ask me whether these methods can be used for small characteristic field. Ex. binary or ternary field extensions.?\r\nObviously we are not covering binary or ternary curves.",
              "createdAt": "2020-02-27T18:56:38Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTE4OTU5",
          "commit": {
            "abbreviatedOid": "f19ef32"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-27T19:01:13Z",
          "updatedAt": "2020-02-27T19:01:14Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "`it first expand the input` \r\nthe first time I read this sentence, it gives me the idea that if I have a large message to be hashed, then the hash_to_base function will expand to a bigger string. \r\nActually, what happens is the opposite, the input message is hashed to produce a pseudo-random string. \r\nMaybe we can rephrase this sentence.",
              "createdAt": "2020-02-27T19:01:14Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE3NjI5",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:51:42Z",
          "updatedAt": "2020-02-28T01:51:42Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "resolved by latest commit",
              "createdAt": "2020-02-28T01:51:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE3Njgy",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:51:53Z",
          "updatedAt": "2020-02-28T01:51:54Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "resolved by latest commit",
              "createdAt": "2020-02-28T01:51:54Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE4MzI2",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:54:15Z",
          "updatedAt": "2020-02-28T01:54:16Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "```suggestion\r\nis appropriate when targeting k-bit security.\r\n```",
              "createdAt": "2020-02-28T01:54:16Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE4NjQ0",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:55:28Z",
          "updatedAt": "2020-02-28T01:55:28Z",
          "comments": [
            {
              "originalPosition": 345,
              "body": "Hmmm, this is a great question. I guess it probably works, but I'd bet there are more efficient ways...",
              "createdAt": "2020-02-28T01:55:28Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5MjMy",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:57:37Z",
          "updatedAt": "2020-02-28T01:57:38Z",
          "comments": [
            {
              "originalPosition": 340,
              "body": "```suggestion\r\nFor example, for a 255-bit prime p, and k = 128-bit security,\r\n```",
              "createdAt": "2020-02-28T01:57:37Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5MzUw",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:58:07Z",
          "updatedAt": "2020-02-28T01:58:07Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "```suggestion\r\n- (u_0, ..., u_(count - 1)), a list of field elements.\r\n```",
              "createdAt": "2020-02-28T01:58:07Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5NDY1",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:58:35Z",
          "updatedAt": "2020-02-28T01:58:36Z",
          "comments": [
            {
              "originalPosition": 428,
              "body": "Great catch! Since the loop indices are used to compute elm_offset, it works slightly better to start at  0. I've fixed line 1614.",
              "createdAt": "2020-02-28T01:58:35Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5Nzc3",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:59:43Z",
          "updatedAt": "2020-02-28T01:59:44Z",
          "comments": [
            {
              "originalPosition": 475,
              "body": "```suggestion\r\nAs an example, for the 128-bit security level, b >= 256 bits and either SHA-256 or\r\n```",
              "createdAt": "2020-02-28T01:59:43Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTIyNTQy",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:10:00Z",
          "updatedAt": "2020-02-28T02:10:01Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "ell implies a maximum length of the output, namely, `256 * b_in_bytes - k_in_bytes`. For 256-bit hashes at 128-bit security this is 8176 bytes.\r\n\r\nFor comparison, the pairing-friendly curves draft defines BLS48-581. When hashing to G2, we need an element of F_(p^8) for p a 581-bit integer at the 256-bit security level. So L = 105 bytes, and hashing to two elements of F_(p^8) requires `len_in_bytes = 2 * 8 * 105 = 1680` + `k_in_bytes = 32`, so ell = 54 in this case if we used SHA-256.\r\n\r\n(But note that one would have to use SHA-512, not SHA-256, so ell = 54 is pessimistic.)",
              "createdAt": "2020-02-28T02:10:01Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI0ODUz",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:18:37Z",
          "updatedAt": "2020-02-28T02:18:38Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "The reason I was thinking to have EXP_TAG is that if someone introduces a new expand_message variant in the future, this keeps things unambiguous. I suppose it's true that we could just require them to tag their nonstandard variant, though. I'm pretty neutral on this. @chris-wood, thoughts?",
              "createdAt": "2020-02-28T02:18:37Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI1MTc3",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:19:48Z",
          "updatedAt": "2020-02-28T02:19:48Z",
          "comments": [
            {
              "originalPosition": 1225,
              "body": "This is a good point. Can we hash it out in a different issue? It's easy to fix once we've decided.",
              "createdAt": "2020-02-28T02:19:48Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI2NDQx",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:24:34Z",
          "updatedAt": "2020-02-28T02:24:34Z",
          "comments": [
            {
              "originalPosition": 1225,
              "body": "Created a new issue: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/213",
              "createdAt": "2020-02-28T02:24:34Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI3OTc0",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:30:20Z",
          "updatedAt": "2020-02-28T02:30:21Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "The reason that we require the trailing separator is to ensure that suite IDs are prefix-free.\r\n\r\nI wanted to have an \"optional\" field that people could use to put extra stuff when defining a new suite-ID, and I explicitly described it this way because I wanted to make sure that people *did not* add anything after the trailing separator. (I think I should make this more explicit, though.)\r\n\r\nSo I think there are three options:\r\n\r\n1. leave \"optional\" field as described here, or\r\n2. add an extra blank field, or\r\n3. don't describe any optional field at all (in which case I worry that people will get it wrong)",
              "createdAt": "2020-02-28T02:30:21Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI4MzQ3",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:31:42Z",
          "updatedAt": "2020-02-28T02:31:43Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "Thinking about it a little more, I think I do slightly prefer having an explicit tag. But only slightly...",
              "createdAt": "2020-02-28T02:31:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI4NjY0",
          "commit": {
            "abbreviatedOid": "3c283f1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:33:01Z",
          "updatedAt": "2020-02-28T02:33:01Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "It's exclusive. from str[a] to str[b] inclusive is (b - a + 1) characters.",
              "createdAt": "2020-02-28T02:33:01Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI5Mjcx",
          "commit": {
            "abbreviatedOid": "1861c34"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:35:12Z",
          "updatedAt": "2020-02-28T02:35:12Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "@chris-wood ? ",
              "createdAt": "2020-02-28T02:35:12Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI5OTEz",
          "commit": {
            "abbreviatedOid": "83532af"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:37:42Z",
          "updatedAt": "2020-02-28T02:37:42Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "To be clearer, it includes str[a] but excludes str[b].",
              "createdAt": "2020-02-28T02:37:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTMwOTAw",
          "commit": {
            "abbreviatedOid": "7530181"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:41:19Z",
          "updatedAt": "2020-02-28T02:41:19Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "I clarified slightly.",
              "createdAt": "2020-02-28T02:41:19Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTUwNzIz",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T04:07:58Z",
          "updatedAt": "2020-02-28T04:07:58Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "I too think being explicit is better, as it doesn't rely on properties of the expansion function for separation. (@armfazh how would you imagine someone define `HASH_ID` if, say, they introduced an expansion variant such as `expand_message_md_like`?)",
              "createdAt": "2020-02-28T04:07:58Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTUxNTc3",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T04:12:02Z",
          "updatedAt": "2020-02-28T04:12:02Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "Interesting! I was fine with this text, but on reflection, I'm now leaning towards (a) fixing RO/NU and then (b) adding an extra blank field (with text clarifying its role). \r\n",
              "createdAt": "2020-02-28T04:12:02Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTcxMTUz",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T05:43:49Z",
          "updatedAt": "2020-02-28T05:43:49Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "I agree with you that the cleanest approach seems to be adding an extra field for user-defined info, like\r\n\r\n    CURVE_ID || \"-\" || HASH_ID || \"-\" || MAP_ID || \"-\" || ENC_VAR || \"-\" || USER_INFO || \"-\"\r\n\r\nThe only thing that's slightly unfortunate about this is that it means *all* suite names get longer (well, by one character) in order to make sure that user-defined fields don't break prefix-freeness. So, e.g., we will have to change the suite name to\r\n\r\n    P256-XMD:SHA.256-SSWU-RO--\r\n\r\n(note: *two* trailing hyphens)\r\n\r\nThe current version, where we let the user-defined fields live in ENC_VAR, is slightly uglier in principle, but in practice it makes the expected case (no user-defined fields) prettier.\r\n\r\nI think I favor optimizing for the expected case and letting the user-defined fields be slightly uglier. For all we no, no one will ever use them... and at least they pay their own cost rather than imposing it on everyone else.\r\n\r\n(But again, not to be dramatic... that \"cost\" is just one extra hyphen, after all...)",
              "createdAt": "2020-02-28T05:43:49Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTE5Mzgw",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T16:20:59Z",
          "updatedAt": "2020-02-28T16:21:00Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "I think we need a tie breaker! @armfazh? ",
              "createdAt": "2020-02-28T16:20:59Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTU2Mjc2",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:15:42Z",
          "updatedAt": "2020-02-28T17:15:42Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": ":)\r\n\r\nIt occurs to me: since this is orthogonal to this PR (this text has been in the document for a while), maybe we can discuss in #213 along with the other Suite-ID--related change?",
              "createdAt": "2020-02-28T17:15:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTYwMzg2",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:22:45Z",
          "updatedAt": "2020-02-28T17:22:46Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "I've added a comment on that issue. Can we move the discussion there so we can discuss in parallel with getting the code updated, etc?",
              "createdAt": "2020-02-28T17:22:46Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjIyMDE1",
          "commit": {
            "abbreviatedOid": "821b907"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-28T19:09:21Z",
          "updatedAt": "2020-02-28T19:09:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjY0ODg1",
          "commit": {
            "abbreviatedOid": "821b907"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T20:26:24Z",
          "updatedAt": "2020-02-28T20:26:24Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "\r\nI am ok on having two separators at the end, if no user info is added \r\nP256-XMD:SHA.256-SSWU-RO--\r\n\r\nhowever, one suggestion is to put algorithm variants between parenthesis, so, we ensure the last character is always ')' even if user input is omitted.\r\n\r\n(Let's move this thread to 213)",
              "createdAt": "2020-02-28T20:26:24Z",
              "updatedAt": "2020-02-28T20:26:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Njk2MzI0",
          "commit": {
            "abbreviatedOid": "821b907"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T21:28:40Z",
          "updatedAt": "2020-02-28T21:28:41Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "OK, since we now have a suite-ID issue, I'm going to assume that if we end up making a change to this we can do it there, too. I've added a link.",
              "createdAt": "2020-02-28T21:28:40Z",
              "updatedAt": "2020-02-28T21:28:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNjM2MzIw",
      "title": "new hash_to_field code / expand_message_md revisited",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/214",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the code in `poc/` to use the new hash_to_field function from #212.\r\n\r\nI have not yet regenerated the test vectors. Shall I do that?",
      "createdAt": "2020-02-28T23:00:56Z",
      "updatedAt": "2020-03-06T17:19:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "72136122bbecbe7ecaa438e94434aa57835a1588",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "new-h2f-code",
      "headRefOid": "c059d1db957d2de4f75b61862af129bf8c177e2d",
      "closedAt": "2020-03-05T18:46:05Z",
      "mergedAt": "2020-03-05T18:46:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "54818b0eb786b5c81f1258cee3d6c3bcd9e59833"
      },
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Is pairing-plus or whatever up to date?",
          "createdAt": "2020-02-29T07:47:48Z",
          "updatedAt": "2020-02-29T07:47:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is pairing-plus or whatever up to date?\r\n\r\nNot yet, that's next on my list.",
          "createdAt": "2020-02-29T08:41:45Z",
          "updatedAt": "2020-02-29T08:41:45Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New test vectors would be very helpful",
          "createdAt": "2020-03-01T10:49:51Z",
          "updatedAt": "2020-03-01T10:49:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Using this new method for obtaining field elements, does it still preserves the guarantees required by the random oracle construction?\r\nPreviously, `u0` and `u1` were obtained from different RO instantiations, by means of appending an extra bit.\r\n`u0 = H (M || 0) and u1 = H (M || 1)`\r\nNow, it seems to me that we are querying the same RO for obtaining `u0` and `u1`.\r\n\r\n",
          "createdAt": "2020-03-02T19:40:19Z",
          "updatedAt": "2020-03-02T19:40:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using this new method for obtaining field elements, does it still preserves the guarantees required by the random oracle construction?\r\n\r\nYes.\r\n\r\nThere are two ways to argue this. One is to recall that the underlying RO-to-curve construction is really defined in terms of independent elements of F. Using two hash functions H0 and H1 that are modeled as independent random oracles satisfies this requirement, but it's not the only way to satisfy it---hash_to_field (with `count=2`) also gives two independent elements of F.\r\n\r\nThe other slightly less direct way is to observe that the output of expand_message inside of hash-to-field gives `2 * m * L` bytes that are uniformly distributed, and therefore we can define two independent random oracles in terms expand_message, just by splitting its output into two non-overlapping chunks of `m * L` bytes. This is precisely what happens inside of hash-to-field, so we can understand that function as essentially returning the evaluations of H0 and H1.\r\n\r\n(These are equivalent views of the world.)",
          "createdAt": "2020-03-02T21:06:11Z",
          "updatedAt": "2020-03-02T21:07:27Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's assume `H(m,2)` and that exactly `b0` and `b1` match the sizes of certain prime field. Then, `u0 = b0 mod p`, and `u1 = b1 mod p`.\r\nMy concern is that `b1` depends only on `b0`, since `b1` was calculated as the hash of `b0` (plus some prefix).\r\nSo, take a message `m` and calculate `b0`. At this point, `b1` is completely determined by `b0`, but not by other call to a RO using the original message. (in some sense `b0` fixes the output of `b1`).\r\nI am probably missing something. thoughts?\r\n",
          "createdAt": "2020-03-02T22:34:25Z",
          "updatedAt": "2020-03-02T22:34:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I see what you're saying.\r\n\r\nThe scenario you describe doesn't quite work because `b0` isn't output, only `b0_chopped`. But I think the idea is correct: consder the case where `b0_chopped || b1` is the 1st element and a substring of `b2 || b3` is the second element. Then b2 and b3 are fully determined by b1, and the adversary sees all of b1, so we still have the issue.\r\n\r\nI went back and looked at CDMP08, and now I see where the issue is coming from. Section 5 talks about building longer outputs by computing H(X || 1), H(X || 2), etc. The important thing here is that there's *no chaining* of output blocks in that construction. And as you say, using chaining on values that the attacker knows makes it possible to distinguish.\r\n\r\n(In contrast, HKDF *does* use chaining, but always combines the chained value with a secret value that the attacker never learns, namely, PRK.)\r\n\r\nI think the fix is straightforward (don't chain, just hash b0 over and over), but I'm going to think carefully about it and push some new text / code.\r\n\r\nThank you!!!",
          "createdAt": "2020-03-02T23:13:53Z",
          "updatedAt": "2020-03-02T23:14:37Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> The scenario you describe doesn't quite work because `b0` isn't output, only `b0_chopped`. But I think the idea is correct: consder the case where `b0_chopped || b1` is the 1st element and a substring of `b2 || b3` is the second element. Then b2 and b3 are fully determined by b1, and the adversary sees all of b1, so we still have the issue.\r\n\r\nThis is exactly the scenario I had in mind, but I simplified to b0 and b1.\r\n\r\n \r\n> I went back and looked at CDMP08, and now I see where the issue is coming from. Section 5 talks about building longer outputs by computing H(X || 1), H(X || 2), etc. The important thing here is that there's _no chaining_ of output blocks in that construction. And as you say, using chaining on values that the attacker knows makes it possible to distinguish.\r\n\r\n \r\n> (In contrast, HKDF _does_ use chaining, but always combines the chained value with a secret value that the attacker never learns, namely, PRK.)\r\n\r\nExactly, another approach is to generate `n` values of `msg_prime`, one per field element requested.\r\n",
          "createdAt": "2020-03-02T23:21:07Z",
          "updatedAt": "2020-03-02T23:21:07Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, consider the following:\r\n\r\n~~~\r\nSteps:\r\n1. ell = ceil((len_in_bytes + k_in_bytes) / b_in_bytes)\r\n2. ABORT if ell > 256\r\n3. DST_prime = I2OSP(len(DST), 1) || DST\r\n4. b_0 = H(DST_prime || I2OSP(0, 1) || I2OSP(len_in_bytes, 2) || msg)\r\n5. for i in (1, ..., ell - 1):\r\n6.   b_i = H(DST_prime || I2OSP(i, 1) || b_0)                   #### change is here\r\n7. b_0_chopped = b_0[0 : (b_in_bytes - k_in_bytes)]\r\n8. pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n9. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\nThis avoids the chaining issue, because the attacker never sees `b_0`.\r\n\r\nIf we were extremely paranoid, we might not even output `b_0_chopped`. This would mean that the minimum number of hash invocations is 2 instead of 1, which will likely make some people unhappy. But that seems unnecessary, by the security argument for chopMD. Informally, an attacker who doesn't know b_0 cannot compute any more blocks, and here the attacker would have to guess k bits of b_0 in order to reconstruct.\r\n\r\nSo I guess I'm slightly in favor of outputting b_0_chopped, but I can be convinced otherwise. Thoughts @armfazh?\r\n\r\n---\r\n\r\nOne issue with the above that makes me quite nervous is that now only 1 byte (really, in the worst case, only 1 bit!!!) of the input of H is changing for each b_i. This is quite aggressive.\r\n\r\nA slightly better solution would be to do something like\r\n\r\n    b_i = H(DST_prime || I2OSP(i, 1) || b_0 || b_(i-1))\r\n\r\nThe big downside of this is that it significantly increases the number of hash invocations. We could get around that with something like:\r\n\r\n    b_i = H(DST_prime || I2OSP(i, 1) || b_0 ^ b_(i - 1))\r\n\r\nwhere `^` is bitwise XOR. This would require a special case for b_1, obviously!",
          "createdAt": "2020-03-02T23:36:12Z",
          "updatedAt": "2020-03-02T23:43:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "A third approach is to chain, but chop the output of every hash function, not just the first one. (The last block does not need to be chopped in this case.)\r\n\r\nLet's think about the cost of all three approaches. For all three approaches, we have\r\n\r\n    b_0 = H(DST || I2OSP(i, 0) || I2OSP(len_in_bytes, 2) || msg)\r\n\r\nFor subsequent blocks,\r\n\r\n- type1 is `b_i = H(DST || I2OSP(i, 1) || b_0 || b_(i-1))`\r\n- type 2 is `b_i = H(DST || I2OSP(i, 1) || b_0 ^ b_(i-1))`\r\n- type 3 is `b_i = H(DST || I2OSP(i, 1) || b_(i-1))` where all b_i are chopped by k bits before being output, except `b_(ell - 1)`.\r\n- type 4 is type 1, but `b_0` is not output\r\n- type 5 is type 2, but `b_0` is not output\r\n- type 6 is type 3, but `b_0` is not output\r\n\r\nType 6 doesn't really make any sense, but I've included it for completeness.\r\n\r\nLet's look first at output rates for different cases:\r\n\r\n| case | first block | middle blocks | last block |\r\n|---|---|---|---|\r\n| SHA-256, k = 128, type 1 or 2 | 16 bytes | 32 bytes | 32 bytes |\r\n| SHA-256, k = 128, type 3 | 16 bytes | 16 bytes | 32 bytes |\r\n| SHA-512, k = 128, type 1 or 2 | 48 bytes | 64 bytes | 64 bytes |\r\n| SHA-512, k = 128, type 3 | 48 bytes | 48 bytes | 64 bytes |\r\n| SHA-512, k = 256, type 1 or 2 | 32 bytes | 64 bytes | 64 bytes |\r\n| SHA-512, k = 256, type 3 | 32 bytes | 32 bytes | 64 bytes |\r\n\r\nTypes 4, 5, and 6 correspond to types 1, 2, and 3 (respectively), except that the \"first block\" column is always 0 (because `b_0` is never output).\r\n\r\nNow, let's look at number of compression function invocations. Assume that the input message is 32 bytes and DST is 16 bytes; this is roughly worst case (because long messages will dominate hashing cost).\r\n\r\n| case | first block | subsequent blocks |\r\n|---|---|---|\r\n| type 1 | 1 | 2 |\r\n| type 2 | 1 | 1 |\r\n| type 3 | 1 | 1 |\r\n\r\nClosed-form expressions for ell and number of invocations. Below, `ell` is the number of blocks that contribute to the output. For types 4, 5, and 6, one must first compute `b_0` and then hash `ell` blocks.\r\n\r\n- type 1:\r\n    - ell = `ceil((len_in_bytes + k_in_bytes) / b_in_bytes)`\r\n    - invocations: `1 + 2 * (ell - 1)`\r\n- type 2:\r\n    - ell = `ceil((len_in_bytes + k_in_bytes) / b_in_bytes)`\r\n    - invocations: `ell`\r\n- type 3:\r\n    - ell = `1 + ceil((len_in_bytes - b_in_bytes) / (b_in_bytes - k_in_bytes))`\r\n    - invocations: `ell`\r\n- type 4:\r\n    - ell = `ceil(len_in_bytes / b_in_bytes)`\r\n    - invocations: `1 + 2 * ell`\r\n- type 5:\r\n    - ell = `ceil(len_in_bytes / b_in_bytes)`\r\n    - invocations: `1 + ell`\r\n- type 6:\r\n    - ell = `1 + ceil((len_in_bytes - b_in_bytes) / (b_in_bytes - k_in_bytes))`\r\n    - invocations: `1 + ell`\r\n\r\nUsing the above, let's consider the cost of different scenarios:\r\n\r\n1. k = 128, p = 256 bits, m = 1 (like Curve25519)\r\n    a. count = 1 (len_in_bytes = 48), SHA-256\r\n    b. as above, SHA-512\r\n    c. count = 2 (len_in_bytes = 96), SHA-256\r\n    d. as above, SHA-512\r\n\r\n2. k = 128, p = 381 bits, m = 2 (like BLS12-381 G2)\r\n    a. count = 1 (len_in_bytes = 128), SHA-256\r\n    b. as above, SHA-512\r\n    c. count = 2 (len_in_bytes = 256), SHA-256\r\n    d. as above, SHA-512\r\n\r\n3. k = 256, p = 521 bits, m = 1 (like P521)\r\n    a. count = 1 (len_in_bytes = 98), SHA-512\r\n    b. count = 2 (len_in_bytes = 196), SHA-512\r\n\r\n4. k = 256, p = 581 bits, m = 8 (like BLS48-581 G2)\r\n    a. count = 1 (len_in_bytes = 840), SHA-512\r\n    b. count = 2 (len_in_bytes = 1680), SHA-512\r\n\r\n| Case | type 1 | 4 | type 2 | 5 | type 3 | 6 |\r\n|------|-------:|:--|-------:|:--|-------:|:--|\r\n| 1a | 3 | 5 | 2 | 3 | 2 | 3 |\r\n| 1b | 1 | 3 | 1 | 2 | 1 | 2 |\r\n| 1c | 7 | 7 | 4 | 4 | 5 | 6 |\r\n| 1d | 3 | 5 | 2 | 3 | 2 | 3 |\r\n| 2a | 9 | 9 | 5 | 5 | 7 | 8 |\r\n| 2b | 5 | 5 | 3 | 3 | 3 | 4 |\r\n| 2c | 17 | 17 | 9 | 9 | 15 | 16 |\r\n| 2d | 9 | 9 | 5 | 5 | 5 | 6 |\r\n| 3a | 5 | 5 | 3 | 3 | 3 | 4 |\r\n| 3b | 7 | 9 | 4 | 5 | 6 | 7 |\r\n| 4a | 27 | 29 | 14 | 15 | 26 | 27 |\r\n| 4b | 53 | 55 | 27 | 28 | 52 | 53 |\r\n\r\nNot surprisingly, type 2 is the cheapest across the board.\r\n\r\nMaybe slightly more surprisingly, types 1 and 3 have close to the same cost, but type 3 is basically always better.\r\n\r\n---\r\n\r\n~So my take is that type 2 is the winner, assuming that folks are OK requiring bitwise XOR. Otherwise, we should go with Type 3.~\r\n\r\n**EDIT** I think the \"right\" choice is really type 5, even though it costs one extra hash invocation for very short messages and very short outputs. So that's my vote.\r\n\r\nType 2 costs fewer hashes, but I'm less certain about its security. I'm roughly as confident in type 4 as type 5, but it's much more expensive. I'm least confident about type 3. And as I said above, type 6 really doesn't make any sense...",
          "createdAt": "2020-03-03T00:44:35Z",
          "updatedAt": "2020-03-03T04:35:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to be clear, I'll write down the pseudocode for each one:\r\n\r\nAll of them start in roughly the same way:\r\n\r\n~~~\r\n1. ell = ((compute using closed form given above))\r\n2. ABORT if ell > 256\r\n3. DST_prime = I2OSP(len(DST), 1) || DST\r\n4. chopped_length = b_in_bytes - k_in_bytes\r\n5. b_0 = H(DST_prime || I2OSP(0, 1) || I2OSP(len_in_bytes, 2) || msg)\r\n~~~\r\n\r\n# Type 1\r\n\r\n~~~\r\n6.  for i in (1, ..., ell - 1):\r\n7.    b_i = H(DST_prime || I2OSP(i, 1) || b_0 || b_(i - 1))\r\n8.  b_0_chopped = b_0[0 : chopped_length]\r\n9.  pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n10. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\n# Type 2\r\n\r\n~~~\r\n5.  b_1 = H(DST_prime || I2OSP(1, 1) || b_0)\r\n6.  for i in (2, ..., ell - 1):\r\n7.    b_i = H(DST_prime || I2OSP(i, 1) || b_0 ^ b_(i - 1))\r\n8.  b_0_chopped = b_0[0 : chopped_length]\r\n9.  pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n10. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\nHere, `^` is bitwise xor (always applied to equal-length bytestrings in the above).\r\n\r\n# Type 3\r\n\r\n~~~\r\n6.  for i in (1, ..., ell - 1):\r\n7.    b_i = H(DST_prime || I2OSP(i, 1) || b_(i - 1))\r\n8.    b_(i-1)_chopped = b_(i-1)[0 : chop_length]\r\n9.  pseudo_random_bytes = b_0_chopped || b_1_chopped || ... || b_(ell - 1)\r\n10. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~",
          "createdAt": "2020-03-03T00:52:01Z",
          "updatedAt": "2020-03-03T01:31:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, it occurs to me that the construction as currently written (i.e., where `b_1` chains into `b_2`) probably *is* OK (though it probably still makes sense to try and improve it, as long as it's not too costly).\r\n\r\nThe reason is, the field elements at the output of hash-to-field do not uniquely determine the bytes at the output of expand-message. In all cases, we take (log(q) + k) bits and reduce them to log(q) bits. Hand-wavily, this means that the indifferentiability simulator has about 2^k choices it can make when mapping field elements to byte strings.\r\n\r\nThe proof is much cleaner if we can just make expand-message a random string, so probably it's best to do that. For this purpose I favor approach 2, since it adds the least overhead...",
          "createdAt": "2020-03-03T02:11:11Z",
          "updatedAt": "2020-03-03T02:11:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I revamped my [comment above](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/214#issuecomment-593707376) to include options that don't output any part of `b_0`.\r\n\r\nMy vote is to go with \"type 5.\" This is maybe slightly conservative and will make embedded folks slightly sadder. I'll update the document and code with proposed changes (we can always back them out).",
          "createdAt": "2020-03-03T04:43:14Z",
          "updatedAt": "2020-03-03T04:43:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Type 5 seems like the right compromise on balance. We maintain chaining while also mixing in `b_0` and keeping it hidden from the distinguisher, and the concatenated output is indistinguishable from a random string. And the additional XOR cost is negligible.\r\n\r\nThanks @armfazh for pointing out the issue! ",
          "createdAt": "2020-03-03T18:48:00Z",
          "updatedAt": "2020-03-03T18:49:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I talked with Dan (Boneh) about \"type 5\" today, and he had two suggestions:\r\n\r\n1. When computing `b_0 = H(DST_prime || I2OSP(0, 1) || I2OSP(ell, 2) || msg)`, there's a danger that a badly-chosen DST will cause a short `msg` to be split across the first block boundary. The reason this is bad is that the entropy of `msg` ends up broken up across two invocations of the compression function, which could end up making some attacks (think: meet-in-the-middle) easier. He suggested that we fix this is by adding extra padding before `msg` to ensure that it starts right at the first block boundary.\r\n\r\n    This is slightly unfortunate because it guarantees one extra invocation of the compression function even for short inputs. In principle we could avoid the extra compression by adding a special case for very short `DST`/`msg` combinations. But that's pretty ugly, because it requires knowing a lot about the hash function's construction (e.g., SHA-256 has a minimum of 65 bits of padding after the message, so `msg` only fits completely in the first block when len(`DST`) + len(`msg`) <= 51 bytes.\r\n\r\n2. Similarly, if `DST` is too long, then `b_0` or `b_0 XOR b_(i - 1)` might end up broken across a block boundary in the `b_i` calculations. For SHA-256, limiting `DST_prime` to 22 bytes fixes this; for SHA-512, the magic number is 46 bytes.\r\n\r\nIt occurs to me that an alternative solution to both of the above issues is to switch the order of the inputs to the hash function; this guarantees that the critical inputs are always right at the beginning. In particular,\r\n\r\n    b_0 = H(msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(strxor(b_0, b_(i - 1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThis means we're doing domain separation as a suffix rather than as a prefix of the message. Does this make life more difficult when interacting with other protocols? I'm not exactly sure, but I can't see why it should.\r\n\r\nIn fact, it arguably makes life better, because any protocol that needs to compute another value of `H(msg || ...)` can reuse an intermediate state of that computation to save time when computing prk!\r\n\r\nNote that both of the worries above apply to SHA-2; for SHA-3, we don't really need to worry about any of this.",
          "createdAt": "2020-03-04T06:47:46Z",
          "updatedAt": "2020-03-04T08:18:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Quick note: I pinged Dan about swapping the input order and he said it looked fine.",
          "createdAt": "2020-03-04T18:58:21Z",
          "updatedAt": "2020-03-04T18:58:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Arrgh. As I was writing down a proof sketch I found an issue with swapping the argument order. Fortunately, it's not hard to fix, and there's a reasonably easy way of avoiding any performance ramifications.\r\n\r\nNext, I'm going to push a commit that implements this. As always, we can revert...\r\n\r\n## Executive summary\r\n\r\nAbove I proposed computing\r\n\r\n    b_0 = H( msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime )\r\n\r\nTo make the proof go through, we should change this to\r\n\r\n    b_0 = H(I2OSP(0, input_block_size) || msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 0) || DST_prime)\r\n\r\nIn other words, we should prepend 1 (input) block of 0s to msg before hashing.  For SHA-256 this is 64 bytes, for SHA-512 it's 128 bytes. This lets us rely directly on the security proofs for NMAC given in [CDMP05](https://cs.nyu.edu/~dodis/ps/merkle.pdf), as well as other analysis like [Bel06](https://eprint.iacr.org/2006/043).\r\n\r\nIn the rest of this post I'll first discuss why we ought to do this, and then describe how implementors can avoid actually computing another hash function invocation.\r\n\r\n## Why do we need this change?\r\n\r\nPreviously we were arguing that our construction was an implementation of the NMAC construction (really, the confusingly-named HMAC^f construction; for clarity I'll just call it NMAC) in Section 3.5 of CDMP05. The basis for this claim was that the first block of each invocation of H was unique, since we had the DST and the counter in there. (We can understand Dan's suggestion (1) above, padding the first block of the b_0 computation, as strengthening this argument.)\r\n\r\nUnfortunately, if we're putting the message first, we can't directly rely on the NMAC proof: since the adversary controls the first input block to the hash function, we have no guarantee that it's unique.\r\n\r\nCDMP05 fix this problem by prepending a block of 0s to the message. This works because it prevents the adversary from controlling the contents of the first block. Using our notation, this is secure essentially because the probability is negligible that b_0 == 0 or strxor(b_0, b_(i-1)) == 0.\r\n\r\n## What is the cost?\r\n\r\nDirectly implementing this change costs an extra compression function invocation.  But in practice it's possible to avoid this, just by saving the state of the hash function after it ingests 1 block of 0s, and hashing msg starting from that state.\r\n\r\nThe storage cost to implement this optimization is minimal (less than 100 bytes for the SHA-2 family), and in practice lots of SHA-2 implementations already let you do this. (This is true, for example, of the OpenSSL implementation.)\r\n\r\nThe other cost here is that it puts us back in a universe where we can't share a hash prefix with other computations of `H(msg || ...)`. But that seems like it's OK---upper-layer protocols are welcome to define a \"prehash mode\" if they're really worried about the cost of hashing messages.",
          "createdAt": "2020-03-04T19:47:55Z",
          "updatedAt": "2020-03-04T19:49:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Referencing the proof wholesale is great! Most hash function implementations allow the internal state to be set, so I don't foresee this to be a problem in practice (as you mention).",
          "createdAt": "2020-03-04T22:08:08Z",
          "updatedAt": "2020-03-04T22:08:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you OK with this change? If so, I\u2019ll merge it.",
          "createdAt": "2020-03-05T16:37:31Z",
          "updatedAt": "2020-03-05T16:37:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure whether the XOR maintains the security, or gives the attacker a new surface for attacks. I am not able to prove or disprove this claim.\r\nLet's move forward.",
          "createdAt": "2020-03-05T18:40:49Z",
          "updatedAt": "2020-03-05T18:40:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTU3OTIw",
          "commit": {
            "abbreviatedOid": "3afe1af"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T22:04:34Z",
          "updatedAt": "2020-03-04T22:04:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":)",
              "createdAt": "2020-03-04T22:04:34Z",
              "updatedAt": "2020-03-05T08:20:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNjM3NTAy",
      "title": "remove explicit use of \"Long\" Weierstrass equations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/215",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses the issues discussed in #195 by making the \"long Weierstrass\" transformations part of the Elligator2 map. The hope is that this makes the Elligator2 section clearer.\r\n\r\nIt also updates the code in `poc/` to match the descriptions in the text.\r\n\r\nCloses #195",
      "createdAt": "2020-02-28T23:05:02Z",
      "updatedAt": "2020-03-03T22:21:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "2b2ea54698b23aa9316b857f110c360ca6388d94",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "remove-long-weierstrass",
      "headRefOid": "53794623e1864278cbc0ee9c91da90a400d36d5e",
      "closedAt": "2020-03-03T18:57:29Z",
      "mergedAt": "2020-03-03T18:57:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "72136122bbecbe7ecaa438e94434aa57835a1588"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @armfazh! I've addressed all the comments.",
          "createdAt": "2020-03-02T21:34:57Z",
          "updatedAt": "2020-03-02T21:34:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice simplification! ",
          "createdAt": "2020-03-03T18:57:21Z",
          "updatedAt": "2020-03-03T18:57:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDIzNTA0",
          "commit": {
            "abbreviatedOid": "849be2a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Only few comments on the rational maps",
          "createdAt": "2020-03-02T18:25:26Z",
          "updatedAt": "2020-03-02T19:08:06Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Here I am not sure whether the sign of `t` should be chosen before doing the transformation from long Weierstrass to Montgomery. \r\nSo line 10 should precede line 9.",
              "createdAt": "2020-03-02T18:25:27Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 271,
              "body": "It seems that these references are not being used  [SP.800-185]  [DRST12]",
              "createdAt": "2020-03-02T18:35:26Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 274,
              "body": "```suggestion\r\n## Twisted Edwards to Montgomery curves {#appx-rational-map-edw}\r\n```",
              "createdAt": "2020-03-02T18:36:07Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 327,
              "body": "This condition is guaranteed by twisted Edwards curves definition.",
              "createdAt": "2020-03-02T18:38:11Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 339,
              "body": "idem",
              "createdAt": "2020-03-02T18:42:15Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 340,
              "body": "When `t=0` (a point of order two) must be mapped to `(0,-1) \\in E` (the point of order two).\r\nWhen `s=-1` it goes to `(0,1)\\in E`.",
              "createdAt": "2020-03-02T18:50:30Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 328,
              "body": "Here are two cases, \r\n\r\n(0,-1) \\in E |--> (0,0) \\in M\r\n(0, 1) \\in E |--> (inf) \\in M\r\n",
              "createdAt": "2020-03-02T18:53:02Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTI4NzQ2",
          "commit": {
            "abbreviatedOid": "849be2a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-02T21:09:30Z",
          "updatedAt": "2020-03-02T21:09:30Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "The way we define sign in the text, sign of t is equal to sign of u. Changing the sign of y and then computing t doesn't necessarily give the same result (depending on the value of K).\r\n\r\nFrom the point of view of the document, it's much simpler to define in terms of t than in terms of y, because y is a purely internal variable to the function.\r\n\r\nNote that this change to the document doesn't change signs for any existing suites, because all of those suites are for curves where K = 1.",
              "createdAt": "2020-03-02T21:09:30Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTUyMTA1",
          "commit": {
            "abbreviatedOid": "5379462"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-02T21:46:43Z",
          "updatedAt": "2020-03-02T21:46:44Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "> From the point of view of the document, it's much simpler to define in terms of t than in terms of y, because y is a purely internal variable to the function.\r\n\r\nYes, of course.\r\n\r\n> Changing the sign of y and then computing t doesn't necessarily give the same result (depending on the value of K).\r\n\r\nWell, this is exactly my point. But anyway, there are no breaking changes since K=1 as you said. So we can proceed as is.\r\n",
              "createdAt": "2020-03-02T21:46:44Z",
              "updatedAt": "2020-03-02T21:46:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTUyNDY0",
          "commit": {
            "abbreviatedOid": "5379462"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-02T21:47:20Z",
          "updatedAt": "2020-03-02T21:47:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MjM5NDIw",
          "commit": {
            "abbreviatedOid": "5379462"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-03T18:57:01Z",
          "updatedAt": "2020-03-03T18:57:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MjY0MDM1",
      "title": "test vectors: add intermediate values, update DSTs, add vectors to document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/217",
      "state": "MERGED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Intention is to facilitate intermediate data collection, which is\r\nthen can be emitted as part of test vectors.\r\n\r\nThis is rather a request for feedback, just to see if it would be considered as a viable approach for collecting intermediate data required for #216. Idea is not only record results like inputs to map_to_curve or clear_cofactor, but even arguments to CMOVs, so that one [can] pick specific vectors out of random set.\r\n",
      "createdAt": "2020-03-05T13:04:21Z",
      "updatedAt": "2020-03-09T17:21:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "1715f79539f9fb904b9aeca3a4e30f813f91fecb",
      "headRepository": "dot-asm/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "test_vector_struct",
      "headRefOid": "e1f1126fbe12ecef523e174ccfae235d48b2781e",
      "closedAt": "2020-03-09T17:21:08Z",
      "mergedAt": "2020-03-09T17:21:08Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "4f73ecf9d7b0550ee564f324eedbcde0bfae2f3a"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool! This looks like a good idea. Not sure whether this will happen before the March 9th deadline for the next IETF meeting, but I'll try!",
          "createdAt": "2020-03-06T17:12:50Z",
          "updatedAt": "2020-03-06T17:12:50Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In such case, I've re-based and fixed 'make test'.\r\n",
          "createdAt": "2020-03-06T22:31:35Z",
          "updatedAt": "2020-03-06T22:31:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "added intermediate values to suite printing and rebased to master",
          "createdAt": "2020-03-09T01:03:37Z",
          "updatedAt": "2020-03-09T01:03:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've updated vectors, added a test vector appendix, and checked compatibility with Sage 8.1. This PR should be good to go.\r\n",
          "createdAt": "2020-03-09T06:11:14Z",
          "updatedAt": "2020-03-09T06:11:14Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not exactly my business, but I [for one] would appreciate if changes to `vector[\"P\"]` were a separate commit and bundled together with modification that triggers the change. I mean I'd appreciate if there was commit that added additional data to `vectors/\\*json`, but didn't change \"P\", and another commit that changes everything along with DST change (right?) that triggers it. So that one has distinct reference points to track. Again, not really my business, so feel free to ignore, but it would make it easier to follow the progression for bystanders such as myself :-)\r\n",
          "createdAt": "2020-03-09T11:33:42Z",
          "updatedAt": "2020-03-09T11:33:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh please review and merge if you're OK with this. ",
          "createdAt": "2020-03-09T14:00:52Z",
          "updatedAt": "2020-03-09T14:00:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's not exactly my business, but I [for one] would appreciate if changes to `vector[\"P\"]` were a separate commit and bundled together with modification that triggers the change.\r\n\r\nSure thing. I've inserted a commit that updates the vectors after adding extra data, but keeps P the same.",
          "createdAt": "2020-03-09T16:52:51Z",
          "updatedAt": "2020-03-09T16:52:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider json vectors should contain the parameter `L` and `Z`.",
          "createdAt": "2020-03-09T16:57:09Z",
          "updatedAt": "2020-03-09T16:57:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, pushed one tiny change---there was a ';' where there should have been a ',' in one of the ciphersuite definitions.",
          "createdAt": "2020-03-09T16:57:17Z",
          "updatedAt": "2020-03-09T16:57:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I consider json vectors should contain the parameter `L` and `Z`.\r\n\r\nSure, I can add that quickly.",
          "createdAt": "2020-03-09T16:57:48Z",
          "updatedAt": "2020-03-09T16:57:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh done. Good now?",
          "createdAt": "2020-03-09T17:17:46Z",
          "updatedAt": "2020-03-09T17:17:46Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, go forward.",
          "createdAt": "2020-03-09T17:18:36Z",
          "updatedAt": "2020-03-09T17:18:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMDk4NTU1",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T11:47:26Z",
          "updatedAt": "2020-03-09T11:47:27Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "There is kind of inconsistency in output. If \"u\" is emitted as an array, then it would be more consistent if \"Q\" was emitted as one as well. As opposite to \"Q0\" and \"Q1\" that is. Or vice versa. If there are \"Q0\" and \"Q1\", then \"u0\" and \"u1\" would be more consistent. [And If you settle for arrays, one can wonder if it would be appropriate to not emit variables as arrays if they have only one element?]\r\n",
              "createdAt": "2020-03-09T11:47:27Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTAwNDc5",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T11:50:54Z",
          "updatedAt": "2020-03-09T11:50:55Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "So \"may be overridden in descendents\" is no longer an option? It still might be useful...",
              "createdAt": "2020-03-09T11:50:55Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjA2Mzg1",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approving in the interest of getting in by the deadline. We can fix any bugs that arise later!",
          "createdAt": "2020-03-09T14:00:34Z",
          "updatedAt": "2020-03-09T14:00:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzM1NDMz",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T16:27:54Z",
          "updatedAt": "2020-03-09T16:27:54Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The variable names and types are consistent with the pseudocode in Section 3.\r\n\r\nI don't want to change Q to an array in the pseudocode because we'd have to add another line initializing Q to an empty array (or at least *somehow* indicating that Q is an array).\r\n\r\nWe could instead do something like\r\n\r\n    (u0, u1) = hash_to_field(msg, 2)\r\n\r\nbut in the `encode_to_curve` case the corresponding Python-ish syntax would be\r\n\r\n    (u0,) = hash_to_field(msg, 1)\r\n\r\nwhich may not make sense to some readers. An alternative would be\r\n\r\n    [u0] = hash_to_field(msg, 1)\r\n\r\nbut this isn't consistent with the notation in hash_to_field.\r\n\r\nSo: I'm OK with the small inconsistency here, because it's in service of simplicity in the pseudocode.",
              "createdAt": "2020-03-09T16:27:54Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzM4Mjg4",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T16:31:24Z",
          "updatedAt": "2020-03-09T16:31:25Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "It turned out not to be useful: the descendants that we need are implemented directly below and only need to override `to_self`.\r\n\r\nAnyway, it can still be overridden in descendants in the normal way. The reason we had two versions of the function before was so that the `_hash` and `hash` functions could have slightly different behavior. This was complexity for no reason: it amounted to testing that doing math on an elliptic curve written in two ways gave the same result.",
              "createdAt": "2020-03-09T16:31:24Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzU1OTg2",
          "commit": {
            "abbreviatedOid": "97bbd7f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-09T16:53:36Z",
          "updatedAt": "2020-03-09T16:53:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1OTMwMTc0",
      "title": "workgroup should be CFRG in frontmatter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/219",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-10T04:24:13Z",
      "updatedAt": "2020-03-10T17:35:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4f73ecf9d7b0550ee564f324eedbcde0bfae2f3a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "front_matter",
      "headRefOid": "059753344db5c979b873c6fcfdf5408be90d5091",
      "closedAt": "2020-03-10T15:24:05Z",
      "mergedAt": "2020-03-10T15:24:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8e4b62bc2c615c9c8669d4d507c5dc1cc2cdc610"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMDU4Mjc4",
          "commit": {
            "abbreviatedOid": "0597533"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-10T15:24:00Z",
          "updatedAt": "2020-03-10T15:24:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2MjcyMDk5",
      "title": "clarify hashed DST output length for XOF case",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/221",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #220",
      "createdAt": "2020-03-10T17:36:42Z",
      "updatedAt": "2020-03-13T20:00:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8e4b62bc2c615c9c8669d4d507c5dc1cc2cdc610",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "dst_clarification",
      "headRefOid": "8adfe20de621241bc7b544c702509d0105001eee",
      "closedAt": "2020-03-13T19:59:40Z",
      "mergedAt": "2020-03-13T19:59:40Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "e9374e1c64c589e3a49308fc27f16a42d5c32312"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyOTkyMDMx",
          "commit": {
            "abbreviatedOid": "e2a625f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-11T17:50:57Z",
          "updatedAt": "2020-03-11T17:50:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NTQzOTky",
          "commit": {
            "abbreviatedOid": "e2a625f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\r\nSome references are not used [CN08] [DFL12] [MT07]",
          "createdAt": "2020-03-13T19:02:03Z",
          "updatedAt": "2020-03-13T19:02:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg4NzQ0NDE4",
      "title": "Add note about security level upper bound.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/224",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This closes #222.",
      "createdAt": "2020-03-15T15:39:44Z",
      "updatedAt": "2022-02-18T16:42:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "36346e036152d3130dce85c520a9cc9f2978aa8d",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/ciphersuite-security-parameter",
      "headRefOid": "0616f03dc1c76bb894b2592e985f1ebfa31a99a2",
      "closedAt": "2020-03-18T19:17:53Z",
      "mergedAt": "2020-03-18T19:17:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0b598fc68b83eddfd89ebe1a4ce8538cdbf15fd4"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam @armfazh I moved the note to the first occurrence of `k`. Please take a look!",
          "createdAt": "2020-03-18T15:58:37Z",
          "updatedAt": "2020-03-18T15:58:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDUxMDY5",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I would like to prevent developers of, for example, using k=128 in a pairing-friendly curve. Then, it is likely that some years later, the actual security could be reduced to, say k=112. Hence, some of them could be tempted to set k=112 (or k=113 depending the paper they read).\r\n\r\nI think the document must stress that `k` must be fixed even in the case of a reduction on security. Since changing this parameter has a waterfall effect in the output of the hash, breaking compatibility.\r\n\r\nAlso open to read your thoughts.\r\n\r\n",
          "createdAt": "2020-03-17T22:33:11Z",
          "updatedAt": "2020-03-17T22:55:39Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think this paragraph should appear earlier at Section 5.1 where it is introduced `k` by the first time.",
              "createdAt": "2020-03-17T22:33:11Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            },
            {
              "originalPosition": 16,
              "body": "A small clash of notation, that can be easily solved, appears on Section 6.8.1 Rational Maps\r\n```\r\nAnalogous ambiguities in other standardized rational maps MUST be resolved in the same way: for any constant k whose sign is ambiguous, k MUST be chosen such that sgn0(k) == 1.\r\n```",
              "createdAt": "2020-03-17T22:37:18Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            },
            {
              "originalPosition": 16,
              "body": "Also in Section 8.8 Defining a new hash curve. \r\nsays: \r\n`k` is the security level of the elliptic curve.\r\nshould say:\r\n`k` is the targeted security level of the suite.\r\n",
              "createdAt": "2020-03-17T22:42:02Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTAyMjc5",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like having this in Security Considerations, but I think a backref in S5 would be good.\r\n\r\nGood catches on notational clashes, @armfazh!",
          "createdAt": "2020-03-18T01:07:42Z",
          "updatedAt": "2020-03-18T01:14:28Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "It's a good idea to make this issue obvious in Section 5, but I think the right way to do it is to have a forward reference from Section 5 (or wherever k is first mentioned) to here. I'd strongly prefer to keep discussion of security issues to the Security Considerations section, because (roughly speaking) Section 5 is normative, whereas this discussion is informative, and keeping them distinct will make things clearer.\r\n\r\n@armfazh do you have an idea of where in Section 5 would be a good place for a forward-reference?",
              "createdAt": "2020-03-18T01:07:42Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            },
            {
              "originalPosition": 16,
              "body": "but I'd suggest \"target\" rather than \"targeted\"\r\n\r\nFor section 6.8.1, maybe use `const`?",
              "createdAt": "2020-03-18T01:10:21Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTg4OTAx",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T15:41:11Z",
          "updatedAt": "2020-03-18T15:41:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yeah, I felt a forward reference to the informative bits from Section 5 was best. ",
              "createdAt": "2020-03-18T15:41:11Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTg5MzM5",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T15:41:38Z",
          "updatedAt": "2020-03-18T15:41:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Great catch!",
              "createdAt": "2020-03-18T15:41:38Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTk0MjYx",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T15:46:47Z",
          "updatedAt": "2020-03-18T15:46:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "> For section 6.8.1, maybe use const?\r\n\r\nI was just going to use `c`, since that's what we use for constants.",
              "createdAt": "2020-03-18T15:46:47Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTQ3MTI1",
          "commit": {
            "abbreviatedOid": "fc51ec9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T18:52:09Z",
          "updatedAt": "2020-03-18T18:52:10Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "in Section 5.1",
              "createdAt": "2020-03-18T18:52:09Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTYwNjY0",
          "commit": {
            "abbreviatedOid": "fc51ec9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T19:11:55Z",
          "updatedAt": "2020-03-18T19:11:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "> in Section 5.1\r\n\r\nHmm?",
              "createdAt": "2020-03-18T19:11:55Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTYzNzYw",
          "commit": {
            "abbreviatedOid": "fc51ec9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "one last nit, it should say `suite` instead of `cryptosystem`.\r\n\r\n```\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter of the cryptosystem (e.g., k = 128).\r\n```",
          "createdAt": "2020-03-18T19:16:38Z",
          "updatedAt": "2020-03-18T19:16:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTY0Nzk5",
          "commit": {
            "abbreviatedOid": "0616f03"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T19:18:09Z",
          "updatedAt": "2020-03-18T19:18:09Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I am ok with the forward reference as is the latest commit.",
              "createdAt": "2020-03-18T19:18:09Z",
              "updatedAt": "2020-03-18T19:18:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkwNzE0MDcy",
      "title": "Pointing to named versions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/226",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Go reference implementation supports v06 using a tagged commit.",
      "createdAt": "2020-03-18T23:22:39Z",
      "updatedAt": "2021-04-21T17:21:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "0b598fc68b83eddfd89ebe1a4ce8538cdbf15fd4",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh-versionsGo",
      "headRefOid": "a13c81f825d45b05d3134a77b5b035cff7e755a0",
      "closedAt": "2020-03-19T20:00:42Z",
      "mergedAt": "2020-03-19T20:00:42Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "003fbdc82e60100fdc5ecb4370ca0c37e8236451"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MzE2MTcy",
          "commit": {
            "abbreviatedOid": "a13c81f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm!",
          "createdAt": "2020-03-18T23:51:33Z",
          "updatedAt": "2020-03-18T23:51:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNjg1ODA3",
      "title": "give guidance on choosing k in Section 8",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/228",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This implements @chris-wood's suggestion in #227.\r\n\r\ncloses #227",
      "createdAt": "2020-03-20T18:39:30Z",
      "updatedAt": "2020-03-21T00:35:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "003fbdc82e60100fdc5ecb4370ca0c37e8236451",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "k_guidance",
      "headRefOid": "53e5b1d2049ecf38882ddf413d75d5b4f03c15be",
      "closedAt": "2020-03-20T23:33:14Z",
      "mergedAt": "2020-03-20T23:33:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9283cbad5c07ff78dc6d0d4e1beab6966bd91529"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM \u2014 thanks!",
          "createdAt": "2020-03-20T20:12:08Z",
          "updatedAt": "2020-03-20T20:12:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzgyOTY2",
          "commit": {
            "abbreviatedOid": "53e5b1d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-20T20:11:52Z",
          "updatedAt": "2020-03-20T20:11:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzkxMDQ1",
          "commit": {
            "abbreviatedOid": "53e5b1d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-20T20:26:45Z",
          "updatedAt": "2020-03-20T20:26:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 229,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzOTAxMjk5",
      "title": "Pointers to rust reference implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/229",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've created a rust reference implementation compatible with v05 and v06",
      "createdAt": "2020-03-26T01:04:07Z",
      "updatedAt": "2021-04-21T17:21:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "9283cbad5c07ff78dc6d0d4e1beab6966bd91529",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/addrust",
      "headRefOid": "7ab58ee7e1f73be1ce87b19d660fb4aa2102888b",
      "closedAt": "2020-03-26T02:54:24Z",
      "mergedAt": "2020-03-26T02:54:24Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "98b7a19d8d8e6b6209e355cb02587ed730bf60a3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk0NTU4NDY5",
      "title": "remove sgn0_be, change sgn0 to output in {0,1}",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/230",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes the changes we discussed in #225.\r\n\r\nCan we hold off on merging this until we get comments from folks working to deploy BLS signatures?\r\n\r\nCloses #225",
      "createdAt": "2020-03-27T05:24:01Z",
      "updatedAt": "2020-03-29T21:58:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "98b7a19d8d8e6b6209e355cb02587ed730bf60a3",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sgn0_simplifications",
      "headRefOid": "de4fd17ce5a8e1a9f3ce712f2debdbd05bf157ea",
      "closedAt": "2020-03-29T15:07:46Z",
      "mergedAt": "2020-03-29T15:07:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8b9c78823e6b691e3e6aabf8116448327094809a"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "CC @JustinDrake @hoeteck @zhenfeizhang @sergeynog\r\n\r\nFor background, see #225. The goal is to significantly simplify the document by unifying the notion of \"sign\" for all curves. Unfortunately, this is a breaking change for BLS12-381, and we'd like feedback on how much of a killer this is.\r\n\r\n@JustinDrake, I know I said that there were probably no more changes coming down the pipe. I'm sorry... :confounded: (If it's any consolation, the change is extremely simple from an implementation point of view...)",
          "createdAt": "2020-03-27T05:28:57Z",
          "updatedAt": "2020-03-27T05:28:57Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If it's a significant spec cleanup/simplification which is minimal for implementers then in theory it sounds good to me. Having said that I'll differ to @djrtwo who can provide much more informed feedback based on the development reality of Eth2 clients :)\r\n\r\ncc @CarlBeek @kirk-baird @mratsim",
          "createdAt": "2020-03-27T15:12:27Z",
          "updatedAt": "2020-03-27T15:12:27Z"
        },
        {
          "author": "sergeynog",
          "authorAssociation": "NONE",
          "body": "Hi Riad:\n\nThis sounds good. I don't think there will be any issues from our end.\n\nRegards,\nSergey\n\n\nOn Fri, Mar 27, 2020 at 11:12 AM Justin <notifications@github.com> wrote:\n\n> If it's a significant spec cleanup/simplification which is minimal for\n> implementers then in theory it sounds good to me. Having said that I'll\n> differ to @djrtwo <https://github.com/djrtwo> who can provide much more\n> informed feedback based on the development reality of Eth2 clients :)\n>\n> cc @CarlBeek <https://github.com/CarlBeek> @kirk-baird\n> <https://github.com/kirk-baird> @mratsim <https://github.com/mratsim>\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/230#issuecomment-605054115>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AGD75LVOUT6JE4KRDCWRJ7TRJS66XANCNFSM4LUX5SQQ>\n> .\n>\n",
          "createdAt": "2020-03-27T15:25:41Z",
          "updatedAt": "2020-03-27T15:25:41Z"
        },
        {
          "author": "kirk-baird",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From an implementation point of view I'm happy for removing `sgn0_be` and only using `sgn0_le` as it is simpler and faster (although the speed is negligible relative to the rest of hashing and pairing).\r\n\r\nFor Ethereum we still have not updated our specs to match hash-to-curve-06 and thus we are already introducing breaking changes so no issues on that front.",
          "createdAt": "2020-03-28T04:12:48Z",
          "updatedAt": "2020-03-28T04:12:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged after hearing no pushback!",
          "createdAt": "2020-03-29T15:08:12Z",
          "updatedAt": "2020-03-29T15:08:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjU2MzAy",
          "commit": {
            "abbreviatedOid": "de4fd17"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-27T23:52:35Z",
          "updatedAt": "2020-03-27T23:52:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjYxNTYx",
          "commit": {
            "abbreviatedOid": "de4fd17"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-28T00:21:17Z",
          "updatedAt": "2020-03-28T00:21:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDMwMjU1",
      "title": "add links to other libraries that implement hash-to-curve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/231",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-28T01:47:43Z",
      "updatedAt": "2020-03-30T15:31:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "98b7a19d8d8e6b6209e355cb02587ed730bf60a3",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "readme_other_impl",
      "headRefOid": "37a5e7f45e4edbe5fe11a5605198ab5d02cd78a9",
      "closedAt": "2020-03-29T22:11:09Z",
      "mergedAt": "2020-03-29T22:11:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6c3a58e3d73e4e20958b7452ee4ad8bc1cda1494"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Does @jedisct1 have an implementation in a libsodium branch?",
          "createdAt": "2020-03-28T16:15:48Z",
          "updatedAt": "2020-03-28T16:15:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like the \"next\" branch adds a ristretto-style map, but as far as I could tell from a quick glance it doesn't implement a compatible hash-to-field. (But I could be wrong!)",
          "createdAt": "2020-03-29T01:28:19Z",
          "updatedAt": "2020-03-29T01:28:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood are you happy pulling this in now and amending if/when libsodium implements?",
          "createdAt": "2020-03-29T22:10:19Z",
          "updatedAt": "2020-03-29T22:10:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep!",
          "createdAt": "2020-03-29T22:11:04Z",
          "updatedAt": "2020-03-29T22:11:04Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `edwards25519_XMD:SHA-512_ELL2_NU_` and `edwards25519_XMD:SHA-512_ELL2_RO_` suites are available in the libsodium's `master` branch (`crypto_core_ed25519_from_string()`, `crypto_core_ed25519_from_string_ro()`).",
          "createdAt": "2020-03-30T15:31:02Z",
          "updatedAt": "2020-03-30T15:31:02Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTkxMDg3",
      "title": "merge @mmaker's g2 cofactor clearing code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/232",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR merges the code from #191, does some slight reformatting, and adds tests.\r\n\r\nAlso adds @mmaker as a contributor.\r\n\r\ncloses #191",
      "createdAt": "2020-03-29T03:43:34Z",
      "updatedAt": "2020-04-17T23:05:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7b839f2dfc0093478ce335d58cbdf5ba0858753a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "mmaker_g2_endo",
      "headRefOid": "997423649522040065bef7db6eb7e6a3add80a37",
      "closedAt": "2020-04-17T23:04:32Z",
      "mergedAt": "2020-04-17T23:04:31Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "710888066d63fc6e83228cf4c064d78a135d8d90"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(rebased onto master)",
          "createdAt": "2020-04-17T23:04:16Z",
          "updatedAt": "2020-04-17T23:04:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjEwNTM3",
          "commit": {
            "abbreviatedOid": "a601779"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-16T13:04:38Z",
          "updatedAt": "2020-04-16T13:16:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nthe denominators (xd == 1 and yd == 1).\r\n```",
              "createdAt": "2020-04-16T13:04:38Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nThe following function efficiently computes psi(psi(P)).\r\n```\r\n\r\n(as opposed to literally invoking `psi` twice!)",
              "createdAt": "2020-04-16T13:07:28Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            },
            {
              "originalPosition": 157,
              "body": "Can we reference draft-yonezawa-pairing-friendly-curves for this constant? (Oddly, I don't see it in the RG version of that document.)",
              "createdAt": "2020-04-16T13:16:03Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0OTQyODU2",
          "commit": {
            "abbreviatedOid": "a601779"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T19:38:59Z",
          "updatedAt": "2020-04-16T19:39:00Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Looks like it's in Appx C of the current RG draft. They demoted BLS12-381, I think...",
              "createdAt": "2020-04-16T19:38:59Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjcwNTkx",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T18:11:53Z",
          "updatedAt": "2020-04-17T18:11:54Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Added a link in the {{suites}} section where we introduce BLS12-381. The appendix backrefs to there. Cool?",
              "createdAt": "2020-04-17T18:11:53Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzE2MDc4",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T19:25:12Z",
          "updatedAt": "2020-04-17T19:25:13Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Yep, works for me!",
              "createdAt": "2020-04-17T19:25:12Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzI1NTA5",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's make the distinction between the named BLS12-381 curve and its twist",
          "createdAt": "2020-04-17T19:41:17Z",
          "updatedAt": "2020-04-17T20:12:20Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "It might be good to put this constant in hex (in the comments) as found in many other sources.",
              "createdAt": "2020-04-17T19:41:17Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            },
            {
              "originalPosition": 140,
              "body": "I think we should specify that the point is on the twist of the BLS12-381, since the twist is a different curve.\r\n ",
              "createdAt": "2020-04-17T20:10:15Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            },
            {
              "originalPosition": 113,
              "body": "`psi` acts on points of the twist of BLS12-381.",
              "createdAt": "2020-04-17T20:11:02Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzQ0MTgy",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T20:13:38Z",
          "updatedAt": "2020-04-17T20:13:39Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "use the variable `bls12381_x` ",
              "createdAt": "2020-04-17T20:13:38Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzQ2MjEx",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T20:17:17Z",
          "updatedAt": "2020-04-17T20:17:17Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "it might be good to test the characteristic equation\r\n``` \u03c8\u00b2 (P ) \u2212 t \u03c8(P ) + q P = \u221e ```",
              "createdAt": "2020-04-17T20:17:17Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzk0Mzgz",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T21:53:00Z",
          "updatedAt": "2020-04-17T21:53:01Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "I think it's a great idea to make clear that this is a different curve. But the term \"twist\" isn't used anywhere in the document, and it seems like a shame to either use it undefined or need to add a definition here. It would be precise to say \"the curve containing the subgroup G2\"---would that work for you?",
              "createdAt": "2020-04-17T21:53:01Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODAxMjUx",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T22:09:19Z",
          "updatedAt": "2020-04-17T22:09:20Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "The term doesn't need to be defined as long as the appropriate references to pairing draft are made.\r\n\r\n>  \"the curve containing the subgroup G2\"\r\n\r\nIn fact, G2 lives in the original curve but over Fp12 (which also satisfies that sentence)\r\n\r\n",
              "createdAt": "2020-04-17T22:09:19Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODA2MDEz",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T22:23:01Z",
          "updatedAt": "2020-04-17T22:23:01Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "> In fact, G2 lives in the original curve but over Fp12 (which also satisfies that sentence)\r\n\r\nHmm, that does not seem to be how G2 is defined anywhere. It's certainly true that this subgroup is isomorphic to a subgroup of the curve defined over Fp12, but in all usage I have seen (including in this draft) elements of the group G2 are points on a curve defined over Fp2.\r\n\r\nAs further support, Budroni and Pintore also use G2 to mean points on the curve defined over Fp2, as does prior work in this line.\r\n\r\nIt is better, in my opinion, to use a slightly longer description that is easily understood rather than a description that the reader may not grok without consulting other references.",
              "createdAt": "2020-04-17T22:23:01Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODA2NzI0",
          "commit": {
            "abbreviatedOid": "c1dc822"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T22:25:08Z",
          "updatedAt": "2020-04-17T22:25:08Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "But actually I believe there's an easy way to avoid this issue entirely, just by talking directly about the curve we mean rather than some description of that curve. I'll push a proposed edit in a moment and we can discuss further.",
              "createdAt": "2020-04-17T22:25:08Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODExMjA4",
          "commit": {
            "abbreviatedOid": "d5694b0"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T22:39:10Z",
          "updatedAt": "2020-04-17T22:39:10Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "The idea here is that the code is copy-and-pasted verbatim from the document, to make sure that what we've written there is correct. (This is why we assert that bls12381_x == c1.)",
              "createdAt": "2020-04-17T22:39:10Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODEzMjAy",
          "commit": {
            "abbreviatedOid": "801af0c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T22:45:51Z",
          "updatedAt": "2020-04-17T22:45:51Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "ok",
              "createdAt": "2020-04-17T22:45:51Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODE0ODI4",
          "commit": {
            "abbreviatedOid": "801af0c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T22:51:29Z",
          "updatedAt": "2020-04-17T22:51:29Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "The formal definition of G2 is the r-torsion points in the original curve over Fp^k.\r\nFor implementation purposes, it is common to use a degree-d twist of the curve over Fp^(k/d).\r\nYou will be agree with all this.\r\n\r\n\r\n",
              "createdAt": "2020-04-17T22:51:29Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODE1MzU2",
          "commit": {
            "abbreviatedOid": "801af0c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-17T22:53:14Z",
          "updatedAt": "2020-04-17T22:53:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODE3NDU2",
          "commit": {
            "abbreviatedOid": "801af0c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T23:00:52Z",
          "updatedAt": "2020-04-17T23:00:52Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "For sure, what you say is absolutely right with respect to the way the pairing operation is defined, etc.! It's only a question of notation what we call elements of G2. But I'm sure that readers of this document don't need to worry about this technicality; it is least confusing, in my mind, to stick with the common usage of \"G2\".",
              "createdAt": "2020-04-17T23:00:52Z",
              "updatedAt": "2020-04-17T23:04:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MzI5NDIw",
      "title": "clarifications based on feedback from VRF authors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/233",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds small clarifications:\r\n\r\n- makes a new subsection in Suites that gives a step-by-step guide\r\n\r\n- forward refs here from the intro rather than repeating that info there\r\n\r\n- changes the section name \"Roadmap\" to \"Encoding byte strings to elliptic curves\". Got feedback from several people that \"Roadmap\" wasn't sufficiently evocative and/or didn't actually describe the content of the section.\r\n\r\n- tweak to the way Z is specified and the justification for choice of sgn0(y) for SvdW\r\n\r\nThe VRF authors specifically requested changes along the lines of the first three to make it easier for users of their document once they incorporate us by ref. This doesn't mean we must do exactly what I've done in this PR, of course.\r\n\r\nI'm hopeful that VRF will accept our PR once we get something like these clarifications in place!",
      "createdAt": "2020-03-29T22:08:09Z",
      "updatedAt": "2020-04-05T03:50:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "8b9c78823e6b691e3e6aabf8116448327094809a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "clarifications",
      "headRefOid": "9fc2d626619d209c310f2eadf8662152fcf16f07",
      "closedAt": "2020-03-30T19:38:20Z",
      "mergedAt": "2020-03-30T19:38:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "50c13e120b2315cfe776dbb8682a714b1ad7f6d4"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I made one quick tweak to the ordering from @chris-wood's diff. Look OK?",
          "createdAt": "2020-03-30T17:25:04Z",
          "updatedAt": "2020-03-30T17:25:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzOTYxMzQz",
          "commit": {
            "abbreviatedOid": "3afd64a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T15:17:17Z",
          "updatedAt": "2020-03-30T15:18:18Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "Aiming for parallel structure:\r\n\r\n```suggestion\r\n1. Target elliptic curve operations, e.g., point addition and scalar multiplication.\r\n\r\n2. Target elliptic curve base field operations, e.g., addition, multiplication, and square root.\r\n\r\n3. The hash-to-field function; see {{hashtofield}}. This includes the expand\\_message\r\n   variant ({{hashtofield-expand}}) and any constituent hash function or XOF.\r\n\r\n4. The suite-specific mapping function; see {{mappings}}.\r\n\r\n5. A cofactor clearing function; see {{cofactor-clearing}}. This may be implemented as \r\n   scalar multiplication by h\\_eff or as a faster equivalent method.\r\n\r\n6. The desired encoding function; see {{roadmap}}. This is either hash\\_to\\_curve or \r\n   encode\\_to\\_curve.\r\n```\r\n\r\n(It may be over-generalizing a bit, but it seems we could probably define a hash-to-curve protocol as a tuple of these functions, e.g., (E, F, HashToField, MapToCurve, ClearCofactor, Encode).)",
              "createdAt": "2020-03-30T15:17:17Z",
              "updatedAt": "2020-03-30T17:24:35Z"
            },
            {
              "originalPosition": 91,
              "body": "> protocols and applications\r\n\r\n:+1:",
              "createdAt": "2020-03-30T15:17:36Z",
              "updatedAt": "2020-03-30T17:24:35Z"
            },
            {
              "originalPosition": 56,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-03-30T15:18:14Z",
              "updatedAt": "2020-03-30T17:24:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MDQ1MTg5",
          "commit": {
            "abbreviatedOid": "3afd64a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T16:49:57Z",
          "updatedAt": "2020-03-30T17:02:47Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Note that the codomain of hash_to_field is a set of field elements.",
              "createdAt": "2020-03-30T16:49:58Z",
              "updatedAt": "2020-03-30T17:24:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MDY2MDgw",
          "commit": {
            "abbreviatedOid": "3afd64a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-30T17:16:23Z",
          "updatedAt": "2020-03-30T17:16:24Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\n-   The function hash\\_to\\_field, {0, 1}^\\* x {1, 2, ...} -> (F, F, ...), hashes arbitrary-length byte strings\r\n    to a list of one or more elements of a finite field; its implementation is defined in\r\n```",
              "createdAt": "2020-03-30T17:16:23Z",
              "updatedAt": "2020-03-30T17:24:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MTcwMTQx",
          "commit": {
            "abbreviatedOid": "9fc2d62"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T19:38:13Z",
          "updatedAt": "2020-03-30T19:38:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1NzgzODEz",
      "title": "add libsodium to readme, too",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/234",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood you were right! I totally missed it.",
      "createdAt": "2020-03-30T17:10:33Z",
      "updatedAt": "2020-04-05T03:50:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6c3a58e3d73e4e20958b7452ee4ad8bc1cda1494",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "readme_libsodium",
      "headRefOid": "bc0b71e64a6218b1e4042f446c659acf23305d34",
      "closedAt": "2020-03-30T19:59:58Z",
      "mergedAt": "2020-03-30T19:59:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "314e63ba8059d7b9611800bf66bde8b8d86e5e91"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No worries. :-)",
          "createdAt": "2020-03-30T19:59:55Z",
          "updatedAt": "2020-03-30T19:59:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MTg0ODcw",
          "commit": {
            "abbreviatedOid": "bc0b71e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T19:59:43Z",
          "updatedAt": "2020-03-30T19:59:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 238,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxMTE1Njc1",
      "title": "Fixing L parameter in P521 suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/238",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - L parameter was set to L=96, the correct value is 98.\r\n\r\nFixes #237 ",
      "createdAt": "2020-04-08T22:40:37Z",
      "updatedAt": "2020-04-08T22:52:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "314e63ba8059d7b9611800bf66bde8b8d86e5e91",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fixLinP521",
      "headRefOid": "c7bfaff37ae046e8eed19da8ec0fcc4a0f1a7d6a",
      "closedAt": "2020-04-08T22:51:14Z",
      "mergedAt": "2020-04-08T22:51:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4c47e09e95e8a8c6ab7faf2ae54d9491e5822c9f"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "It needs to update the test vectors in the main document.",
          "createdAt": "2020-04-08T22:51:20Z",
          "updatedAt": "2020-04-08T22:51:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can do that in a separate PR!",
          "createdAt": "2020-04-08T22:52:12Z",
          "updatedAt": "2020-04-08T22:52:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzg0MDc5",
          "commit": {
            "abbreviatedOid": "c7bfaff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-08T22:51:08Z",
          "updatedAt": "2020-04-08T22:51:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxMTMzNDE5",
      "title": "Updates test vectors in the main document.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/239",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Updates test vectors in the main document after correcting the L parameter in P521 suites.",
      "createdAt": "2020-04-08T23:42:43Z",
      "updatedAt": "2020-04-09T15:56:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4c47e09e95e8a8c6ab7faf2ae54d9491e5822c9f",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fixLinP521_main",
      "headRefOid": "18b383d0ae2fcee9901be775d99d52a2edea8e18",
      "closedAt": "2020-04-09T15:56:39Z",
      "mergedAt": "2020-04-09T15:56:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "80f074bc3acb2d0ad5392ca180e219d016a3fc55"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwOTIyODk1",
          "commit": {
            "abbreviatedOid": "18b383d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-09T15:56:33Z",
          "updatedAt": "2020-04-09T15:56:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxNzc3MjE2",
      "title": "add the remaining optimized impls",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/240",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This finishes off the remaining optimized impls in the appendix, does a slight reorg and generalization, and very slightly improves the Curve25519 and Curve448 maps.\r\n\r\ncloses #181",
      "createdAt": "2020-04-10T06:28:49Z",
      "updatedAt": "2020-04-20T18:14:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "710888066d63fc6e83228cf4c064d78a135d8d90",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "new_optimized_code",
      "headRefOid": "7a301b45f1e24163f51b1f3be9e02ea92bf5994c",
      "closedAt": "2020-04-20T18:12:04Z",
      "mergedAt": "2020-04-20T18:12:03Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "24d9d50a309438b9f7d75a4b1c00b8087c75c73f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "ACKing here, too. This one will take some time to get through.",
          "createdAt": "2020-04-16T13:16:51Z",
          "updatedAt": "2020-04-16T13:16:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(@kwantam you should feel free to merge this without my approval, for what it's worth.)",
          "createdAt": "2020-04-20T13:53:29Z",
          "updatedAt": "2020-04-20T13:53:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjU0NDk5",
          "commit": {
            "abbreviatedOid": "47eec81"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-14T20:04:28Z",
          "updatedAt": "2020-04-14T20:04:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxNzgyMjkw",
      "title": "convert DST encoding to suffix free",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/241",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This implements @davidben's suggestion in #236.\r\n\r\ncloses #236",
      "createdAt": "2020-04-10T06:48:38Z",
      "updatedAt": "2020-04-16T19:40:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "80f074bc3acb2d0ad5392ca180e219d016a3fc55",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "suffix_free_dst",
      "headRefOid": "793a8499302b1285d089579a03ca2619aa56289c",
      "closedAt": "2020-04-16T17:33:17Z",
      "mergedAt": "2020-04-16T17:33:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7b839f2dfc0093478ce335d58cbdf5ba0858753a"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "ping @armfazh @chris-wood should we move forward with this? Would be nice to get -07 out and update BLS in the next few days.\r\n\r\n(Same goes for the other open PRs, but I'd guess this one wants the most scrutiny.)",
          "createdAt": "2020-04-14T16:07:54Z",
          "updatedAt": "2020-04-14T16:07:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "ACKing for now -- I'll try to get to this today!",
          "createdAt": "2020-04-14T18:08:34Z",
          "updatedAt": "2020-04-14T18:08:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks right to me. I suppose there's another input to the function that one needs to consider (len_in_bytes), but the argument holds there, too.\r\n\r\nAnother way to make the argument is: for both XOF and XMD, any valid input to the hash function (either to the XOF or to H when generating b_0) can be uniquely parsed into msg, DST, len_in_bytes, as follows:\r\n\r\n(the following reads the input from back to front)\r\n\r\n1. Read the last byte, interpret as an integer, and read that many more bytes from the end. This is DST.\r\n\r\n2. (XMD only) read a single 0\r\n\r\n3. read two bytes, which are len_in_bytes\r\n\r\n4. (XOF only) read the remaining bytes. This is msg\r\n\r\n5. (XMD only) read all except block-length bytes. This is msg. The remaining block-length bytes should be 0.\r\n\r\nSince the parser is deterministic, there is exactly one (msg, DST, len_in_bytes) tuple that can produce any valid input to XOF/H. By the assumption that XOF/H is collision resistant, the outputs must be different.",
          "createdAt": "2020-04-16T17:26:16Z",
          "updatedAt": "2020-04-16T18:58:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That looks good, too. Thanks!",
          "createdAt": "2020-04-16T17:33:13Z",
          "updatedAt": "2020-04-16T17:33:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzM2MjYw",
          "commit": {
            "abbreviatedOid": "793a849"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry for the delay! It took me longer than I hoped to work through this :-) Previously, it was possible to find a pair of (`msg`, `DST`) tuples T1 = (`msg_1`, `DST_1`) and T2 = (`msg_2`, `DST_2`) such that H(T1) = H(T2). There's four cases: \r\n\r\n(hand waving over notation for now)\r\n\r\n1. `msg_1` = `msg_2` and `DST_1` = `DST_2`: We expect this to produce the same output, so it's fine.\r\n\r\n2. `msg_1` = `msg_2` and `DST_1` != `DST_2`: If `|DST_1|` != `|DST_2|`, then the internal suffix (`DST_prime`) differs, so the output is different. Otherwise, if the lengths are the same and the values are different, then the hashes are different, as expected.\r\n\r\n3. `msg_1` != `msg_2` and `DST_1` = `DST_2`: The prefix `Z_pad || msg` differs, so the hashes are different, as expected.\r\n\r\n4.`msg_1` != `msg_2` and `DST_1` != `DST_2`: Assume by way of contradiction that such a pair exists. If `|DST_1|` != `|DST_2|`, then the internal suffix and resulting hash differs, which is a contradiction. Otherwise, if the lengths are different, then it must be that `DST_1 = DST_2`, which is a contradiction. \r\n\r\n(Did I get that right, @kwantam?)",
          "createdAt": "2020-04-14T22:21:02Z",
          "updatedAt": "2020-04-16T13:00:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxOTM5Nzg3",
      "title": "example code for is_square in quadratic extensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/242",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #190",
      "createdAt": "2020-04-10T14:52:02Z",
      "updatedAt": "2020-04-16T19:40:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "80f074bc3acb2d0ad5392ca180e219d016a3fc55",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "is_square_extensions",
      "headRefOid": "72ec99cec8a55e73b0731fafffc990ad16a56d92",
      "closedAt": "2020-04-16T12:58:34Z",
      "mergedAt": "2020-04-16T12:58:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "69dda837d7d6fdff0da3c87444a523ace3814e13"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjQzNzY2",
          "commit": {
            "abbreviatedOid": "72ec99c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-14T19:48:49Z",
          "updatedAt": "2020-04-14T19:48:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjA1NDEx",
          "commit": {
            "abbreviatedOid": "72ec99c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-16T12:58:27Z",
          "updatedAt": "2020-04-16T12:58:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2MzE1Mzkx",
      "title": "clarifications: k and Edwards map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/244",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes a tiny clarification in Section 5, and some more extensive changes in Section 6 and Appx B in response to #243.\r\n\r\nSpecifically, it moves the definition of the generic Montgomery to twisted Edwards rational map to Appx B ~~and it adds the optimized Monty->Edw map for square K~~. It also clarifies that the map is specified as part of the suite and updates the discussion of sign for standardized mappings.\r\n\r\nEDIT: I removed the optimized Monty->Edw map for square K. Per a conversation with @chris-wood, best to discuss the clarifications in this PR separately from the question of adding another mapping.",
      "createdAt": "2020-04-20T21:35:18Z",
      "updatedAt": "2020-04-29T00:18:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "1bbf07bbc187a0ebe7f9e49740fc59abbb9e5c48",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "small_clarifications",
      "headRefOid": "dc830985719ad4adfd4f020855d8de1cdf24a35e",
      "closedAt": "2020-04-29T00:07:48Z",
      "mergedAt": "2020-04-29T00:07:48Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "17ed13d76e970bbd85d7a94e790a34c3d48b6d1a"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I will review it and post my comments later. ",
          "createdAt": "2020-04-20T21:53:05Z",
          "updatedAt": "2020-04-20T21:53:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh @chris-wood I removed the k=1 mapping from this PR, so now it is just an exercise in reorg and clarification. I'll open a separate PR for the k=1 mapping that builds on this one, and we can separately decide whether to add it or not.",
          "createdAt": "2020-04-28T21:20:29Z",
          "updatedAt": "2020-04-28T21:20:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you OK with this given that it just shuffles things around?",
          "createdAt": "2020-04-28T23:04:25Z",
          "updatedAt": "2020-04-28T23:04:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjIwODY4",
          "commit": {
            "abbreviatedOid": "66a4d7e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! This looks good to me. ",
          "createdAt": "2020-04-28T21:20:59Z",
          "updatedAt": "2020-04-28T21:20:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjk0OTUz",
          "commit": {
            "abbreviatedOid": "dc83098"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-04-29T00:07:19Z",
          "updatedAt": "2020-04-29T00:07:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEwMzY5NTMw",
      "title": "add special mapping for k=1 in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/246",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a section to the appendix that specifies a slightly more optimized Montgomery->Edwards mapping for the case that `4 / (a - d)` is square in F (`a` and `d` are the coefficients of the twisted Edwards curve). This is the mapping that's specified in RFC7748 for Curve25519.\r\n\r\nThe idea here is to help readers pick a better mapping when defining suites for Edwards curves that don't have a standardized Montgomery counterpart.\r\n\r\n**Note** that this PR builds on #244. The differences are all in [this commit](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/246/commits/cc8db5e928a93e4eec37a3793bdf1b8b4119abb6), to make it easier to see what's going on. If we decide to add this, I'll rebase after we land #244.",
      "createdAt": "2020-04-28T21:24:17Z",
      "updatedAt": "2020-05-21T17:33:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "17ed13d76e970bbd85d7a94e790a34c3d48b6d1a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "add_k1",
      "headRefOid": "aa8d9a935120fc4ab2fdfbb1b37fc3a4d384d483",
      "closedAt": "2020-05-21T17:33:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm ambivalent about adding this. On the one hand, it might be nice to include this info to help folks design better suites for twisted Edwards curves that don't have a standardized Montgomery counterpart, which I suppose is good.\r\n\r\nOn the other hand, it only applies to a restricted class of curves---and looking at the Edwards curves listed on [SafeCurves](https://safecurves.cr.yp.to), it looks like this map only applies to Curve41417. And even when it does apply, it only saves a small handful of multiplications---it would be tough to squeeze even a 1% performance boost from this \"optimization.\"\r\n\r\nSo in the end I'm OK just leaving it out. Folks who are defining new curves are of course welcome to define whatever super-optimized Montgomery->Edwards mapping they want regardless of what we say in the appendix...",
          "createdAt": "2020-04-28T21:33:13Z",
          "updatedAt": "2020-04-29T00:21:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for moving this to a separate PR, and sorry for the delay in getting to this! I think we should leave this out, for the reasons outlined above. @armfazh, if you agree, let's close this. ",
          "createdAt": "2020-05-19T01:38:52Z",
          "updatedAt": "2020-05-19T01:38:52Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree, let's close this.",
          "createdAt": "2020-05-21T17:32:26Z",
          "updatedAt": "2020-05-21T17:32:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now. It will remain part of history in case we ever want to revisit it!",
          "createdAt": "2020-05-21T17:33:28Z",
          "updatedAt": "2020-05-21T17:33:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Nzk4MjQ3",
          "commit": {
            "abbreviatedOid": "0e26b17"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T20:28:46Z",
          "updatedAt": "2020-05-19T20:34:35Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nis birationally equivalent to the Montgomery curve\r\n```",
              "createdAt": "2020-05-19T20:28:46Z",
              "updatedAt": "2020-05-19T20:34:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEwMzg3ODA3",
      "title": "move straight-line impls from Section 6 to Appx",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/247",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR moves all of the generic straight-line code from Section 6 to a new appx.\r\n\r\nThe reason to make this a new appx is that the existing \"optimized sample code\" appx has a different interface---all of the mappings use projective coordinates and return ratios. Keeping this in its own appx gets rid of confusion about which sample code uses which interface.",
      "createdAt": "2020-04-28T22:11:50Z",
      "updatedAt": "2020-05-11T21:13:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "17ed13d76e970bbd85d7a94e790a34c3d48b6d1a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "straight_line_appx",
      "headRefOid": "c529b36036f1ca5026525ab2ad0058a1d5093ef1",
      "closedAt": "2020-04-29T03:10:46Z",
      "mergedAt": "2020-04-29T03:10:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c3d5f178ff4d3699ee69ac937e95a3316a0b1aba"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(rebased onto master)",
          "createdAt": "2020-04-29T00:20:45Z",
          "updatedAt": "2020-04-29T00:20:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, are you OK with this?",
          "createdAt": "2020-04-29T00:46:47Z",
          "updatedAt": "2020-04-29T00:46:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjcxODEw",
          "commit": {
            "abbreviatedOid": "f4804f4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "You are quick!",
          "createdAt": "2020-04-28T23:03:27Z",
          "updatedAt": "2020-04-28T23:03:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzE2Mjg1",
          "commit": {
            "abbreviatedOid": "c529b36"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-29T01:24:33Z",
          "updatedAt": "2020-04-29T01:24:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 248,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNzA5OTEy",
      "title": "Fix numbering",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/248",
      "state": "MERGED",
      "author": "kirk-baird",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixing a minor typo in the numbering.",
      "createdAt": "2020-05-04T02:27:12Z",
      "updatedAt": "2020-05-13T08:17:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "c3d5f178ff4d3699ee69ac937e95a3316a0b1aba",
      "headRepository": "kirk-baird/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "kirk-patch-01",
      "headRefOid": "e88c7164e77d538311e550bb35a2d73bb38813ab",
      "closedAt": "2020-05-04T03:25:17Z",
      "mergedAt": "2020-05-04T03:25:17Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "7112dceb3356a9d3746feb5068168da13acc179b"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-05-04T03:25:08Z",
          "updatedAt": "2020-05-04T03:25:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE2MjkxNTc1",
      "title": "Updating v07 implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/249",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Updates links to implementations compatible with draft-v07.",
      "createdAt": "2020-05-11T19:14:27Z",
      "updatedAt": "2021-04-21T17:21:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7112dceb3356a9d3746feb5068168da13acc179b",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/v07Implemantations",
      "headRefOid": "23662318dcec85771168d6aa02401a2c9247fff5",
      "closedAt": "2020-05-11T20:54:27Z",
      "mergedAt": "2020-05-11T20:54:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fd12ba041298053931d6fbb4ee8d5340bb01ef34"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTIyOTA0",
          "commit": {
            "abbreviatedOid": "2366231"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-11T20:54:22Z",
          "updatedAt": "2020-05-11T20:54:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE2NDA0MTIw",
      "title": "change sign computation for Ell2 to match BHKL13",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/250",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the definition of Elligator 2 to match the way that point sign is chosen in BHKL13. This has the effect of making the mapping injective (which is not important in our context, but doesn't hurt and may be useful in other contexts).\r\n\r\nThis was suggested [on the CFRG mailing list](https://mailarchive.ietf.org/arch/msg/cfrg/4EwW-jmlu1OXWE_1v4aKVTBGpZo/) by Mike Hamburg.\r\n\r\nNote that for most (all?) curves the number of points in the image of the mapping is the same under both methods of choosing the sign; they just correspond to slightly different inputs.\r\n\r\nThis PR also updates all of the pseudocode, the corresponding sage code, and the test vectors.",
      "createdAt": "2020-05-11T23:38:47Z",
      "updatedAt": "2020-05-20T04:45:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fd12ba041298053931d6fbb4ee8d5340bb01ef34",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "ell2_sign_fix",
      "headRefOid": "8ec5a3fdcbfc05d00ab18aa419ddfc895cb5b686",
      "closedAt": "2020-05-19T21:47:04Z",
      "mergedAt": "2020-05-19T21:47:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "146f1626292cc6571e705be9b87b2f5a97a54bec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDQyMzcy",
          "commit": {
            "abbreviatedOid": "8ec5a3f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @kwantam! This looks good to me. @armfazh, can you please have a look?",
          "createdAt": "2020-05-19T01:34:51Z",
          "updatedAt": "2020-05-19T01:34:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODMyMDMy",
          "commit": {
            "abbreviatedOid": "8ec5a3f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks good to me",
          "createdAt": "2020-05-19T21:20:36Z",
          "updatedAt": "2020-05-19T21:20:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE3MTk4MTcw",
      "title": "Add Apache Milagro - Rust to list of references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/251",
      "state": "MERGED",
      "author": "kirk-baird",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Apache Milagro - Rust hash implemented hash-to-curve-v07 for BLS12-381 and will hopefully have many more implemented soon.",
      "createdAt": "2020-05-13T08:20:19Z",
      "updatedAt": "2020-05-13T22:11:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fd12ba041298053931d6fbb4ee8d5340bb01ef34",
      "headRepository": "kirk-baird/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "kirk-patch-02",
      "headRefOid": "f77362d23495e29902a66a3be26b6674f675a0a0",
      "closedAt": "2020-05-13T22:11:49Z",
      "mergedAt": "2020-05-13T22:11:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7344dfa66ff259c869a551f9aba30ba35531957d"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Lovely -- thanks!",
          "createdAt": "2020-05-13T22:11:45Z",
          "updatedAt": "2020-05-13T22:11:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzM1NjMy",
          "commit": {
            "abbreviatedOid": "f77362d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-13T22:11:38Z",
          "updatedAt": "2020-05-13T22:11:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMDY3Mjky",
      "title": "Remove unnecessary ciphersuite variety",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/254",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #235. \r\n\r\ncc @davidben, @jedisct1, @reyzin",
      "createdAt": "2020-05-20T23:20:13Z",
      "updatedAt": "2022-02-18T16:42:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "146f1626292cc6571e705be9b87b2f5a97a54bec",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/remove-suites",
      "headRefOid": "db467220b59f8d60cfdee1a13799d4f86ce8cfe5",
      "closedAt": "2020-05-21T22:04:09Z",
      "mergedAt": "2020-05-21T22:04:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b745602521c4535c172b793ce7ce6060935ce009"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam @armfazh, are we good to merge this based on discussion in #235?",
          "createdAt": "2020-05-21T16:43:24Z",
          "updatedAt": "2020-05-21T16:43:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzQyNTI1",
          "commit": {
            "abbreviatedOid": "db46722"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-05-21T17:22:33Z",
          "updatedAt": "2020-05-21T17:22:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNjkzMDky",
      "title": "Use the example protocol name as the DST in the test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/255",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per @jedisct1's suggestion, this uses the example protocol from the document as the DST value. I opted *not* to include a long DST, since we don't have any branches on the length of the DST. (We do have a requirement that it be less than 256 bytes, but I'm not sure we need a test vector for that?)\r\n\r\n",
      "createdAt": "2020-05-22T03:23:42Z",
      "updatedAt": "2022-02-18T16:42:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d668b0b334238fef7b6dda74a499c3836bf5f897",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/fix-test-dst",
      "headRefOid": "c62262c8c5c7993a97dc380a3456127d4808e0c6",
      "closedAt": "2020-05-22T21:35:46Z",
      "mergedAt": "2020-05-22T21:35:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "473208ac66093b19602bc3273fa74089ca8c7df8"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: I will do this review tomorrow!",
          "createdAt": "2020-05-22T04:44:35Z",
          "updatedAt": "2020-05-22T04:44:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I have test vectors for `expand_message` ready to go, too. I'll send those in a separate PR after this lands.",
          "createdAt": "2020-05-22T17:23:02Z",
          "updatedAt": "2020-05-22T17:23:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, I'll remove those test vectors, too. Stand by!",
          "createdAt": "2020-05-22T21:21:45Z",
          "updatedAt": "2020-05-22T21:21:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam here's the final set of suites:\r\n\r\n```\r\nALL_SUITES = [\r\n    p256_sswu_ro, p384_sswu_ro, p521_sswu_ro, secp256k1_sswu_ro,\r\n    p256_sswu_nu, p384_sswu_nu, p521_sswu_nu, secp256k1_sswu_nu,\r\n    edw25519_sha512_ro, edw448_hash_ro,\r\n    edw25519_sha512_nu, edw448_hash_nu,\r\n    monty25519_sha512_ro, monty448_hash_ro,\r\n    monty25519_sha512_nu, monty448_hash_nu,\r\n    bls12381g1_sswu_ro, bls12381g2_sswu_ro,\r\n    bls12381g1_sswu_nu, bls12381g2_sswu_nu,\r\n]\r\n```",
          "createdAt": "2020-05-22T21:27:00Z",
          "updatedAt": "2020-05-22T21:27:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTgxMjc2",
          "commit": {
            "abbreviatedOid": "8086cb5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "~`suite_448.sage` is broken---needs to import `test_dst` from `sagelib.common`.~ fixed now\r\n\r\n\r\nAh, one other thing: should we go ahead and remove the test vectors for the suites that no longer exist?",
          "createdAt": "2020-05-22T21:02:10Z",
          "updatedAt": "2020-05-22T21:17:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    from sagelib.common import sgn0_be\r\n```\r\n\r\nI think this might have been a mistake.",
              "createdAt": "2020-05-22T21:02:10Z",
              "updatedAt": "2020-05-22T21:34:29Z"
            },
            {
              "originalPosition": 31,
              "body": "Does this combined_ascii file get used somewhere? Is the idea that this replaces the `poc/test_vectors_appx.py` script?",
              "createdAt": "2020-05-22T21:10:05Z",
              "updatedAt": "2020-05-22T21:34:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTg3OTYw",
          "commit": {
            "abbreviatedOid": "a7e6544"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T21:20:04Z",
          "updatedAt": "2020-05-22T21:20:05Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Doh. I didn't even realize that was a thing! It does the same thing. Would you prefer I remove this change?",
              "createdAt": "2020-05-22T21:20:04Z",
              "updatedAt": "2020-05-22T21:34:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTg4Nzk1",
          "commit": {
            "abbreviatedOid": "7e8535b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T21:22:27Z",
          "updatedAt": "2020-05-22T21:22:28Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "No strong preference. The order of the sections is slightly different, which ends up making the diff to the document huge. So I guess that's a small thing in favor of keeping the old script, but only a very small one.",
              "createdAt": "2020-05-22T21:22:28Z",
              "updatedAt": "2020-05-22T21:34:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTg5MDc5",
          "commit": {
            "abbreviatedOid": "7e8535b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T21:23:16Z",
          "updatedAt": "2020-05-22T21:23:16Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I'll remove it :) ",
              "createdAt": "2020-05-22T21:23:16Z",
              "updatedAt": "2020-05-22T21:34:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTkwMzE2",
          "commit": {
            "abbreviatedOid": "7e8535b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-22T21:26:16Z",
          "updatedAt": "2020-05-22T21:26:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxOTYxNTY5",
      "title": "Fix M. Tibouchi name ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/257",
      "state": "MERGED",
      "author": "mratsim",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"Indifferentiable deterministic hashing to elliptic and hyperelliptic curves\"",
      "createdAt": "2020-05-22T14:47:05Z",
      "updatedAt": "2020-05-22T16:42:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "efc6cadfdab967f272ce05d373499330e4ca3e2b",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "5537622a7a6b4a36ddd17ec00c5c144e314478b4",
      "closedAt": "2020-05-22T16:42:36Z",
      "mergedAt": "2020-05-22T16:42:36Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "d668b0b334238fef7b6dda74a499c3836bf5f897"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! :+1:",
          "createdAt": "2020-05-22T16:42:26Z",
          "updatedAt": "2020-05-22T16:42:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMTUyODkw",
      "title": "small test vector tweaks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/258",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the unused json files and updates the script for the document and the test vectors section in the document.",
      "createdAt": "2020-05-22T21:54:01Z",
      "updatedAt": "2020-05-23T06:27:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "473208ac66093b19602bc3273fa74089ca8c7df8",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "test_vector_little",
      "headRefOid": "8ad338bea7ae5d85f71720c970659af9fde465dd",
      "closedAt": "2020-05-22T21:55:13Z",
      "mergedAt": "2020-05-22T21:55:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f23930f0377a392767fb2467fb6a5c165750e604"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjAzNDY0",
          "commit": {
            "abbreviatedOid": "8ad338b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-22T21:55:06Z",
          "updatedAt": "2020-05-22T21:55:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMTU5NDE4",
      "title": "Add expand_message test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/259",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #253.",
      "createdAt": "2020-05-22T22:22:15Z",
      "updatedAt": "2022-02-18T16:42:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f23930f0377a392767fb2467fb6a5c165750e604",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/expand-vectors",
      "headRefOid": "92a51cd7d860e272fcb32adfddcda5dabb16be67",
      "closedAt": "2020-05-22T23:27:59Z",
      "mergedAt": "2020-05-22T23:27:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f69ca372d8db728650706590d9e3a1788d5abb70"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> One small thing: would it make sense to fix the line wrapping in the ASCII test vectors? I know this is annoying, but I'm guessing the rfc editor is going to make us do it at some point...\r\n\r\nYeah, probably. I think we can probably tackle this during RGLC, so I'll merge this as-is now!",
          "createdAt": "2020-05-22T23:27:55Z",
          "updatedAt": "2020-05-22T23:27:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjEzNTgw",
          "commit": {
            "abbreviatedOid": "5fcca41"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T22:33:50Z",
          "updatedAt": "2020-05-22T22:33:51Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "what is the input msg?",
              "createdAt": "2020-05-22T22:33:50Z",
              "updatedAt": "2020-05-22T23:08:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjE0Mzgx",
          "commit": {
            "abbreviatedOid": "5fcca41"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T22:37:28Z",
          "updatedAt": "2020-05-22T22:37:29Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Oh whoops -- I added it to the dictionary but forgot to render it. Stand by!",
              "createdAt": "2020-05-22T22:37:29Z",
              "updatedAt": "2020-05-22T23:08:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjE5OTky",
          "commit": {
            "abbreviatedOid": "7b9175d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T23:07:59Z",
          "updatedAt": "2020-05-22T23:08:00Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I think here is where your are dumping twice.\r\n",
              "createdAt": "2020-05-22T23:08:00Z",
              "updatedAt": "2020-05-22T23:08:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjIwMjgw",
          "commit": {
            "abbreviatedOid": "92a51cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T23:09:44Z",
          "updatedAt": "2020-05-22T23:09:45Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I didn't consider this a big deal, but fixed it nonetheless. Please have a look!",
              "createdAt": "2020-05-22T23:09:44Z",
              "updatedAt": "2020-05-22T23:09:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjIwODc0",
          "commit": {
            "abbreviatedOid": "92a51cd"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-22T23:12:49Z",
          "updatedAt": "2020-05-22T23:12:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjIzMjk5",
          "commit": {
            "abbreviatedOid": "92a51cd"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me!\r\n\r\nOne small thing: would it make sense to fix the line wrapping in the ASCII test vectors? I know this is annoying, but I'm guessing the rfc editor is going to make us do it at some point...",
          "createdAt": "2020-05-22T23:26:38Z",
          "updatedAt": "2020-05-22T23:26:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 262,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMjE4MzU3",
      "title": "Fixes indentation of is_square.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/262",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes indentation of is_square.",
      "createdAt": "2020-05-23T04:09:59Z",
      "updatedAt": "2020-05-23T06:52:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f69ca372d8db728650706590d9e3a1788d5abb70",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fixIden",
      "headRefOid": "9457c2b486b19818d6cc6e597cb67ec56280068c",
      "closedAt": "2020-05-23T06:52:01Z",
      "mergedAt": "2020-05-23T06:52:01Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "e92c188be1ac404e7c013f6f6e4b9e12efbdc871"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. Have you tried running this through the compilation pipeline? My recollection is that this gives the wrong result. I'll check now and report back.",
          "createdAt": "2020-05-23T06:26:20Z",
          "updatedAt": "2020-05-23T06:26:20Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK! So it turns out that the kramdown HTML output is kind of broken, and what we should actually care about is the text. This is indeed an improvement :+1:\r\n\r\nI did a quick sweep of the document for consistency of blockquotes-inside-of-bullets. ~Looks like there are two instances of this issue in #hashtofield-expand-dst. Also maybe the blockquotes in #roadmap?~ The output doesn't seem to be improved by changing these. I'd say leave them alone.",
          "createdAt": "2020-05-23T06:45:54Z",
          "updatedAt": "2020-05-23T06:51:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMjg0Njkx",
      "title": "Rename pseudo_random_bytes to uniform_bytes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/263",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #261. (Thanks, @reyzin!)",
      "createdAt": "2020-05-23T14:53:49Z",
      "updatedAt": "2022-02-18T16:42:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "e92c188be1ac404e7c013f6f6e4b9e12efbdc871",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/rename-pseudorandom",
      "headRefOid": "d0eff3985b46deeae013a554452ecb857f2e967a",
      "closedAt": "2020-05-23T18:30:38Z",
      "mergedAt": "2020-05-23T18:30:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e5642d7ad475232ee6de9a68eed1f43469a513e4"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! They look good. Merging now.",
          "createdAt": "2020-05-23T18:30:33Z",
          "updatedAt": "2020-05-23T18:30:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Mjk1MjM4",
          "commit": {
            "abbreviatedOid": "d0eff39"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!\r\n\r\nI pushed a couple commits that remove bad uses of the word \"pseudorandom\" in the text, too. Please let me know if the edits look weird or wrong!",
          "createdAt": "2020-05-23T17:37:06Z",
          "updatedAt": "2020-05-23T17:37:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 264,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMzM1ODA0",
      "title": "Domain separation discussion in Security Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/264",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR:\r\n\r\n- updates acknowledgments\r\n- slightly tweaks and clarifies the domain separation requirements\r\n- adds a discussion of \"external\" domain separation in the Security Recommendations section\r\n\r\ncloses #256",
      "createdAt": "2020-05-23T22:38:49Z",
      "updatedAt": "2020-05-29T23:28:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "da6db8b0e3ed731af1199420f87b8cd903c1321a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "domain_separation_considerations",
      "headRefOid": "123128058f2a04a54fa34c70195af1ab967ada73",
      "closedAt": "2020-05-28T21:15:03Z",
      "mergedAt": "2020-05-28T21:15:03Z",
      "mergedBy": "armfazh",
      "mergeCommit": {
        "oid": "136c6d46c0061e4b3efb1f6d8ad26b2de1d7ba1b"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I have done a heavy editing pass on this section based on offline feedback from @reyzin. Sorry that this causes extra reviewing work, but I think the result is a more coherent description.",
          "createdAt": "2020-05-28T05:05:29Z",
          "updatedAt": "2020-05-28T05:05:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Simpler indeed. I'm happy.",
          "createdAt": "2020-05-28T21:04:12Z",
          "updatedAt": "2020-05-28T21:04:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh please merge if you're OK with the changes!",
          "createdAt": "2020-05-28T21:04:20Z",
          "updatedAt": "2020-05-28T21:04:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzE1Mzkw",
          "commit": {
            "abbreviatedOid": "dcd4bc4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! This matches what I expected from the issue. I only have a couple suggestions and one clarifying question.",
          "createdAt": "2020-05-23T23:23:56Z",
          "updatedAt": "2020-05-23T23:37:22Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "```suggestion\r\n1. For each use of H outside hash\\_to\\_field, choose a unique domain\r\n   separation tag DST\\_ext. Augment each invocation of H with input msg by\r\n   computing H(DST\\_ext || msg || I2OSP(0, 1)).\r\n```",
              "createdAt": "2020-05-23T23:23:56Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n   required to be nonzero ({{domain-separation}}, requirement 2), and DST\\_prime is always\r\n```",
              "createdAt": "2020-05-23T23:25:29Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\n   For example, for two uses of H whose inputs are msg1 and msg2,\r\n```",
              "createdAt": "2020-05-23T23:25:59Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 126,
              "body": "To me, an invocation is a single call to H, e.g., H(msg), whereas (as I understand it) what we mean here is that we want to clone H twice using DST_ext1 and DST_ext2.",
              "createdAt": "2020-05-23T23:28:08Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\n   For example, for two uses of H whose inputs are msg1 and msg2,\r\n```",
              "createdAt": "2020-05-23T23:28:57Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\n{{hashtofield-expand-other}} are expected to have similar properties.\r\nHowever, these should be analyzed on a case-by-case basis.\r\n```",
              "createdAt": "2020-05-23T23:29:46Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nexpand\\_message\\_xmd guards against these attacks.\r\nApplications can use it as a random oracle outside of hash\\_to\\_field\r\nwith proper domain separation from invocations inside hash\\_to\\_field\r\nby choosing a different DST.\r\n```",
              "createdAt": "2020-05-23T23:30:14Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 168,
              "body": "This is another possibility to use expand_message_xmd outside of hash_to_field? I'm not sure I follow this example. The above paragraph says, as I understand it, \"feel free to crib expand_message_xmd for your purposes so long as you apply domain separation with a separate tag.\" It's not clear to me how this example follows. Can you clarify?",
              "createdAt": "2020-05-23T23:34:55Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 204,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-05-23T23:36:27Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzI0OTcz",
          "commit": {
            "abbreviatedOid": "dcd4bc4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T03:59:33Z",
          "updatedAt": "2020-05-24T03:59:33Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Ah, yes, sorry. What I meant was, an alternative to using expand_msg_xmd is to use HMAC. And then the idea is, this is how you'd domain separate HMAC from expand_message_xmd. I will clarify",
              "createdAt": "2020-05-24T03:59:33Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzI3NDM5",
          "commit": {
            "abbreviatedOid": "c174f27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T05:12:49Z",
          "updatedAt": "2020-05-24T05:12:49Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "OK, I took a crack at clarifying. Does this make sense now?\r\n\r\nThe reason I want to include \"how to domain separate HMAC from expand_message_xmd\" is that I suspect this might be something that protocols will want to do.",
              "createdAt": "2020-05-24T05:12:49Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzI4NTI4",
          "commit": {
            "abbreviatedOid": "3bcc44f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T05:44:05Z",
          "updatedAt": "2020-05-24T05:44:05Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Did some further simplification.",
              "createdAt": "2020-05-24T05:44:05Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzU4NTA2",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is much more clear now -- thanks for the additional details. (I need to give this a careful look in conjunction with the domain separation efforts we put into [HPKE](https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-cryptographic-dependencies), but that's not a blocking task.) ",
          "createdAt": "2020-05-24T13:24:50Z",
          "updatedAt": "2020-05-24T13:24:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzU4NTk3",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T13:26:05Z",
          "updatedAt": "2020-05-24T13:26:06Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Yep! All good now.",
              "createdAt": "2020-05-24T13:26:05Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTg2ODc5",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-27T20:34:18Z",
          "updatedAt": "2020-05-27T20:35:03Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "I think you might want to say two hash functions H0, H1 created from H. So each hash function has different `DST_ext` prefix.\r\n\r\nOtherwise, this makes me think that every time Alice wants to hash using say H0 (derived from H), she needs to append a different DST_ext (per message). Rather than a DST_ext that is the same for all invocations of H0.\r\n",
              "createdAt": "2020-05-27T20:34:18Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjE1OTg0",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:18:23Z",
          "updatedAt": "2020-05-27T21:18:24Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Wouldn't those be identical? Namely, Alice could append the DST, or the implementation of H0 could do it internally, no?",
              "createdAt": "2020-05-27T21:18:23Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjI0OTA4",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:33:04Z",
          "updatedAt": "2020-05-27T21:33:05Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "The difference is whether the `DTS_ext` is different per message rather than per hash H0,H1,...",
              "createdAt": "2020-05-27T21:33:04Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjI2Mjgz",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:35:31Z",
          "updatedAt": "2020-05-27T21:35:31Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Sorry, I'm not following. How are these not identical? \r\n\r\n```\r\nH0(msg) = H(msg || DST1) // Library appends and calls H directly\r\nH1(msg) = H(msg || DST2) // ^^\r\n```\r\n\r\nand\r\n\r\n```\r\nH0(msg || DST1) = H(msg || DST1) // Alice appends and calls H directly\r\nH1(msg || DST2) = H(msg || DST2) // ^^\r\n```",
              "createdAt": "2020-05-27T21:35:31Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjM2MDYx",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:53:06Z",
          "updatedAt": "2020-05-27T21:53:07Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "This is not the point. \r\n\r\n> For example, for two uses of H whose inputs are msg1 and msg2, one might choose distinct DST\\_ext1 and DST\\_ext2 and compute\r\n>\r\n>        hash1 = H(DST_ext1 || msg1 || I2OSP(0, 1))\r\n>        hash2 = H(DST_ext2 || msg2 || I2OSP(0, 1))\r\n\r\nEvery time Alice wants to hash with H0 defined as H0(msg) = H( DST_ex || msg ),  she must choose a different DST_ex. \r\n\r\nSo, which one is the correct way?\r\nH0(msg1) = H( DST_ex1 || msg1 )\r\nH0(msg2) = H( DST_ex2 || msg2 )\r\nH0(msg3) = H( DST_ex3 || msg3 )\r\nor this one\r\nH0(msg1) = H( DST_ex || msg1 )\r\nH0(msg2) = H( DST_ex || msg2 )\r\nH0(msg3) = H( DST_ex || msg3 )\r\n\r\nI think the correct way is the second one, but the text it seems to me is saying the first one.\r\n  \r\n\r\n",
              "createdAt": "2020-05-27T21:53:06Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjM3MTQw",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:55:14Z",
          "updatedAt": "2020-05-27T21:55:15Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Ah, I see! Certainly the second one is the recommendation here. Maybe this clears it up?\r\n\r\n```\r\nhash1 = H1(msg) = H(DST_ext1 || msg || I2OSP(0, 1))\r\nhash2 = H2(msg) = H(DST_ext2 || msg || I2OSP(0, 1))\r\n```",
              "createdAt": "2020-05-27T21:55:14Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjQ5Njg1",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T22:20:11Z",
          "updatedAt": "2020-05-27T22:20:11Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "@kwantam if this works for you, would you mind adding it? I'll merge when done!",
              "createdAt": "2020-05-27T22:20:11Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NzI4Njc1",
          "commit": {
            "abbreviatedOid": "e6addd6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-28T02:05:05Z",
          "updatedAt": "2020-05-28T02:05:05Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Great catch. I will clarify.",
              "createdAt": "2020-05-28T02:05:05Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjgwODUw",
          "commit": {
            "abbreviatedOid": "7837730"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These latest changes look good! I have a couple suggestions, but nothing blocking.",
          "createdAt": "2020-05-28T16:20:04Z",
          "updatedAt": "2020-05-28T16:55:00Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "```suggestion\r\ndistinct from DST\\_prime and augment calls to H with DST\\_ext.\r\n```",
              "createdAt": "2020-05-28T16:20:05Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nEach method augments calls to H differently, and each may impose\r\n```",
              "createdAt": "2020-05-28T16:20:38Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 143,
              "body": "```suggestion\r\n    encoding the length of DST\\_ext) to make it infeasible to find distinct\r\n```",
              "createdAt": "2020-05-28T16:25:33Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 157,
              "body": "```suggestion\r\n    encoding the length of DST\\_ext) to make it infeasible to find distinct\r\n```",
              "createdAt": "2020-05-28T16:25:43Z",
              "updatedAt": "2020-05-28T21:00:48Z"
            },
            {
              "originalPosition": 162,
              "body": "```suggestion\r\n    are distinct from those inside expand\\_message. Specifically, the final byte of\r\n```",
              "createdAt": "2020-05-28T16:30:48Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            },
            {
              "originalPosition": 147,
              "body": "```suggestion\r\n    H have distinct suffixes. Namely, two suffixes are only equal if their length and value is the same, which\r\n    is not possible if DST\\_ext is different from DST\\_prime.\r\n```",
              "createdAt": "2020-05-28T16:50:14Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            },
            {
              "originalPosition": 170,
              "body": "```suggestion\r\n    It does not give domain separation for expand\\_message\\_xof or HMAC-H.\r\n```",
              "createdAt": "2020-05-28T16:50:46Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            },
            {
              "originalPosition": 198,
              "body": "Should we note something about HMAC-H when used with a secret key? (HPKE, for example, assumes HMAC is indifferentiable from a RO.)",
              "createdAt": "2020-05-28T16:54:12Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzI2NjI4",
          "commit": {
            "abbreviatedOid": "7837730"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "some suggested edits",
          "createdAt": "2020-05-28T17:15:15Z",
          "updatedAt": "2020-05-28T17:46:20Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "I think this line could be better sited at the start of the section. \r\nSo, first recalling the objective of domain separation, \r\nthen showing how we achieve this objective _inside_ expand_message,\r\nand then pointing out how others can  _externally_ use H preserving domain separation.  ",
              "createdAt": "2020-05-28T17:15:15Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nEach method proceeds in a similar way: first, it chooses a tag DST\\_ext\r\n```",
              "createdAt": "2020-05-28T17:20:24Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            },
            {
              "originalPosition": 123,
              "body": "Is there a reason for using parentheses?",
              "createdAt": "2020-05-28T17:22:16Z",
              "updatedAt": "2020-05-28T21:00:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDYyNzIx",
          "commit": {
            "abbreviatedOid": "7837730"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I've pushed a revision that responds to all of these comments. Thank you!!!",
          "createdAt": "2020-05-28T20:21:41Z",
          "updatedAt": "2020-05-28T21:01:22Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "To make clear that it's a heading rather than text. Since we don't have \"description\" lists, I went with something roughly analogous to what's frequently used in papers, e.g.,\r\n\r\n    Definition 1 (Soundness.)\r\n\r\nI'm not extremely committed to keeping this, but I do think the parens are slightly better for clarity.",
              "createdAt": "2020-05-28T20:21:41Z",
              "updatedAt": "2020-05-28T21:01:22Z"
            },
            {
              "originalPosition": 147,
              "body": "I'm going to push an edit with something slightly simpler; please let me know if you prefer more detail.",
              "createdAt": "2020-05-28T20:24:44Z",
              "updatedAt": "2020-05-28T21:01:22Z"
            },
            {
              "originalPosition": 115,
              "body": "I'm going to push a commit with a similar edit, except that the subject of the verb \"chooses\" is not the method, it's the protocol designer. Please let me know if my edit doesn't capture the spirit of this suggestion.",
              "createdAt": "2020-05-28T20:25:56Z",
              "updatedAt": "2020-05-28T21:01:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDkwNDg0",
          "commit": {
            "abbreviatedOid": "1231280"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-28T21:03:54Z",
          "updatedAt": "2020-05-28T21:03:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 266,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMzI0MTI4",
      "title": "fixes and tweaks for h2f test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/266",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses the issue in #265 and also updates the data dumped out in the expand_message test vectors:\r\n\r\n- adds `len_in_bytes` argument for each invocation\r\n- removes `security_param`, which is an internal variable for sanity checking and not part of the API\r\n\r\nAlso, this PR updates `printer.py` to wrap correctly when the label is longer than 7 chars.\r\n\r\ncloses #265 ",
      "createdAt": "2020-05-26T16:42:39Z",
      "updatedAt": "2020-05-28T02:00:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "e5642d7ad475232ee6de9a68eed1f43469a513e4",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "h2f_vector_fix",
      "headRefOid": "380f3510318260cc956d4930eea32ab1f7a7fb25",
      "closedAt": "2020-05-26T17:47:01Z",
      "mergedAt": "2020-05-26T17:47:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "da6db8b0e3ed731af1199420f87b8cd903c1321a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTE3ODA5",
          "commit": {
            "abbreviatedOid": "380f351"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T17:24:32Z",
          "updatedAt": "2020-05-26T17:24:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTM0Mjc1",
          "commit": {
            "abbreviatedOid": "380f351"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks great! Thanks!",
          "createdAt": "2020-05-26T17:46:50Z",
          "updatedAt": "2020-05-26T17:46:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 267,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0ODE5ODA0",
      "title": "Edits up to Deterministic Mappings.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/267",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'll continue my pass separately from this PR. I wanted to keep things somewhat small.",
      "createdAt": "2020-05-29T00:24:13Z",
      "updatedAt": "2022-02-18T16:42:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "094784ed6e314b1c4d1cf075d44c23f998113f86",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/up-to-mappings",
      "headRefOid": "c1b25c53fc9c0e6dc99585483fdaf03ce4efab18",
      "closedAt": "2020-05-29T22:31:59Z",
      "mergedAt": "2020-05-29T22:31:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "590f252e2e5fa7df15d9e027ff5aa01abbaf8bed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjYzMDgx",
          "commit": {
            "abbreviatedOid": "f234bd6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T20:21:10Z",
          "updatedAt": "2020-05-29T20:21:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjczOTQ2",
          "commit": {
            "abbreviatedOid": "f234bd6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Nice edits. Just a few nits and tiny questions.",
          "createdAt": "2020-05-29T20:41:12Z",
          "updatedAt": "2020-05-29T20:55:11Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nconsequences for the security of a protocol.\r\n```",
              "createdAt": "2020-05-29T20:41:12Z",
              "updatedAt": "2020-05-29T22:29:21Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\nFor security reasons, protocols using elliptic curves often require a group\r\nof prime order. Elliptic curves induce subgroups of prime order.\r\n```",
              "createdAt": "2020-05-29T20:45:26Z",
              "updatedAt": "2020-05-29T22:29:21Z"
            },
            {
              "originalPosition": 155,
              "body": "As an alternative, I was going to suggest `Hf`. Maybe slightly easier to read than H'?",
              "createdAt": "2020-05-29T20:46:56Z",
              "updatedAt": "2020-05-29T22:29:21Z"
            },
            {
              "originalPosition": 297,
              "body": "```suggestion\r\nwhich is a byte string constructed according to the following requirements:\r\n```",
              "createdAt": "2020-05-29T20:50:29Z",
              "updatedAt": "2020-05-29T22:29:21Z"
            },
            {
              "originalPosition": 523,
              "body": "Does `||` need escaping as elsewhere?\r\n\r\nOr maybe the escaping is unnecessary?",
              "createdAt": "2020-05-29T20:54:28Z",
              "updatedAt": "2020-05-29T22:29:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzMxMDcx",
          "commit": {
            "abbreviatedOid": "5b0fecf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T22:29:16Z",
          "updatedAt": "2020-05-29T22:29:16Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "That'll work too! Want to make that change in your pass after rebasing?\r\n",
              "createdAt": "2020-05-29T22:29:16Z",
              "updatedAt": "2020-05-29T22:29:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzMxODQ5",
          "commit": {
            "abbreviatedOid": "c1b25c5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T22:31:35Z",
          "updatedAt": "2020-05-29T22:31:36Z",
          "comments": [
            {
              "originalPosition": 523,
              "body": "It doesn't look like it (I see it render fine)?",
              "createdAt": "2020-05-29T22:31:35Z",
              "updatedAt": "2020-05-29T22:31:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 268,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1Mjk5MjM0",
      "title": "Merging section 4 and 4.1.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/268",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the past section 4.1 descried two sgn0 variants. Now there is only one, so I merged into section 4.\r\n\r\nIt also reorders items of section 4, first functions on bit strings followed by operations on field elements. (the reverse order is interesting too).\r\n\r\n* This is on top of #267 for easily seeing changes.",
      "createdAt": "2020-05-29T19:56:40Z",
      "updatedAt": "2020-06-01T16:38:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "caw/up-to-mappings",
      "baseRefOid": "f234bd65d96670ef3301c2c0fd6a06d91e0d688b",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sug/mergeSec4",
      "headRefOid": "b672cc965b79b0c5a421e00d7bb26870c293a363",
      "closedAt": "2020-06-01T16:38:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this change necessary? It seems like `sgn0` is complicated enough and the description is long enough that a separate sub-section makes sense...",
          "createdAt": "2020-05-29T20:38:05Z",
          "updatedAt": "2020-05-29T20:38:05Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\n> `sgn0` is complicated enough and the description is long enough that a separate sub-section makes sense...\r\n\r\nit is not entirely necessary, but it doesn't hurt to revisit again. Thumbs up/down?\r\n\r\n\r\n",
          "createdAt": "2020-05-29T20:49:05Z",
          "updatedAt": "2020-05-29T20:49:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, I think it's a big enough chunk that it's clearer in its own subsection, so I guess I'd vote against this change.",
          "createdAt": "2020-05-29T20:56:42Z",
          "updatedAt": "2020-05-29T20:56:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it should also stay separate.",
          "createdAt": "2020-05-29T22:34:24Z",
          "updatedAt": "2020-05-29T22:34:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Are we OK leaving Section 4.1 as-is?",
          "createdAt": "2020-06-01T00:58:08Z",
          "updatedAt": "2020-06-01T00:58:08Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The description of sgn0 deserves its own section.",
          "createdAt": "2020-06-01T16:38:43Z",
          "updatedAt": "2020-06-01T16:38:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MzAzNDU3",
      "title": "Highlighting L value.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/269",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Makes the L parameter easier to find.",
      "createdAt": "2020-05-29T20:07:43Z",
      "updatedAt": "2020-05-29T20:38:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "094784ed6e314b1c4d1cf075d44c23f998113f86",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sug/HighlightL",
      "headRefOid": "474422c30c5b44c555e30ff7d6a143bc394957e4",
      "closedAt": "2020-05-29T20:38:52Z",
      "mergedAt": "2020-05-29T20:38:52Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "34e1f06b8dc81682953f7e93057db804ab0b2db2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 270,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MzUwNjQ2",
      "title": "Suites on Table 2.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/270",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Table 2 can also lists the suites recommended for each curve.\r\nThe line right before the table can be rewritten, suggestions? \r\n",
      "createdAt": "2020-05-29T21:56:38Z",
      "updatedAt": "2020-05-30T00:07:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "34e1f06b8dc81682953f7e93057db804ab0b2db2",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sug/Tab8",
      "headRefOid": "2cd4b6cc6754ae7b9d330a36563258edf83f2a97",
      "closedAt": "2020-05-30T00:07:35Z",
      "mergedAt": "2020-05-30T00:07:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c1582256394e58a89a71f1d7b09f245a05dd6f5a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzI2MjUx",
          "commit": {
            "abbreviatedOid": "ceb07cd"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this is a great idea! One small comment.",
          "createdAt": "2020-05-29T22:14:38Z",
          "updatedAt": "2020-05-29T22:15:21Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "It might be nice to break these up into separate lines in the table: one line for curve25519 that lists relevant suites, one for edwards25519, etc.",
              "createdAt": "2020-05-29T22:14:38Z",
              "updatedAt": "2020-05-29T22:38:59Z"
            },
            {
              "originalPosition": 27,
              "body": "Here, maybe separate \"BLS12-381 G1\" and \"BLS12-381 G2\" lines?",
              "createdAt": "2020-05-29T22:15:01Z",
              "updatedAt": "2020-05-29T22:38:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzMyNTYw",
          "commit": {
            "abbreviatedOid": "ceb07cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-29T22:33:46Z",
          "updatedAt": "2020-05-29T22:33:51Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'd swap the Section and Suites columns, too, to match this sentence. Namely, each table row identities a curve, the suite, and a pointer to more details.",
              "createdAt": "2020-05-29T22:33:47Z",
              "updatedAt": "2020-05-29T22:38:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzU1MzQ4",
          "commit": {
            "abbreviatedOid": "2cd4b6c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-30T00:05:51Z",
          "updatedAt": "2020-05-30T00:05:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzU1NjA5",
          "commit": {
            "abbreviatedOid": "2cd4b6c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-30T00:07:29Z",
          "updatedAt": "2020-05-30T00:07:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MzU2OTc4",
      "title": "suggested edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/272",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here are my suggested edits for everything through the relwork section.",
      "createdAt": "2020-05-29T22:16:32Z",
      "updatedAt": "2020-06-01T00:58:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "c1582256394e58a89a71f1d7b09f245a05dd6f5a",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "rsw_edits",
      "headRefOid": "d176640eb1e7122de14ffdcce84b4e792ee6e563",
      "closedAt": "2020-06-01T00:56:00Z",
      "mergedAt": "2020-06-01T00:56:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9b15875a9aba00b5891aca490876057f8bef9c20"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, this is now rebased.",
          "createdAt": "2020-05-30T00:12:53Z",
          "updatedAt": "2020-05-30T00:12:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I made some more edits to address the protocol/application concern. In the process I ended up revising the 'random oracle encodings' definition, because it wasn't quite correct.\r\n\r\nI ended up removing the SHOULD language from the definition, because it doesn't seem like a definitions section is the right place to state requirements, but I'm happy to put back those sentences if you'd prefer.",
          "createdAt": "2020-05-31T19:18:42Z",
          "updatedAt": "2020-05-31T19:18:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam shall we merge? :)",
          "createdAt": "2020-06-01T00:55:04Z",
          "updatedAt": "2020-06-01T00:55:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me :)",
          "createdAt": "2020-06-01T00:55:27Z",
          "updatedAt": "2020-06-01T00:55:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm nearly done with my pass, too. I'll submit a PR for that when complete!",
          "createdAt": "2020-06-01T00:56:15Z",
          "updatedAt": "2020-06-01T00:56:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzMzNDM0",
          "commit": {
            "abbreviatedOid": "94cd4f9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM so far!",
          "createdAt": "2020-05-29T22:36:47Z",
          "updatedAt": "2020-05-29T22:37:33Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Reading this piece out of context, I wonder if someone might conclude, \"oh, so if I don't want constant time, I can ignore these steps.\" The previous text made it clear that this is necessary \"for security reasons.\" Maybe we can bring that back by saying, \"Each function MUST be implemented in constant time. To do so, all field operations...\"?",
              "createdAt": "2020-05-29T22:36:47Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 132,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-05-29T22:37:16Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzM4NjA4",
          "commit": {
            "abbreviatedOid": "94cd4f9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "some suggestions",
          "createdAt": "2020-05-29T22:54:22Z",
          "updatedAt": "2020-05-29T23:13:59Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "> Most cryptographic protocols operate on G.\r\n\r\nIt is also important to say that G is the destination group rather than E.",
              "createdAt": "2020-05-29T22:54:22Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 112,
              "body": "Does the document needs to warn implementers something along the lines\r\n\"do not be tempted to chose encode_to_curve over hash_to_curve due its performance\" ?\r\n",
              "createdAt": "2020-05-29T23:01:52Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 132,
              "body": "We should also give credit to {{BCIMRT10}} as it was proposed earlier.",
              "createdAt": "2020-05-29T23:04:49Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 144,
              "body": "It this more accurate?\r\n\r\n```suggestion\r\nCryptographic protocols proven secure in the random oracle model are often analyzed\r\n```",
              "createdAt": "2020-05-29T23:08:09Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 287,
              "body": "```suggestion\r\n    calls sqrt also specifies how to determine the correct root.\r\n```",
              "createdAt": "2020-05-29T23:12:31Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzQ0ODE3",
          "commit": {
            "abbreviatedOid": "440b518"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:17:53Z",
          "updatedAt": "2020-05-29T23:17:53Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Good point. I was intending to flag this edit as something we should discuss:\r\n\r\nI'm not convinced it makes sense to say that implementations MUST be constant time, for a few reasons. First, it's not always the case that protocols require constant-time implementations, which I think implies SHOULD rather than must. Second, it's not obvious what it means to require something like this---do we mean that one is just not allowed to implement hash-to-curve in (say) Python, where it's basically impossible to guarantee constant time? (In this case, our reference implementations aren't technically conforming!)",
              "createdAt": "2020-05-29T23:17:53Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzQ1NzA4",
          "commit": {
            "abbreviatedOid": "440b518"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:21:41Z",
          "updatedAt": "2020-05-29T23:21:41Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Related to the above: in other places in the document it seems like we're more ambivalent about SHOULD vs MUST for constant time. So if we decide that this will be a MUST rather than a SHOULD, we should (must? :smile:) do a sweep for consistency.",
              "createdAt": "2020-05-29T23:21:41Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzQ2Mzg3",
          "commit": {
            "abbreviatedOid": "92c1a82"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:24:26Z",
          "updatedAt": "2020-05-29T23:24:27Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "See also the very first sentence of security considerations:\r\n\r\n    When constant-time implementations are required, all basic operations and\r\n    utility functions must be implemented in constant time, as discussed in\r\n    {{utility}}.",
              "createdAt": "2020-05-29T23:24:27Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzUwNDAx",
          "commit": {
            "abbreviatedOid": "0dd655c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:41:49Z",
          "updatedAt": "2020-05-29T23:41:50Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "The reason I suggested this change is that it seems like talking about G as a destination for an encoding is use-before-def: we haven't defined the term encoding or mapping yet.",
              "createdAt": "2020-05-29T23:41:49Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzUwNTAy",
          "commit": {
            "abbreviatedOid": "0dd655c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:42:12Z",
          "updatedAt": "2020-05-29T23:42:13Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Sorry, this was a bad edit on my part. I put the sentence back.",
              "createdAt": "2020-05-29T23:42:13Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzUwNTY3",
          "commit": {
            "abbreviatedOid": "0dd655c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:42:32Z",
          "updatedAt": "2020-05-29T23:42:32Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "I pushed another commit that addresses this.",
              "createdAt": "2020-05-29T23:42:32Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzUxMjYx",
          "commit": {
            "abbreviatedOid": "6b08f37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:45:51Z",
          "updatedAt": "2020-05-29T23:45:52Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "hmm, I think you're right. I will revert.",
              "createdAt": "2020-05-29T23:45:51Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzUyMDc2",
          "commit": {
            "abbreviatedOid": "8e51acc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T23:49:38Z",
          "updatedAt": "2020-05-29T23:49:38Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Thinking about this more: it seems like it might make sense to add or expand a paragraph in the Security Considerations section to address constant timeness.",
              "createdAt": "2020-05-29T23:49:38Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzU1MTMy",
          "commit": {
            "abbreviatedOid": "77907cc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-30T00:04:50Z",
          "updatedAt": "2020-05-30T00:04:51Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Just pushed a slightly expanded discussion in security considerations.",
              "createdAt": "2020-05-30T00:04:50Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzU5Mjg2",
          "commit": {
            "abbreviatedOid": "14fadee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Nice set of changes! I only have a few clarifying questions and comments.",
          "createdAt": "2020-05-30T00:31:21Z",
          "updatedAt": "2020-05-30T00:35:38Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "We include an examples of how to compute is_square and inv0 in constant time using -- why drop the example here?",
              "createdAt": "2020-05-30T00:31:21Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 337,
              "body": "Did this not render correctly for you? It was fine in the txt and html files for me.",
              "createdAt": "2020-05-30T00:31:50Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 437,
              "body": "```suggestion\r\nIt is important to note that using a nonuniform encoding or directly\r\n```",
              "createdAt": "2020-05-30T00:32:16Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 442,
              "body": "Unrelated to this change, but we should probably unify on terminology regarding the callers of hash-to-curve: we use applications and protocols in different places. I prefer applications, as it's more general and includes protocols. ",
              "createdAt": "2020-05-30T00:33:29Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 458,
              "body": "Should we reference {{VR20}} again here (or after \"for security against timing attacks\" below)?",
              "createdAt": "2020-05-30T00:33:46Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 520,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-05-30T00:34:31Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzU5OTc5",
          "commit": {
            "abbreviatedOid": "14fadee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-30T00:36:33Z",
          "updatedAt": "2020-05-30T00:36:34Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "The new text works for me!",
              "createdAt": "2020-05-30T00:36:33Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzYzOTYw",
          "commit": {
            "abbreviatedOid": "14fadee"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-30T01:08:35Z",
          "updatedAt": "2020-05-30T01:08:35Z",
          "comments": [
            {
              "originalPosition": 337,
              "body": "I think this one rendered correctly, but then I went through and removed all the escapes and some of them didn't render correctly (I think kramdown thought they were starting tables or something weird). So then I went back through and escaped all of them because I wasn't sure which ones would work and which ones wouldn't...",
              "createdAt": "2020-05-30T01:08:35Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzY0MzY3",
          "commit": {
            "abbreviatedOid": "b058c68"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-30T01:12:35Z",
          "updatedAt": "2020-05-30T01:15:18Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Ah, I actually didn't realize it was intended as an example. When I read through this it seemed like a low-level implementation detail rather than an example. Also, I'm pretty sure at this point all of the uses of CMOV in the document actually pass in a boolean value, which means it's not necessary to describe the case where there's a bitstring C rather than a boolean c. I can double check this...",
              "createdAt": "2020-05-30T01:12:35Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 442,
              "body": "Good point. Opened #273.",
              "createdAt": "2020-05-30T01:13:35Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzc4NTc5",
          "commit": {
            "abbreviatedOid": "695bcc9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-30T05:00:09Z",
          "updatedAt": "2020-05-30T05:00:10Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "I went back and checked. Every use of CMOV in this document takes a boolean value as its third operand, so there shouldn't be any need for the extra explanation that I cut here. We could still bring it back if you want, but it does not seem necessary given the rest of the text.",
              "createdAt": "2020-05-30T05:00:09Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDkzMDI2",
          "commit": {
            "abbreviatedOid": "fb289e9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "All of these changes look good, I'm just not sure we've landed on the right application/protocol split yet. The choice appears arbitrary in some places. (I'm sure they were intentional, I just don't understand the intention! We also don't need to block on that, so I'm approving to move us forward.)",
          "createdAt": "2020-05-31T13:07:22Z",
          "updatedAt": "2020-05-31T13:14:54Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "I feel like this should be \"protocols\", given that the choice of which is made by \"protocol designers\" (below).",
              "createdAt": "2020-05-31T13:07:22Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 293,
              "body": "\ud83d\udc4d Thanks! I think this was leftover from a previous draft where the value was non-binary. ",
              "createdAt": "2020-05-31T13:09:35Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 369,
              "body": "We use \"protocol designers\" above and \"application designers\" here -- why the difference?",
              "createdAt": "2020-05-31T13:10:21Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 391,
              "body": "We flip from using applications before the suite details, to protocols after. I don't understand the difference. (A protocol whose security depends on hash-to-curve is an application of hash-to-curve, in my view.)",
              "createdAt": "2020-05-31T13:12:28Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            },
            {
              "originalPosition": 393,
              "body": "And we use applications here. ",
              "createdAt": "2020-05-31T13:12:45Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTIwNTAz",
          "commit": {
            "abbreviatedOid": "89c49de"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-31T19:17:02Z",
          "updatedAt": "2020-05-31T19:17:03Z",
          "comments": [
            {
              "originalPosition": 391,
              "body": "I revisited this with fresh eyes and pushed some more edits.",
              "createdAt": "2020-05-31T19:17:02Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTIwNTE2",
          "commit": {
            "abbreviatedOid": "89c49de"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-31T19:17:10Z",
          "updatedAt": "2020-05-31T19:17:11Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "Revisited this, too.",
              "createdAt": "2020-05-31T19:17:10Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTQ2MzEw",
          "commit": {
            "abbreviatedOid": "89c49de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-01T00:50:32Z",
          "updatedAt": "2020-06-01T00:50:32Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "```suggestion\r\noracles are instantiated based on one underlying function H.\r\n```",
              "createdAt": "2020-06-01T00:50:32Z",
              "updatedAt": "2020-06-01T00:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTQ2Mzgz",
          "commit": {
            "abbreviatedOid": "0e7974d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest text looks good!",
          "createdAt": "2020-06-01T00:51:03Z",
          "updatedAt": "2020-06-01T00:51:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NzAzNDUx",
      "title": "Pass up to related work",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/274",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'll finish the rest this evening!",
      "createdAt": "2020-06-01T01:16:44Z",
      "updatedAt": "2022-02-18T16:42:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "9b15875a9aba00b5891aca490876057f8bef9c20",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/remainder",
      "headRefOid": "4914182604706c872f38b9fdb5b0b04c06db65d1",
      "closedAt": "2020-06-01T18:21:42Z",
      "mergedAt": "2020-06-01T18:21:42Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "c8f7cfc0d9c8a69398370f56b86b0dda3ee27187"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~:+1: I'll get on this first thing in the morning.~\r\n\r\nOK fine couldn't resist :)",
          "createdAt": "2020-06-01T06:42:11Z",
          "updatedAt": "2020-06-01T06:53:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNjI1MzM2",
          "commit": {
            "abbreviatedOid": "a880bbf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great edits. Just a few small nits.",
          "createdAt": "2020-06-01T06:44:40Z",
          "updatedAt": "2020-06-01T06:53:41Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The \"we set\" made clear that this was a decision, whereas the proposed wording feels like it implies that \"sgn0(y) == sgn0(u)\" follows from \"u and -u give the same x-coordinate\". Is it possible to recover the explicit we-made-this-decision statement?",
              "createdAt": "2020-06-01T06:44:40Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            },
            {
              "originalPosition": 48,
              "body": "Same as prior comment---can we keep explicit that this is a decision?",
              "createdAt": "2020-06-01T06:44:58Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            },
            {
              "originalPosition": 67,
              "body": "\"The prime-order (sub)group of the curve\" reads like there's only one, but that might not be true. Would it make sense to make an explicit reference to G?\r\n\r\n```suggestion\r\nprime-order (sub)group G ({{bg-curves}}).\r\n```",
              "createdAt": "2020-06-01T06:47:26Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            },
            {
              "originalPosition": 89,
              "body": "Hmm... I think the original intent of this sentence really was about collision resistance. For example, it wouldn't be great to use a hash with 160-bit output (i.e., 80-bit collision resistance) for a cryptosystem targeting 128-bit security.\r\n\r\nOn the other hand, not totally clear to me that domain separation is a huge issue here since H isn't being used as a random oracle and the password is secret from the adversary.\r\n\r\nI think maybe it makes sense to keep \"collision resistance\" and fix the target of the link... thoughts?\r\n\r\n```suggestion\r\nFor collision resistance, the hash underlying the key derivation function\r\nshould be chosen according to the guidelines listed in {{hashtofield-expand-xmd}}.\r\n```",
              "createdAt": "2020-06-01T06:52:51Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxODE3ODI0",
          "commit": {
            "abbreviatedOid": "a880bbf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-01T12:52:44Z",
          "updatedAt": "2020-06-01T12:52:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yep, that's fine. I'll revert it.",
              "createdAt": "2020-06-01T12:52:44Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxODE3ODgx",
          "commit": {
            "abbreviatedOid": "a880bbf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-01T12:52:48Z",
          "updatedAt": "2020-06-01T12:52:49Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Same!",
              "createdAt": "2020-06-01T12:52:48Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxODE5MzQw",
          "commit": {
            "abbreviatedOid": "ef95468"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-01T12:55:13Z",
          "updatedAt": "2020-06-01T12:55:13Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "It was the link that made me think we meant something else, so we can update it. That said, should we not *also* mention domain separation here, as any KDF will surely have a hash that likely ought to be domain separated, too. ",
              "createdAt": "2020-06-01T12:55:13Z",
              "updatedAt": "2020-06-01T16:27:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDAyNDgx",
          "commit": {
            "abbreviatedOid": "4914182"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like these changes.",
          "createdAt": "2020-06-01T16:36:46Z",
          "updatedAt": "2020-06-01T16:36:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDcxOTQ5",
          "commit": {
            "abbreviatedOid": "4914182"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-01T18:15:55Z",
          "updatedAt": "2020-06-01T18:15:55Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Probably not necessary to use domain separation there because the password input to the KDF is secret. In particular, for something like PBKDF2 or scrypt the password is used as the key for an HMAC invocation. As long as the password is secret life is fine, by a similar argument to the one we give in the domain separation recommendations.",
              "createdAt": "2020-06-01T18:15:55Z",
              "updatedAt": "2020-06-01T18:20:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDc1NjY0",
          "commit": {
            "abbreviatedOid": "4914182"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-01T18:21:34Z",
          "updatedAt": "2020-06-01T18:21:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDc5MjI2",
          "commit": {
            "abbreviatedOid": "4914182"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-01T18:26:49Z",
          "updatedAt": "2020-06-01T18:26:50Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Oh, that's a good point. Never mind then!",
              "createdAt": "2020-06-01T18:26:50Z",
              "updatedAt": "2020-06-01T18:27:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI2MjAwNDA4",
      "title": "edits from offline conversation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/275",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-01T20:34:38Z",
      "updatedAt": "2020-06-01T21:14:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "c8f7cfc0d9c8a69398370f56b86b0dda3ee27187",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw_questions",
      "headRefOid": "e58fb0a04a46addfac783f6d1f00d8e7c3bd0008",
      "closedAt": "2020-06-01T20:42:01Z",
      "mergedAt": "2020-06-01T20:42:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cf6327c7725269a1c95c68e16f809198305f2b1c"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-06-01T20:41:56Z",
          "updatedAt": "2020-06-01T20:41:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMTY2MTI0",
          "commit": {
            "abbreviatedOid": "e58fb0a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-01T20:41:51Z",
          "updatedAt": "2020-06-01T20:41:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 276,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI2MjI0Mjgz",
      "title": "add one test vector",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/276",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds one extra test vector. With this new vector, all of the gx1/gx2 branches are covered in all suites.\r\n\r\nI'm explicitly not trying to cover branches in exceptional cases or in choosing sign of y. For exceptional cases, it's infeasible to find inputs that trigger the cases (we test our code by generating inputs for the map functions rather than the end-to-end hash function). For sign of y, the branch taken depends on the sqrt implementation, so it's not clear to me that it makes sense to try and cover these.",
      "createdAt": "2020-06-01T21:28:23Z",
      "updatedAt": "2020-06-01T21:56:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "cf6327c7725269a1c95c68e16f809198305f2b1c",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "add_one_vector",
      "headRefOid": "b3cd2213b5358a4ea8cc864fe7ed2ed1144d5f7c",
      "closedAt": "2020-06-01T21:55:43Z",
      "mergedAt": "2020-06-01T21:55:43Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "48361fc663dd5dbea585d0871a4f39fba4247a07"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way, I took a super simple approach to this, which I've stored in my [test_vector_coverage](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/tree/test_vector_coverage) branch.\r\n\r\nI don't think we should pull the changes in that branch into the master branch, because I think we'd rather have the code in `poc/` be as close as possible to mechanically translated from the code listings in the document (currently that is how all of the `*_generic.sage` files are done).",
          "createdAt": "2020-06-01T21:33:02Z",
          "updatedAt": "2020-06-01T21:33:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> By the way, I took a super simple approach to this, which I've stored in my test_vector_coverage branch.\r\n\r\nHah! I like it. \r\n\r\n> I don't think we should pull the changes in that branch into the master branch, because I think we'd rather have the code in poc/ be as close as possible to mechanically translated from the code listings in the document (currently that is how all of the *_generic.sage files are done).\r\n\r\nAgreed. It's cute, but a bit cumbersome.",
          "createdAt": "2020-06-01T21:35:13Z",
          "updatedAt": "2020-06-01T21:35:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam the test vector is fine. Out of curiosity, how'd you pick it? Did you just try some random things and check the resulting coverage?",
          "createdAt": "2020-06-01T21:36:45Z",
          "updatedAt": "2020-06-01T21:36:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Yup, exactly. Found something that worked on the second or third guess. I suppose we could try to find a smaller one...",
          "createdAt": "2020-06-01T21:39:49Z",
          "updatedAt": "2020-06-01T21:40:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suppose we could try to find a smaller one...\r\n\r\nNah, I think it's fine as is. :)",
          "createdAt": "2020-06-01T21:40:09Z",
          "updatedAt": "2020-06-01T21:40:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjAxMzI5",
          "commit": {
            "abbreviatedOid": "b3cd221"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-01T21:39:50Z",
          "updatedAt": "2020-06-01T21:39:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjA0MzM0",
          "commit": {
            "abbreviatedOid": "b3cd221"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "NIce",
          "createdAt": "2020-06-01T21:45:14Z",
          "updatedAt": "2020-06-01T21:45:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MTM2MzM5",
      "title": "Updates reference implementations to draft-v08",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/277",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Updates pointers to reference implementations both go and rust.",
      "createdAt": "2020-06-04T23:14:00Z",
      "updatedAt": "2021-04-21T17:21:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "256dd6983f8ca9f4ce93eafcc1ec36269b3b8937",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "updateRefImpl08",
      "headRefOid": "99e6e30b3ac6081ebfc6ffc5f64582644c85d62e",
      "closedAt": "2020-06-04T23:29:16Z",
      "mergedAt": "2020-06-04T23:29:16Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "ead9c9110b9b5eb611c1e6f6daeb7ed8c5cdd22c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0NjkxNzU2",
      "title": "Export curve paramters (for code reuse).",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/278",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes it easier to use this code as a submodule without for other reference implementations (VOPRF).",
      "createdAt": "2020-06-15T18:06:11Z",
      "updatedAt": "2022-02-18T16:42:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "ead9c9110b9b5eb611c1e6f6daeb7ed8c5cdd22c",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/export-parameters",
      "headRefOid": "63b03df1c0abdfdffc660e362d465ef7fc7fe2af",
      "closedAt": "2020-06-15T20:47:42Z",
      "mergedAt": "2020-06-15T20:47:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d19b27740c0c7aed45e9d9336786986edb53433b"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I'll work with this as is and tweak as needed if it becomes to burdensome to import each parameter individually.",
          "createdAt": "2020-06-15T20:47:38Z",
          "updatedAt": "2020-06-15T20:47:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTU1MTE5",
          "commit": {
            "abbreviatedOid": "63b03df"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me!\r\n\r\nAs we discussed via email, it might eventually make sense to collect all of these in one file that this and other code can import. Maybe using NamedTuples?",
          "createdAt": "2020-06-15T20:06:20Z",
          "updatedAt": "2020-06-15T20:06:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0ODAyNjc1",
      "title": "respond to comments from Thomas Pornin",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/282",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR includes responses to most of the comments from Thomas Pornin's review for the crypto panel.\r\n\r\nIn the next comment in this thread I will quote Thomas's email and my responses to each point. There are a few cases (marked \"???\") where it's either not clear to me what the comment meant or it's otherwise not obvious how to respond. Let's discuss in this thread and I'll make edits as necessary.",
      "createdAt": "2020-06-15T21:16:28Z",
      "updatedAt": "2020-06-16T19:22:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "c09a3368610f5c7e420db0a42d9ee970d51f27a4",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "crypto_review_panel",
      "headRefOid": "e2eaf1c86cd4dab7d953f7bba4c7e7fbe5e45294",
      "closedAt": "2020-06-16T18:03:58Z",
      "mergedAt": "2020-06-16T18:03:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f028204795218e1c9bc14356957b5562062b84c9"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> A generic remark: there is not a word about intellectual property\r\n> issues. I understand that this is a contentious issue, and that nobody\r\n> wants to assert that any specific method is patent-free. But I would\r\n> have expected a disclaimer somewhere. Otherwise, it feels weird that\r\n> Icart's map is not used as a possible method, since, when p^m = 2 mod 3,\r\n> it should be faster than the simplified SWU (it uses one inversion\r\n> and one cube root, no extra is_square() or similar).\r\n> (Also, I heard some rumours that simplified SWU is also patented,\r\n> albeit with a less proactively enforced patent. The same rumours say\r\n> that the original Shallue-van de Woestijne method is patent-free. These\r\n> are only rumours.)\r\n\r\n???\r\n\r\nI think the IPR disclosures handle this. Should double check whether\r\nthis is true, and what the policy is regarding IPR discussion in the draft\r\nitself. (I seem to recall that this is discouraged.)\r\n\r\n> 2.1 (page 6): Maybe note that there are multiple choices for the\r\n> representation of GF(p^m) as polynomials: any irreducible modulus M (of\r\n> degree m) is fine (all finite fields with the same cardinal are\r\n> isomorphic to each other), but no M is more canonical than any other.\r\n> Choice of M is often driven by implementation performance (some M lead\r\n> to faster code).\r\n\r\n???\r\n\r\nNot clear that this is within the scope of the document, since right\r\nnow we're not talking about the modulus M at all.\r\n\r\n> 2.1 (page 6): \"elements are those points with coordinates (x, y)\r\n> satisfying the curve equation\": some curves (in particular Weierstra\u00df\r\n> and Montgomery curves) also include a special point-at-infinity which\r\n> does not have coordinates (x, y).\r\n\r\nDone.\r\n\r\n> 2.2.2 (page 8): \"Section 10 discusses further.\" -> This lacks a\r\n> complement. Maybe: \"See section 10 for further discussion.\"?\r\n\r\nDone.\r\n\r\n> 2.2.5 (page 9): Concatenation can be ambiguous, i.e.\r\n>    \"RO10\" || x == \"RO1\" || (\"0\" || x)\r\n> The actual usage (in section 5.3) uses explicit length bytes, and\r\n> also puts the tag _after_ the message, not before. It might be worth\r\n> mentioning here that the \"concatenation\" operation must be an\r\n> injective encoding of the tag and input x, with a forward reference\r\n> to section 5.3 for details (especially 5.3.4).\r\n\r\nDone.\r\n\r\n> 3.1 (page 12): The text fluidly and implicitly equates character strings\r\n> and byte strings. Java and C#/.NET developers might take issue with\r\n> that. This might be worth an explicit sentence here; otherwise, some\r\n> developer somewhere will use UTF-16 (and calling it \"Unicode\" in pure\r\n> Microsoft fashion), others will add a terminating zero, or use\r\n> big-endian, or add a BOM, or any combination thereof, and much confusion\r\n> and interoperability sorrow will ensue.\r\n\r\nDone.\r\n\r\n> 4 (page 12): \"SHOULD be constant time\" -> \"SHOULD be constant-time\".\r\n\r\n\"constant time\" should be hyphenated only when it's used as an adjective. The hyphen in \"constant-time X\" is to clarify that \"constant\" modifies \"time,\" not \"X.\" I've swept the document for consistency.\r\n\r\n> Also, the traditional acception of \"constant-time\" covers more than\r\n> independence of the execution time with regard to the input values:\r\n> \r\n>   - It really is independence with regard to all secret values, including\r\n>     intermediate values and outputs, not just inputs.\r\n> \r\n>   - Constant-time code should not leave any trace that can be leveraged\r\n>     with time-based measurements. For instance, in a flush+reload\r\n>     attack, the victim's execution time is independent of the secret\r\n>     values; the timing measurement is on a reload operation performed by\r\n>     the attacker themselves, _after_ the victim has finished. Code which\r\n>     is vulnerable to a flush+reload attack may still be \"constant-time\"\r\n>     in the sense described by section 4, but would not be\r\n>     \"constant-time\" in the usual sense.\r\n> \r\n> I think a more generic definition of \"constant-time\" is needed here. I\r\n> suggest the following: \"For security, implementations of these functions\r\n> SHOULD be constant-time, i.e. none of the possible timing measurements\r\n> that can be effected by an adversary should depend on secret values. In\r\n> particular, execution time but also memory access patterns should be\r\n> independent of any secret input, output or intermediate value.\"\r\n\r\nDone, with a slightly trimmed-down version of the suggested text.\r\n\r\n> 4 (page 13): \"there exist two roots of x in the field F whenever x is\r\n> square.\" -> except when x = 0. Zero has a unique square root in F.\r\n\r\nDone.\r\n\r\n> 4 (page 13): \"To implement inv0 in constant time, compute inv0(x) :=\r\n> x^(q-2)\" -> Depending on the field, there may be (much) faster ways, in\r\n> particular in field extensions (e.g. in Curve9767, inversion cost is\r\n> about 6M, while Fermat's Little Theorem would bring it to about 300M!).\r\n> Even in prime fields, a constant-time extended binary GCD will typically\r\n> have cost between 40M and 100M for inversion (but some specific care is\r\n> required to ensure that inv0(0) = 0). However, it must be said that the\r\n> exponentiation is a simple to implement in constant-time if\r\n> constant-time multiplication is available (and it should, otherwise the\r\n> whole thing is hopeless).\r\n\r\nGood point. Added a note saying that this is possible, but further discussion\r\nis beyond the scope.\r\n\r\n> 4 (page 13): It may be worth mentioning that I2OSP and OS2IP, as defined\r\n> in PKCS#1 (aka RFC 8017), are big-endian. In particular, most of the\r\n> curve25519/edwards25519 ecosystem tends to be little-endian, so that's a\r\n> plausible source of mistakes.\r\n\r\nDone.\r\n\r\n> 5 (page 5): The draft uses \"SHAKE-128\" as the name of SHAKE with a\r\n> 128-bit output, but the NIST specification (FIPS 202) defines \"SHAKE128\"\r\n> without the dash. This impacts the use of the name in IDs (e.g. in\r\n> section 8.10, page 43).\r\n\r\nDone.\r\n\r\n> 5.2 (page 17): Maybe note somewhere that implementation of \"mod p\" with\r\n> constant-time code is not completely obvious. Using Euclidean division\r\n> is not constant-time. Most constant-time implementations use Barrett\r\n> reduction, although some use Montgomery instead.\r\n\r\n???\r\n\r\nWe note that this is needed in Utility. Should we note again here?\r\n\r\n> 5.2 (page 17): When mapping to a field GF(p^m) with a relatively small p\r\n> (e.g. less 32 bits), then the proposed hash_to_field() is rather\r\n> wasteful in hash output. For such fields, generating k+log2(p^m) bits\r\n> and then repeatedly dividing that big integer by p will be faster,\r\n> especially when working on embedded systems. On an ARM Cortex M0+, with\r\n> field GF(9767^19), I can get a map_to_field() in about 20000 cycles,\r\n> while each invocation of the SHAKE internal function costs 34000 cycles\r\n> and the proposed method would require three invocations of that internal\r\n> function to get enough bytes.\r\n\r\nAdded appx discussing the alternative function.\r\n\r\n> 5.3.1 (page 18): I needed to verify, but \"Damgaard\" is indeed the\r\n> correct ASCII-compatible alternative spelling of \"Damg\u00e5rd\". Nice job!\r\n\r\n:)\r\n\r\n> 5.3.1 (page 19): Definition of b_in_bytes uses ceil(), i.e. accounts for\r\n> the possibility that H outputs something else than an integral number\r\n> of bytes. But if that is the case, the \"uniform_bytes\" are not uniform!\r\n> It would be better to make it an explicit requirement that the output\r\n> length of H, in bits, MUST be a multiple of 8.\r\n\r\nDone (thanks to @armfazh's clarification :+1:)\r\n\r\n> 5.3.1 (page 19): r_in_bytes is said to be the \"block size\" of a hash\r\n> function, but that notion has not been defined. Generally speaking, some\r\n> hash functions do not have a well-defined \"block size\". You may fall\r\n> back here on HMAC, since HMAC also needs a \"block size\"; for instance,\r\n> FIPS 202 defines the block size of SHA3-256 to be 136 bytes.\r\n\r\nDone.\r\n\r\n> 5.3.4 (page 21): \"prepended or appended\" -> technically, \"prepended\" is\r\n> an actual English word, but not with that meaning. It means something\r\n> like \"premeditate\". I suggest: \"an encoding of DST MUST be added either\r\n> as a prefix or suffix to the input to each invocation of H (a suffix is\r\n> the RECOMMENDED approach).\"\r\n\r\nDone, and swept the document for other uses of prepend.\r\n\r\n> 6.6.1 (page 25): It may be worth mentioning that some of the computed\r\n> values are actually constants, e.g. tv4 (step 5) or -4*g(Z)/(3*Z^2+4*A)\r\n> (used in step 10) (this is applied in appendix D.1). In effect, the\r\n> \"expensive\" operations in this algorithm that cannot be precomputed are\r\n> 1 inv0(), 2 is_square(), and 1 sqrt(). This makes it apparent that the\r\n> speed advantage of the simplified SWU map is that it saves 1 is_square()\r\n> call, i.e. about 25% of the overall cost if inv0(), is_square() and\r\n> sqrt() are implemented with modular exponentiations.\r\n\r\nDone.\r\n\r\n> 10 (page 45): for password hashing, discussion points to PBKDF2 and\r\n> Scrypt. It might be worth mentioning Argon2, for which there is an\r\n> in-progress draft:\r\n>    https://datatracker.ietf.org/doc/draft-irtf-cfrg-argon2/\r\n\r\nDone.\r\n\r\n> 10 (page 45): \"the nature of the leakage and the appropriate defense\r\n> depends on the application.\" -> should be \"depend\" here.\r\n\r\nDone.\r\n\r\n> E.1 (page 75): It may be worth mentioning here that the random oracle\r\n> mapping requires doing two map_to_curve() and adding the results\r\n> together, and this is, in itself, enough to make projective coordinates\r\n> useful. In particular, when using a Weierstra\u00df curve, you must take into\r\n> account the (remote) possibility that the two points may be the same,\r\n> therefore requiring a constant-time generic point addition routine;\r\n> there are complete formulas for Weierstra\u00df curves in homogenous\r\n> projective coordinates.\r\n\r\nDone.\r\n\r\n> G.5 (page 96): \"Other optimizations of this type are possible in other\r\n> even-order extension fields\" -> You can also have similar optimizations\r\n> in any extension field. In general, for an odd p and an arbitrary m > 1:\r\n> \r\n>       (p-1)/2 = ((p-1)/2)*(1+p+p^2+...+p^(m-1))\r\n> \r\n> Thus, if we call r = 1+p+p^2+...+p^(m-1), we have:\r\n> \r\n>       x^((p-1)/2) = (x^r)^((p-1)/2)\r\n> \r\n> This can be computed very efficiently because:\r\n> \r\n>   - x^r is an element of GF(p) (indeed, (x^r)^(p-1) = 1 for any x != 0,\r\n>     and only elements of GF(p) are roots of the polynomial X^(p-1)-1 in\r\n>     GF(p^m)[X]), so the final exponentiation by (p-1)/2 can be done with\r\n>     only values in the small field GF(p).\r\n> \r\n>   - x^r can be computed in log(m) multiplications and log(m) applications\r\n>     of the Frobenius operator:\r\n> \r\n>       t1 = x * x^p = x^(1+p)\r\n>       t2 = t1 * t1^(p^2) = x^(1+p+p^2+p^3)\r\n>       t3 = t2 * t2^(p^4) = x^(1+p+p^2+p^3+p^4+p^5+p^6+p^7)\r\n>       ...\r\n> \r\n>     The Frobenius operator itself is typically as efficient, or even\r\n>     faster, as a multiplication, since it is a linear transform over the\r\n>     source polynomial (seen as a vector in a space of dimension m over\r\n>     GF(p)). If GF(p^m) was defined modulo M = X^m-c for some constant c,\r\n>     then the Frobenius operator is a simple per-coefficient\r\n>     multiplication, i.e. a cost close to that of an addition in GF(p^m).\r\n> \r\n> The algorithm in appendix G.5 is a simple sub-case of this, when m = 2.\r\n\r\n???\r\n\r\nFor now, just made clear that this is not restricted to even-order\r\nextensions. Is it worth documenting this trick here, should we write it\r\ndown in a separate document, is there a cite we can add, or should we\r\ndo something else?",
          "createdAt": "2020-06-15T21:18:04Z",
          "updatedAt": "2020-06-16T02:21:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I also made an edit that closes #281 in this PR, clarifying that the reason for MUST NOT is that rejection sampling rules out (reasonable) constant-time impls. Constant-time impls aren't required, but they should always be *possible*.",
          "createdAt": "2020-06-15T21:51:31Z",
          "updatedAt": "2020-06-15T21:51:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with all of your responses, @kwantam! Below are my thoughts on the unclear feedback items.\r\n\r\n> I think the IPR disclosures handle this. Should double check whether this is true, and what the policy is regarding IPR discussion in the draft itself. (I seem to recall that this is discouraged.)\r\n\r\nLet's follow up with the chairs and see what they'd like us to do?\r\n\r\n> Not clear that this is within the scope of the document, since right now we're not talking about the modulus M at all.\r\n\r\nMaybe we can just note that our choice of basis does not change as a function of the irreducible? (That is, we always use a polynomial basis, rather than, say, a normal basis, regardless of the polynomial.) I agree this is not really in scope, but maybe clarity here doesn't hurt.\r\n\r\n> For now, just made clear that this is not restricted to even-order extensions. Is it worth documenting this trick here, should we write it down in a separate document, is there a cite we can add, or should we do something else?\r\n\r\nI'd say let's leave it out for now. Optimizations at this stage seem to be scope creep.",
          "createdAt": "2020-06-16T02:29:39Z",
          "updatedAt": "2020-06-16T02:29:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we remove the hash-to-field change and discuss that in a separate PR, @kwantam?\r\n\r\nYes! I'll do this and respond to your other feedback later tonight or tomorrow. Sorry for the delay; need to take care of some other stuff for a little while.",
          "createdAt": "2020-06-16T03:40:43Z",
          "updatedAt": "2020-06-16T03:40:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've rewritten this branch so that it does not include the alternative hash_to_field function. We can discuss in #284 and then pull in the commit or not as we decide.",
          "createdAt": "2020-06-16T06:06:00Z",
          "updatedAt": "2020-06-16T06:06:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDY5NTM5",
          "commit": {
            "abbreviatedOid": "4d8464c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "In general it's ok, but I am not really conviced about whether to include the alternative method for hash to field. Let's discuss this topic in #284 \r\n",
          "createdAt": "2020-06-15T23:57:56Z",
          "updatedAt": "2020-06-16T01:14:39Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Not always there is one point at infinity. Neither the point at infinity is always the one chosen as the identity element.\r\n\r\n> Elements of an elliptic curve group are points with coordinates (x, y) satisfying the curve equation, where x and y are elements of F, together with a set of points at infinity (which doesn't have a representation as a coordinate pair).\r\nAll elliptic curve groups have a distinguished element, called the identity point, which acts as the identity element for the group operation.\r\n",
              "createdAt": "2020-06-15T23:57:57Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\ni.e., execution time SHOULD NOT depend on the\r\n```\r\nMemory access can be done in non-constant time provided it uses public values.\r\n\r\n\"A secure memory access pattern restricts the use of secret values (or values derived from secret data) to address the memory.\" \r\n\r\n",
              "createdAt": "2020-06-16T00:12:39Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 125,
              "body": "```suggestion\r\n    of such methods is out of the scope of this document.\r\n```",
              "createdAt": "2020-06-16T00:19:56Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 195,
              "body": "> ???\r\n> I'm not sure how to interpret this---truncating the output of H is still uniform if H is...\r\n\r\nSuppose there is a hash function that outputs `b=8n+1` bits, then after ceiling you have `b_in_bytes=n+1`, and then the last byte has almost all-zeros (except the first bit).\r\n-- I think Thomas' comment refers that this last byte is not uniform.\r\n\r\n",
              "createdAt": "2020-06-16T00:35:33Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 303,
              "body": "This expression is correct. But it took me a second to parse `7-byte` as a string of seven bytes, and not as a byte of seven bits. The confusion was increased as ASCII was originally a seven bit codification.\r\n\r\ncan we rewrite with something like this: \r\n> ... MUST indicate this by appending the ASCII literal \":H2F-DR\" (seven bytes) to the HASH\\_ID field.\r\n",
              "createdAt": "2020-06-16T00:48:57Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 496,
              "body": "> For now, just made clear that this is not restricted to even-order extensions. \r\n\r\nI think that is enough, as AR13 already describes the application of Frobenius operator.\r\n\r\n",
              "createdAt": "2020-06-16T00:56:43Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 29,
              "body": "> ???\r\n> Not clear that this is within the scope of the document, since right now we're not talking about the modulus M at all.\r\n\r\nIt might be good just to mention that there exists different irreducible polynomials to construct an extension field, even though they are isomorphic.\r\n\r\n",
              "createdAt": "2020-06-16T01:03:06Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTA2Njgx",
          "commit": {
            "abbreviatedOid": "4d8464c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T01:55:36Z",
          "updatedAt": "2020-06-16T01:55:37Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Ah, great point! I will clarify :)",
              "createdAt": "2020-06-16T01:55:37Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTA2NzU1",
          "commit": {
            "abbreviatedOid": "4d8464c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T01:55:47Z",
          "updatedAt": "2020-06-16T01:55:48Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "(no pun intended :laughing: )\r\n",
              "createdAt": "2020-06-16T01:55:47Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTA3OTgz",
          "commit": {
            "abbreviatedOid": "4d8464c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T01:59:25Z",
          "updatedAt": "2020-06-16T01:59:26Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think the issue is that my edit isn't clear enough about *which* inputs, intermediate values, and outputs the timing and memory access patterns are not allowed to depend upon.\r\n\r\nThe problems with removing \"and memory access patterns\" are, first, that it ends up ignoring Thomas's comment (which is a good one), and second (and relatedly), that it makes the statement incomplete, in the sense that secret-dependent memory accesses are not OK.\r\n\r\nI'll think more about how to address this. One way is for us to not attempt to inject a concise definition of \"constant time\" here, and instead cite a different document that discusses in more detail.",
              "createdAt": "2020-06-16T01:59:26Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTEwODgx",
          "commit": {
            "abbreviatedOid": "4d8464c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T02:08:37Z",
          "updatedAt": "2020-06-16T02:08:38Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Ah! Thank you!!!",
              "createdAt": "2020-06-16T02:08:37Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTEyNzA5",
          "commit": {
            "abbreviatedOid": "4d8464c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T02:14:38Z",
          "updatedAt": "2020-06-16T02:14:39Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Right now we just say \"there is some basis\", but we don't go into any more detail. I guess we could add something like \"all choices of basis are isomorphic, but certain choices may result in a more efficient implementation\", but it's not clear to me what this adds to the document...\r\n\r\nHappy to add it if you think it's useful! :+1:",
              "createdAt": "2020-06-16T02:14:38Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTE0NTM1",
          "commit": {
            "abbreviatedOid": "b758173"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T02:20:41Z",
          "updatedAt": "2020-06-16T02:20:42Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "OK, I made a small edit to clarify that this applies to *secrets*. Does this address the concern?",
              "createdAt": "2020-06-16T02:20:41Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTE3NzEz",
          "commit": {
            "abbreviatedOid": "b758173"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for tackling this large chunk of feedback! I have concerns about the hash-to-field alternative, and only some minor comments about the rest of the change. (The primary point being that we should move all pre-computation steps to constants in the algorithms.) \r\n\r\nCan we remove the hash-to-field change and discuss that in a separate PR, @kwantam?",
          "createdAt": "2020-06-16T02:30:41Z",
          "updatedAt": "2020-06-16T02:38:54Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Agreed -- noting the isomorphism, and perhaps reinforcing that this means the polynomial does not affect the basis, is sufficient.",
              "createdAt": "2020-06-16T02:30:41Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nElements of an elliptic curve group are points with affine coordinates (x, y)\r\n```",
              "createdAt": "2020-06-16T02:31:01Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 126,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-16T02:32:50Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 130,
              "body": "Maybe network byte order? (Unclear if that's preferred for IETF documents.)",
              "createdAt": "2020-06-16T02:33:14Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\nwould prohibit a constant-time implementation.\r\n```",
              "createdAt": "2020-06-16T02:33:39Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nof H. Adding DST as a suffix is the RECOMMENDED approach.\r\n```",
              "createdAt": "2020-06-16T02:34:44Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 262,
              "body": "Should we lift this to a constant, then?",
              "createdAt": "2020-06-16T02:35:06Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 273,
              "body": "Same here, r.e., it being a constant.",
              "createdAt": "2020-06-16T02:35:19Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 382,
              "body": "I'm less thrilled about adding this. What's the driving use case? ",
              "createdAt": "2020-06-16T02:36:38Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            },
            {
              "originalPosition": 5,
              "body": "Same constant here (and below) r.e. this being a constant.",
              "createdAt": "2020-06-16T02:37:03Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTczNDA3",
          "commit": {
            "abbreviatedOid": "b758173"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T05:39:05Z",
          "updatedAt": "2020-06-16T05:39:05Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Cool. Added.",
              "createdAt": "2020-06-16T05:39:05Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTc0Nzky",
          "commit": {
            "abbreviatedOid": "b758173"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T05:42:55Z",
          "updatedAt": "2020-06-16T05:42:55Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "RFC7748 uses \"little endian\", as does the current Ristretto draft. Other RFCs are mixed, but use of \"little-endian\" and \"big-endian\" seems to be pretty common even in older RFCs (e.g., RFC1071).\r\n\r\nMy guess is that implementors of this spec are more likely to understand \"big endian\" than \"network byte order,\" so I'd vote to keep as-is. Thoughts?",
              "createdAt": "2020-06-16T05:42:55Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTc1Mzkx",
          "commit": {
            "abbreviatedOid": "b758173"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T05:44:34Z",
          "updatedAt": "2020-06-16T05:44:34Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "It's not *quite* true that it would \"prohibit\" it---it's possible, just in a painful way. How about \"would be incompatible with constant-time implementation\"?",
              "createdAt": "2020-06-16T05:44:34Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTc3NDU4",
          "commit": {
            "abbreviatedOid": "b758173"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T05:50:07Z",
          "updatedAt": "2020-06-16T05:50:08Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Hmmm... the problem with lifting this into the \"Constants\" list above is that it's a different kind of constant---the \"Constants\" list are parameters, whereas these are derived values that can be precomputed. I think it's clearer if we make a distinction between these two things, and I don't think the pseudocode suffers so much in the process...\r\n\r\nThoughts?",
              "createdAt": "2020-06-16T05:50:07Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTgzNjA4",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T06:05:23Z",
          "updatedAt": "2020-06-16T06:05:23Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "See #284 --- basically, the alternative method is much better for high-degree extension fields of small-ish characteristic, like [curve9767](https://github.com/pornin/curve9767), which is nice for microcontrollers.",
              "createdAt": "2020-06-16T06:05:23Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMzIyNzIz",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T09:26:50Z",
          "updatedAt": "2020-06-16T09:26:50Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Would an example constant-time lookup with secret bit be interesting as an appendix?\r\n\r\nIn Mrabet and Joye book there is a  example in page 11-13 (Software Implementation, chapter -line11.6.2 \"Eliminating Secret Memory Addresses\") based on CMOV",
              "createdAt": "2020-06-16T09:26:50Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMzI3NjAy",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T09:32:53Z",
          "updatedAt": "2020-06-16T09:32:54Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "I strongly oppose any use similar to `htonl` / `ntohl` (host to network long and network to host long), those are machine dependent / implementation-defined and lead to situation like the C `int` datatypes which is at least 16-bit but almost always assume to be 32-bit i.e. `int16_t` and `int32_t` is clearer and less error prone (and for the spec big endian).",
              "createdAt": "2020-06-16T09:32:53Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDk3NTYz",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T13:24:22Z",
          "updatedAt": "2020-06-16T13:24:23Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Great point! Let's keep it as is.",
              "createdAt": "2020-06-16T13:24:23Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDk4NTY1",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T13:25:22Z",
          "updatedAt": "2020-06-16T13:25:22Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I'm honestly fine fibbing a little bit here, if only to get the point across. Your proposal also works. (Consider this bike shedding :))",
              "createdAt": "2020-06-16T13:25:22Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNTAyOTY4",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T13:30:01Z",
          "updatedAt": "2020-06-16T13:30:01Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "I'm not sure I see the difference. `tv4` depends only on `Z` and `A`, which are both themselves constants. Doesn't that make this the same type of constant? Even if we do consider these different, wouldn't we expect implementations to precompute all parameter and derived constants in practice?",
              "createdAt": "2020-06-16T13:30:01Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjAzNzQy",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T15:06:37Z",
          "updatedAt": "2020-06-16T15:06:37Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Sorry, I was super unclear. What I meant was, the constants in the list (A, B, Z) are choices that you have to make to use this map, no matter how you implement the map.\r\n\r\nIn contrast, tv4 and tv5 are values you can precompute to speed up evaluating the map, but they're more like implementation details for this specific implementation rather than fundamental parameters. Someone implementing the map in projective coordinates would probably precompute different values, not tv4 and tv5.\r\n\r\nDoes this make sense?\r\n\r\nMore generally, I don't think we need to focus too much on precomputation here, because the point isn't to suggest that people follow the details of this implementation, just to make clearer what the high-level costs are (as Thomas says). So it seems like it's OK just to note \"can be precomputed,\" without suggesting that people actually *do* precompute---that's what the constants in the straight-line impl are for.",
              "createdAt": "2020-06-16T15:06:37Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjIxNTAz",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T15:20:03Z",
          "updatedAt": "2020-06-16T15:20:03Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Ah, yes, thanks for clarifying! I forgot that we already have these constants in the straight-line implementation.",
              "createdAt": "2020-06-16T15:20:03Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjIxNjE3",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T15:20:10Z",
          "updatedAt": "2020-06-16T15:20:11Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Should this be `tv6`?",
              "createdAt": "2020-06-16T15:20:10Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjIyMjIy",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo one small aliasing comment.",
          "createdAt": "2020-06-16T15:20:48Z",
          "updatedAt": "2020-06-16T15:20:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjI1NTY5",
          "commit": {
            "abbreviatedOid": "81921e2"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T15:24:10Z",
          "updatedAt": "2020-06-16T15:24:11Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Sure, that might be clearer. I'll make the change :+1:",
              "createdAt": "2020-06-16T15:24:10Z",
              "updatedAt": "2020-06-16T15:28:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNzYwNTk0",
          "commit": {
            "abbreviatedOid": "e2eaf1c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-16T18:02:51Z",
          "updatedAt": "2020-06-16T18:02:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0ODM1NjMw",
      "title": "respond to a few other comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/283",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue responds to a comment from Michael Scott and one from Marek Jankowski.\r\n\r\nThe next message in this thread includes all of Marek's review, and some notes. We can discuss further here or in the issues that Chris opened.",
      "createdAt": "2020-06-15T21:57:12Z",
      "updatedAt": "2020-07-08T22:02:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d19b27740c0c7aed45e9d9336786986edb53433b",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "other_comments",
      "headRefOid": "3417a9dc0e4d9d966faf1b91691318a2b280b8b6",
      "closedAt": "2020-06-16T03:50:56Z",
      "mergedAt": "2020-06-16T03:50:56Z",
      "mergedBy": "armfazh",
      "mergeCommit": {
        "oid": "ce233b0a972680f4d1c43f88b118a6b4c532f615"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> a. I think Table 1 (Sec. 2.1) could be better formatted, using less line\r\n> breaks. Please consider redistributing the widths of the columns.\r\n\r\nIssue #279 --- probably needs to be handled manually.\r\n\r\n> b. The second paragraph in 2.2.1 can be simplified: it suffices to say it\r\n> needs not be bijective/surjective/injective. Also I'm not entirely sure\r\n> it's best practice to use the term 'invertible' for just _efficiently_\r\n> reversible functions.\r\n\r\nI think the examples here may be useful, and certainly don't hurt clarity.\r\n\r\nNot clear re 'invertible'---my understanding is that this is indeed the\r\nterm used in the crypto literature...\r\n\r\n> c. I think a better formulation in the first paragraph in 2.2.5 is\r\n> something like \"...assuming the attacker accesses RO only through the\r\n> protocol, viz. the RO is not used elsewhere.\"\r\n\r\nI think the first part of this statement isn't quite true---generally\r\na random oracle is assumed to be public, so adversaries are allowed\r\nto query it. The important thing is that other protocols are not\r\nsimultaneously trying to query it, because otherwise, e.g., the\r\nchallenger in the security game can't program the random oracle when\r\nit needs to.\r\n\r\nI've updated with a cite to BR93 and a clarification that the adversary\r\nis allowed to query the oracle, to make this statement more precise.\r\n\r\n> d. The word 'encode' (Sec. 3) implies that its output can be decoded.\r\n> Perhaps there's a better word for noninvertible maps.\r\n\r\nNo action for now---is there a word that Marek recommends?\r\n\r\n> e. Domain separation (Sec. 3.1): I believe that if needed for backwards\r\n> compatibility, it is not a disaster if we omit the version number from the\r\n> Tag. Maybe it is worth a \"NOT RECOMMENDED\".\r\n\r\nWait---are we now NOT RECOMMENDing a version number after all?\r\nCan we ask for clarification on this? Maybe we can discuss more in #280.\r\n\r\n> f. It says that expand_message MUST NOT use rejection sampling (5.3.4). To\r\n> the best of my understanding, rejection sampling is to be avoided for the\r\n> sole purpose of mitigating side channel attacks; this is defined (Sec. 4)\r\n> as a SHOULD, so I believe this SHOULD should (no pun intended :-) propagate\r\n> there.\r\n\r\nI made an edit in PR #282 to address this. See comments there and in #281.\r\n\r\n> g. Do we really want to approve as many curves as in [Table 2, Sec. 8]? We\r\n> are standardizing something new here, so we can allow ourselves to stick to\r\n> just the best curves. In my opinion Curve25519 is in every way superior to\r\n> the NIST curve of the same strength, so the latter can be omitted.\r\n> Again, I am very supportive of the draft and will be happy to further help\r\n> in the process.\r\n\r\nInclined to keep, per Chris's response on the mailing list.\r\n",
          "createdAt": "2020-06-15T21:57:33Z",
          "updatedAt": "2020-06-15T21:57:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! @armfazh, please merge if you're OK with the change. I think this adequately addresses Marek's comments.",
          "createdAt": "2020-06-16T02:23:34Z",
          "updatedAt": "2020-06-16T02:23:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @armfazh somehow the UI ignored me when I asked it to request a review from you earlier :)",
          "createdAt": "2020-06-16T02:29:52Z",
          "updatedAt": "2020-06-16T02:30:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTE1Mjcy",
          "commit": {
            "abbreviatedOid": "3417a9d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T02:23:03Z",
          "updatedAt": "2020-06-16T02:23:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-16T02:23:03Z",
              "updatedAt": "2020-06-16T02:23:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTE1MzI2",
          "commit": {
            "abbreviatedOid": "3417a9d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-16T02:23:12Z",
          "updatedAt": "2020-06-16T02:23:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTQwODU4",
          "commit": {
            "abbreviatedOid": "3417a9d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-16T03:50:38Z",
          "updatedAt": "2020-06-16T03:50:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0OTUyNzgx",
      "title": "Fixes column spacing of table 1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/285",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #279 ",
      "createdAt": "2020-06-16T03:36:46Z",
      "updatedAt": "2020-06-16T06:07:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d19b27740c0c7aed45e9d9336786986edb53433b",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "fixTable1",
      "headRefOid": "296fba3336bfbfc1f1a0bfe88b9c9bc10e27dc4c",
      "closedAt": "2020-06-16T03:51:43Z",
      "mergedAt": "2020-06-16T03:51:43Z",
      "mergedBy": "armfazh",
      "mergeCommit": {
        "oid": "c09a3368610f5c7e420db0a42d9ee970d51f27a4"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice! :+1:",
          "createdAt": "2020-06-16T06:07:56Z",
          "updatedAt": "2020-06-16T06:07:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDIwNjcw",
      "title": "add hash_to_field_divrem in appx",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/286",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds an alternative version of hash_to_field that is approriate for high-degree extensions of smallish characteristic. I'm posting this here so that we can refer to specifies in the discussion in #284. Not clear that we should actually apply this change, though.\r\n\r\ncloses #284",
      "createdAt": "2020-06-16T19:23:42Z",
      "updatedAt": "2020-06-28T00:00:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f028204795218e1c9bc14356957b5562062b84c9",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "hash_to_field_alt",
      "headRefOid": "45a8f2df74f95fe145b2d9249d541386f3dc89e2",
      "closedAt": "2020-06-28T00:00:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Just ACKing this for now. @kwantam, do we have a concrete use case for this? I wonder if we should ask folks on the list if they think it'd be helpful? ",
          "createdAt": "2020-06-17T13:50:07Z",
          "updatedAt": "2020-06-17T13:50:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nA different approach to handle this case, it could be to define and/or recommend what are the properties needed by an alternative algorithm for hash_to_field, instead of proposing the full description of an alternate method, which, at the end of the day, might or might not be the best method.\r\n\r\nThis would be similar to the way we described a variant for expand_message (other than XMD and XOF).\r\n\r\nFor example, we didn't describe any method for hashing to GF(2^n), (of course, the draft restricts to large prime characateristic), however, this is the other extreme and we could give some recommendations -- Imagine someone interested in using a binary curve for lightweight computing.\r\n\r\n",
          "createdAt": "2020-06-17T16:39:41Z",
          "updatedAt": "2020-06-17T16:39:41Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> do we have a concrete use case for this?\r\n\r\nThe only one I know of is https://github.com/pornin/curve9767\r\n\r\n> A different approach to handle this case, it could be to define and/or recommend what are the properties needed by an alternative algorithm for hash_to_field, instead of proposing the full description of an alternate method, which, at the end of the day, might or might not be the best method\r\n\r\nThis is a good observation. This could be done, for example, by expanding the paragraph at the start of Section 5 that says impls must not use rejection sampling. We could also add a subsection describing the properties, but really there are not many: must be statistaically close to uniform, must not use rejection sampling, should be specified with straight line impls in mind.",
          "createdAt": "2020-06-17T16:53:33Z",
          "updatedAt": "2020-06-17T16:53:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> This is a good observation. This could be done, for example, by expanding the paragraph at the start of Section 5 that says impls must not use rejection sampling. We could also add a subsection describing the properties, but really there are not many: must be statistaically close to uniform, must not use rejection sampling, should be specified with straight line impls in mind.\r\n\r\n\r\nAgree, so we can remove the alternative method.\r\n",
          "createdAt": "2020-06-19T22:41:39Z",
          "updatedAt": "2020-06-19T22:41:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, I approved since this is a fairly simple algorithm, so I'm OK with the added complexity. But if you both think elaborating on the requirements would work, that's fine too. That we only know of one use case is, well, unfortunate. (So maybe I just talked myself in @armfazh's suggestion? :))",
          "createdAt": "2020-06-19T22:44:06Z",
          "updatedAt": "2020-06-19T22:44:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam, quick question:\r\n\r\n> This is a good observation. This could be done, for example, by expanding the paragraph at the start of Section 5 that says impls must not use rejection sampling. We could also add a subsection describing the properties, but really there are not many: must be statistaically close to uniform, must not use rejection sampling, should be specified with straight line impls in mind.\r\n\r\nThe third paragraph in Section 5 starts with, \"Implementors MUST NOT use rejection sampling...\" Perhaps we could add the properties you list to 5.1 (security considerations)?",
          "createdAt": "2020-06-25T22:50:09Z",
          "updatedAt": "2020-06-25T22:50:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I made that change over in #287. @armfaz, @kwantam, please have a look!",
          "createdAt": "2020-06-25T23:06:38Z",
          "updatedAt": "2020-06-25T23:06:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we're all agreed that #287 is the better way to go, so I'm going to close this in favor of that one.",
          "createdAt": "2020-06-28T00:00:37Z",
          "updatedAt": "2020-06-28T00:00:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzUxNjA2",
          "commit": {
            "abbreviatedOid": "45a8f2d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T21:34:44Z",
          "updatedAt": "2020-06-19T22:28:06Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nor greater than k as it is more difficult to implement\r\n```",
              "createdAt": "2020-06-19T21:34:44Z",
              "updatedAt": "2020-06-19T22:28:06Z"
            },
            {
              "originalPosition": 163,
              "body": "Should this be `ceil(log2(p))`?",
              "createdAt": "2020-06-19T22:27:15Z",
              "updatedAt": "2020-06-19T22:28:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMjk5Njkz",
      "title": "Specify alternative hash-to-field requirements.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/287",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This pulls some text from #286 (explaining why applications might want alternative hash-to-field functions) but replaces the description of one with some basic requirements. ",
      "createdAt": "2020-06-25T23:05:54Z",
      "updatedAt": "2022-02-18T16:42:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "f028204795218e1c9bc14356957b5562062b84c9",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/h2f-reqs",
      "headRefOid": "a3f3cb767688162856af683b01cbcb16f9b6dcf4",
      "closedAt": "2020-06-29T22:31:24Z",
      "mergedAt": "2020-06-29T22:31:24Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "33fb61006261a108b76c0bd41e276c76362d3d9e"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The only thing we don't do here is require suites using alternative hash_to_field functions to indicate that in the suite ID string. Do we want to ask them to include that information? Probably it would just take one sentence.\r\n\r\nGood point -- I added a sentence to the suites section. @kwantam, please merge if you think this is good to go!",
          "createdAt": "2020-06-28T13:44:31Z",
          "updatedAt": "2020-06-28T13:44:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam fixed -- thanks for the careful review!",
          "createdAt": "2020-06-29T22:13:11Z",
          "updatedAt": "2020-06-29T22:13:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTIwMDUx",
          "commit": {
            "abbreviatedOid": "1e20b7a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like this, which is enough to avoid adding the full description of an alternative method. ",
          "createdAt": "2020-06-25T23:14:50Z",
          "updatedAt": "2020-06-25T23:14:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzMxMTIx",
          "commit": {
            "abbreviatedOid": "1e20b7a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Probably this is cleaner than adding the appendix.\r\n\r\nThe only thing we don't do here is require suites using alternative hash_to_field functions to indicate that in the suite ID string. Do we want to ask them to include that information? Probably it would just take one sentence.",
          "createdAt": "2020-06-27T23:38:19Z",
          "updatedAt": "2020-06-27T23:58:55Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n- The function MUST output field element(s) that are uniformly random except with bias at most 2^-k.\r\n```",
              "createdAt": "2020-06-27T23:38:19Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            },
            {
              "originalPosition": 14,
              "body": "The issue is, we've just gotten through saying that the function in this section outputs something with bias at most 2^-k---so it does not even meet the \"uniformly random\" requirement as stated here!",
              "createdAt": "2020-06-27T23:39:47Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n## Efficiency considerations in extension fields {#hashtofield-exteff}\r\n\r\nThe hash\\_to\\_field function described in this section is inefficient for certain\r\nextension fields. Specifically, when hashing to an element of the extension\r\n```",
              "createdAt": "2020-06-27T23:44:35Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nfield GF(p^m), hash\\_to\\_field requires expanding msg into m * L bytes (for L as defined above).\r\n```",
              "createdAt": "2020-06-27T23:44:56Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n\r\nFor example, Pornin {{P20}} describes a method for hashing to GF(9767^19) that meets\r\nthese requirements while using fewer output bits from expand\\_message than\r\nhash\\_to\\_field would for that field.\r\n```",
              "createdAt": "2020-06-27T23:50:48Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            },
            {
              "originalPosition": 19,
              "body": "P20 is:\r\n\r\n```\r\n  P20:\r\n    title: \"Efficient Elliptic Curve Operations On Microcontrollers With Finite Field Extensions\"\r\n    target: https://eprint.iacr.org/2020/009\r\n    date: 2020\r\n    author:\r\n      -\r\n        ins: T. Pornin\r\n        name: Thomas Pornin\r\n        org: NCC Group\r\n```",
              "createdAt": "2020-06-27T23:53:00Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzMxOTY2",
          "commit": {
            "abbreviatedOid": "1e20b7a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-28T00:01:40Z",
          "updatedAt": "2020-06-28T00:01:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think it might be better to add a separate subsection because otherwise I worry that this info gets lost...",
              "createdAt": "2020-06-28T00:01:40Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzgxMDMz",
          "commit": {
            "abbreviatedOid": "baacd5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-28T13:34:55Z",
          "updatedAt": "2020-06-28T13:34:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "\ud83d\udc4d thanks -- this precision is better!",
              "createdAt": "2020-06-28T13:34:55Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzgxMDYy",
          "commit": {
            "abbreviatedOid": "baacd5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-28T13:35:14Z",
          "updatedAt": "2020-06-28T13:35:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That works for me!",
              "createdAt": "2020-06-28T13:35:14Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTM0Mzg3",
          "commit": {
            "abbreviatedOid": "93f50be"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": ":+1: this looks great, with one small comment. What do you think of the suggested edit?\r\n\r\n(And sorry for the continued nitpicking!!!)",
          "createdAt": "2020-06-29T22:08:06Z",
          "updatedAt": "2020-06-29T22:08:46Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n  Suites that use an alternative hash\\_to\\_field function that meets the requirements\r\n  in {{hashtofield-exteff}} MUST indicate this by appending a tag identifying that function\r\n  to the HASH\\_ID field, separated by a colon (\":\", ASCII 0x3A).\r\n```\r\n\r\nTwo suggestions:\r\n\r\n(1) add indentation to keep this as part of the bulleted list, and\r\n\r\n(2) \"choosing a unique identifier\" is not quite explicit enough, because it's not clear what it needs to be different from.",
              "createdAt": "2020-06-29T22:08:06Z",
              "updatedAt": "2020-06-29T22:11:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTM3OTk3",
          "commit": {
            "abbreviatedOid": "a3f3cb7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T22:11:52Z",
          "updatedAt": "2020-06-29T22:11:52Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> \ud83d\udc4d this looks great, with one small comment. What do you think of the suggested edit?\r\n\r\nThis works for me!",
              "createdAt": "2020-06-29T22:11:52Z",
              "updatedAt": "2020-06-29T22:11:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 289,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2NTU1NjQy",
      "title": "comments from Dan ; hash_to_scalar",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/289",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adjusts the text as discussed in #288, clarifying uniform/nonuniform vs random oracle.\r\n\r\nIt also adds the note we discussed via email regarding hashing to GF(r).",
      "createdAt": "2020-07-09T00:50:55Z",
      "updatedAt": "2020-08-08T19:08:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "33fb61006261a108b76c0bd41e276c76362d3d9e",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "more_comments",
      "headRefOid": "7b1734edb27c0bb39ba95231c9dba12f990f93bb",
      "closedAt": "2020-07-13T20:50:20Z",
      "mergedAt": "2020-07-13T20:50:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "17b7db9be3193d819d40d875bb7d80c98bc21897"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments! :+1:",
          "createdAt": "2020-07-13T00:45:22Z",
          "updatedAt": "2020-07-13T00:45:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTkwOTY1",
          "commit": {
            "abbreviatedOid": "f87f209"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-07-09T21:45:59Z",
          "updatedAt": "2020-07-09T23:02:21Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "r must be prime, but the elliptic curve group could not. ",
              "createdAt": "2020-07-09T21:45:59Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            },
            {
              "originalPosition": 143,
              "body": "```suggestion\r\nrelies on a random oracle that outputs points with a uniform distribution MUST NOT use a\r\n```",
              "createdAt": "2020-07-09T21:49:11Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            },
            {
              "originalPosition": 63,
              "body": "Stating these bounds at this point is distracting. \r\nI recommend just to mention that 1) the image of `encode_to_curve` reaches only a fraction of the points in G, and 2) some points have different probability to be obtained by `encode_to_curve`. Both of these staments make clear that the distribution is far from uniform. More details are given in  `{{security-considerations-encode}}` .",
              "createdAt": "2020-07-09T22:13:38Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nA random-oracle encoding is an encoding satisfying a strong property: it can be\r\nproved indifferentiable from a random oracle {{MRH04}} under a suitable assumption.\r\nThis makes random-oracle encodings appropriate for use in many cryptographic\r\nprotocols proven secure in the random oracle model, as long as the output distribution\r\nis uniform in G. See {{security-considerations}} for further discussion.\r\n```",
              "createdAt": "2020-07-09T22:21:34Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nThe constructions described in {{roadmap}} differ in their output \r\ndistributions: one gives points sampled from a nonuniform \r\ndistribution, and the other gives uniformly random points in G.\r\nThe latter can be used to instantiate a hash function into elliptic \r\ncurves in schemes proved in the random oracle model {{MRH04}}.\r\n```",
              "createdAt": "2020-07-09T22:29:49Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            },
            {
              "originalPosition": 199,
              "body": "I am not sure whether these bounds are still maintained.\r\nFor example  {{FT10}} improved the image size just by altering the choice of the y coordinate. In our case, we have altered the y-coordinate, and the choice of Z to make the encodings complete. \r\nIt's likely that our modifications only modified the bounds by a minor factor. I think there is no need to prove that, nor to include such a proof in the document.\r\nMy recommendation is to point readers to the correspondent papers without including the specific details of the bounds.",
              "createdAt": "2020-07-09T22:50:12Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTI1MjUy",
          "commit": {
            "abbreviatedOid": "f87f209"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T00:32:52Z",
          "updatedAt": "2020-07-13T00:32:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This edit changes the point of the \"Note, however\"---I was intending to refer to the Ristenpart et al. paper on the limits of indifferentiability, not uniformity issues. But maybe the broader point is that this is all too encoded, and we should simply refer them to security considerations for further discussion. I'll push an edit to this effect and then can we discuss further?",
              "createdAt": "2020-07-13T00:32:53Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTI1NTc4",
          "commit": {
            "abbreviatedOid": "f87f209"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T00:35:31Z",
          "updatedAt": "2020-07-13T00:35:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Same comment as above. I'll push an edit and then can we discuss further?",
              "createdAt": "2020-07-13T00:35:31Z",
              "updatedAt": "2020-07-13T00:44:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTI5ODUw",
          "commit": {
            "abbreviatedOid": "7b1734e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T19:16:31Z",
          "updatedAt": "2020-07-13T19:16:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1MDQ0NjUw",
      "title": "Address Thomas' nits.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/293",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #292.\r\n\r\nI think we should leave indentation nonsense to the RFC editor. We didn't change any of the pseudocode blocks, so it seems to be a tooling issue that (in my opinion) is not worth our time debugging.",
      "createdAt": "2020-08-08T15:42:43Z",
      "updatedAt": "2022-02-18T16:42:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "17b7db9be3193d819d40d875bb7d80c98bc21897",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/thomas-nits",
      "headRefOid": "54b371c1ad623cfb04c4b864b2fafa0cb664dada",
      "closedAt": "2020-08-08T19:11:20Z",
      "mergedAt": "2020-08-08T19:11:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4f2de2f80d055d5a7ce1f3244b8c5b119d22eae7"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam please merge if you agree!",
          "createdAt": "2020-08-08T15:45:01Z",
          "updatedAt": "2020-08-08T15:45:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood :+1: looks good to me. I modified the vector generation scripts to generate \"SHAKE128\" instead of \"SHAKE_128\" and double checked that the auto-generated results match the change you made. If my changes look good to you, go ahead and merge.",
          "createdAt": "2020-08-08T19:10:34Z",
          "updatedAt": "2020-08-08T19:10:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1MjAyNjM5",
      "title": "recommendation on how to hash to ristretto255",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/294",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a short appendix that defines a hash_to_curve--like function for ristretto255.\r\n\r\nCloses #291 ",
      "createdAt": "2020-08-09T21:05:26Z",
      "updatedAt": "2020-08-23T17:12:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4f2de2f80d055d5a7ce1f3244b8c5b119d22eae7",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "ristretto_advice",
      "headRefOid": "2cd66aaa6958fa7b87d03086a9ffd4d7f0394b84",
      "closedAt": "2020-08-23T17:12:02Z",
      "mergedAt": "2020-08-23T17:12:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4fc19e5b38d0ed25d3c11d32f54a10bf214cdb35"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Per @grittygrease's statement in #291, I think once we're happy with this text we should push an updated draft and request feedback on the cfrg list about this.",
          "createdAt": "2020-08-09T21:06:50Z",
          "updatedAt": "2020-08-09T21:06:50Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @chris-wood! I pushed a very small edit that refs to the domain separation recommendations from the appendix, but now I'll stop messing around with it :)",
          "createdAt": "2020-08-09T22:11:56Z",
          "updatedAt": "2020-08-09T22:11:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The edits still look good :-) I suggest we take this to the list now. (@armfazh is out this week and won't be able to review for a while.)",
          "createdAt": "2020-08-10T14:49:17Z",
          "updatedAt": "2020-08-10T14:49:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "What's the best way to do this? Ref the list to this PR?",
          "createdAt": "2020-08-11T01:30:40Z",
          "updatedAt": "2020-08-11T01:30:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What's the best way to do this? Ref the list to this PR?\r\n\r\nYep, that\u2019ll do!",
          "createdAt": "2020-08-11T01:48:30Z",
          "updatedAt": "2020-08-11T01:48:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam shall we merge this? There's been no pushback, and it seems like the best option (in my opinion).",
          "createdAt": "2020-08-23T14:24:47Z",
          "updatedAt": "2020-08-23T14:24:47Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me. ",
          "createdAt": "2020-08-23T14:29:33Z",
          "updatedAt": "2020-08-23T14:29:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Feedback has been more positive than negative, so I think it passes the bar for inclusion :+1:\r\n\r\nThere is a small remaining question that we can decide not to address now: if the ristretto draft adds decaf for edwards448 we might also want to give a recommendation for that. Happy to merge this and update later if that becomes necessary.",
          "createdAt": "2020-08-23T17:07:40Z",
          "updatedAt": "2020-08-23T17:07:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> There is a small remaining question that we can decide not to address now: if the ristretto draft adds decaf for edwards448 we might also want to give a recommendation for that. Happy to merge this and update later if that becomes necessary.\r\n\r\nI heard that Mike might join the ristretto255 draft and add decaf448 in the process. When that happens, we can that method in a followup PR.",
          "createdAt": "2020-08-23T17:11:38Z",
          "updatedAt": "2020-08-23T17:11:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA0MTc1",
          "commit": {
            "abbreviatedOid": "68bd991"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The content LGTM \u2014 thanks!",
          "createdAt": "2020-08-09T21:19:49Z",
          "updatedAt": "2020-08-09T21:19:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 295,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3OTIxMDI5",
      "title": "Add hash-to-decaf448.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/295",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on the latest and greatest new document: https://www.ietf.org/staging/draft-irtf-cfrg-ristretto255-decaf448-00.html :-)",
      "createdAt": "2020-10-05T15:04:45Z",
      "updatedAt": "2020-10-11T11:14:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "4fc19e5b38d0ed25d3c11d32f54a10bf214cdb35",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/add-decaf448",
      "headRefOid": "af46bf3f91615b7209a9ac8ec4bb4afff754c68c",
      "closedAt": "2020-10-10T19:02:30Z",
      "mergedAt": "2020-10-10T19:02:30Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "fb8cc83f2062b293777c81c73521265136258e03"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "CI's broken because the new document hasn't officially landed in the tracker, as far as I can tell. Once that's done, I'll kick the CI to fix it.",
          "createdAt": "2020-10-05T15:16:53Z",
          "updatedAt": "2020-10-05T15:16:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "very nice! I will make time to review in the next few days :)",
          "createdAt": "2020-10-05T16:50:59Z",
          "updatedAt": "2020-10-05T16:50:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kwantam!",
          "createdAt": "2020-10-05T16:56:48Z",
          "updatedAt": "2020-10-05T16:56:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, oops... did I merge too quickly?",
          "createdAt": "2020-10-10T19:04:34Z",
          "updatedAt": "2020-10-10T19:04:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Oh, oops... did I merge too quickly?\r\n\r\nYeah, but I'll fix directly on master. No problem. :)",
          "createdAt": "2020-10-11T11:14:34Z",
          "updatedAt": "2020-10-11T11:14:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjk4OTg0",
          "commit": {
            "abbreviatedOid": "0a5f4dc"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thanks Chris, LGTM!",
          "createdAt": "2020-10-07T22:02:11Z",
          "updatedAt": "2020-10-07T22:02:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTA5NTA3",
          "commit": {
            "abbreviatedOid": "0a5f4dc"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-10T16:26:01Z",
          "updatedAt": "2020-10-10T16:33:24Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "```suggestion\r\na prime-order group based on Curve448 {{!RFC7748}}.\r\n```",
              "createdAt": "2020-10-10T16:26:01Z",
              "updatedAt": "2020-10-10T18:50:25Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nristretto255 {{I-D.irtf-cfrg-ristretto255-decaf448}} provides a prime-order\r\n```",
              "createdAt": "2020-10-10T16:31:21Z",
              "updatedAt": "2020-10-10T18:50:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTE3NjE1",
          "commit": {
            "abbreviatedOid": "0a5f4dc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks great! Just one small question.",
          "createdAt": "2020-10-10T18:31:51Z",
          "updatedAt": "2020-10-10T18:37:29Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n{{?I-D.irtf-cfrg-ristretto255-decaf448}}.\r\n```\r\n\r\nShouldn't we use the \"auto\" reffing if possible? (Or is that broken because this document is too new?)",
              "createdAt": "2020-10-10T18:31:51Z",
              "updatedAt": "2020-10-10T18:50:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTE4NzI2",
          "commit": {
            "abbreviatedOid": "0a5f4dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-10T18:49:07Z",
          "updatedAt": "2020-10-10T18:49:08Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "It was broken at the time. It might be working now? I'll try to build without it and remove the manual entry if so.",
              "createdAt": "2020-10-10T18:49:07Z",
              "updatedAt": "2020-10-10T18:50:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTE4Nzgz",
          "commit": {
            "abbreviatedOid": "0a5f4dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-10T18:50:10Z",
          "updatedAt": "2020-10-10T18:50:10Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "It works now!",
              "createdAt": "2020-10-10T18:50:10Z",
              "updatedAt": "2020-10-10T18:50:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 297,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyODIyMzgx",
      "title": "Add Zig's standard library to the list of implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/297",
      "state": "MERGED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The Zig programming language includes hash-to-curve support in its standard library.",
      "createdAt": "2020-11-18T01:34:46Z",
      "updatedAt": "2020-11-18T08:40:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "5999997b269f2eb4ad5cb3d6a3dd4297b7cd68e6",
      "headRepository": "jedisct1/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "patch-1",
      "headRefOid": "295f65584d04b7dcfba8be8c65b1fb6b2a1b5c82",
      "closedAt": "2020-11-18T03:53:55Z",
      "mergedAt": "2020-11-18T03:53:55Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "eac6f7d11909f8ff776294595dde4f52df8e3a8a"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Very cool --- thank you!!!",
          "createdAt": "2020-11-18T03:53:49Z",
          "updatedAt": "2020-11-18T03:53:49Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc4NjcyNTMy",
      "title": "Recommend SHAKE256 for decaf448 hash-to-group. ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/303",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And add expand_message_xof(SHAKE256) test vectors.\r\n\r\ncc @claucece",
      "createdAt": "2021-02-23T18:41:06Z",
      "updatedAt": "2022-02-18T16:42:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "eac6f7d11909f8ff776294595dde4f52df8e3a8a",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/recommend-shake256",
      "headRefOid": "25869726bf462124925507f913abc9b36d262193",
      "closedAt": "2021-03-19T23:58:41Z",
      "mergedAt": "2021-03-19T23:58:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e1897dec82ecf6f2e1db0482e7ba95991a706877"
      },
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "NONE",
          "body": "LGTM.",
          "createdAt": "2021-02-23T19:52:34Z",
          "updatedAt": "2021-02-23T19:52:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2Njk3Nzc3",
          "commit": {
            "abbreviatedOid": "e88853e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-23T19:04:19Z",
          "updatedAt": "2021-02-23T19:04:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nFor example, if expand\\_message is expand\\_message\\_xof using SHAKE256, the\r\n```",
              "createdAt": "2021-02-23T19:04:19Z",
              "updatedAt": "2021-02-23T19:09:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2NzAxOTc2",
          "commit": {
            "abbreviatedOid": "e88853e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-23T19:09:24Z",
          "updatedAt": "2021-02-23T19:09:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hrm I thought I made that change. Oops.",
              "createdAt": "2021-02-23T19:09:24Z",
              "updatedAt": "2021-02-23T19:09:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5MTI1MDg0",
          "commit": {
            "abbreviatedOid": "2586972"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-25T23:18:39Z",
          "updatedAt": "2021-02-25T23:18:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5MjM1OTI3",
      "title": "Cite Mike Hamburg's analysis on Elligator 2 indifferentiability.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/305",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #299.",
      "createdAt": "2021-03-23T22:40:35Z",
      "updatedAt": "2022-02-18T16:42:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "e1897dec82ecf6f2e1db0482e7ba95991a706877",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/cite-mikes-paper",
      "headRefOid": "0d396a04704083d09b5cc4e5736c61afd73a228e",
      "closedAt": "2021-03-24T15:50:44Z",
      "mergedAt": "2021-03-24T15:50:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fb7b6d49684065727630fb5fd31b770704894265"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5ODk0Nzk2",
          "commit": {
            "abbreviatedOid": "0d396a0"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-24T15:45:46Z",
          "updatedAt": "2021-03-24T15:45:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEzMTE3MTU2",
      "title": "Security considerations: the identity element",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/306",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a short paragraph in Security Considerations to put this identity element issue to bed.\r\n\r\n--\r\n\r\nI don't insist on keeping the last sentence :)\r\n",
      "createdAt": "2021-04-11T17:45:00Z",
      "updatedAt": "2021-04-14T02:08:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "fb7b6d49684065727630fb5fd31b770704894265",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "master",
      "headRefOid": "63a42053548746397314a9b4ad92b9785767356e",
      "closedAt": "2021-04-14T02:08:35Z",
      "mergedAt": "2021-04-14T02:08:34Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "a62e564748d51f62292e4eaa749bde365911326f"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh @chris-wood if we merge this before Wednesday it can make it into draft -11 (which we need to submit so that the draft doesn't expire).",
          "createdAt": "2021-04-11T17:45:39Z",
          "updatedAt": "2021-04-11T17:45:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> We might give a hint about why this check is not needed, or in which situations it is.\r\n\r\nThe original change had some rationale, but I don't think it's needed here.",
          "createdAt": "2021-04-12T18:16:20Z",
          "updatedAt": "2021-04-12T18:16:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNjY2Mjc2",
          "commit": {
            "abbreviatedOid": "955c964"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with some suggested rewording, including trimming that last sentence. :-)",
          "createdAt": "2021-04-12T15:18:35Z",
          "updatedAt": "2021-04-12T15:19:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nThe probability that either encoding function, when instantiated with a hash\\_to\\_field function \r\nthat follows all guidelines in {{hashtofield}}, outputs the identity element given a uniformly\r\nrandom input is roughly 1/r, which is negligible for cryptographically useful elliptic curves.\r\n```",
              "createdAt": "2021-04-12T15:18:35Z",
              "updatedAt": "2021-04-12T17:46:42Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nFurther, it is computationally infeasible to find an input to either encoding function\r\n```",
              "createdAt": "2021-04-12T15:18:51Z",
              "updatedAt": "2021-04-12T17:46:42Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nProtocols that use these encoding functions SHOULD NOT add a special case \r\nto detect and \"fix\" the identity element.\r\n```",
              "createdAt": "2021-04-12T15:19:18Z",
              "updatedAt": "2021-04-12T17:46:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNzY2OTE5",
          "commit": {
            "abbreviatedOid": "955c964"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-12T16:55:27Z",
          "updatedAt": "2021-04-12T16:55:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Your suggestion definitely helps, but I wonder if we can make this even clearer. How about:\r\n\r\n```\r\nThe probability that either encoding function outputs the identity element is roughly\r\n1/r for a random input, which is negligible for cryptographically useful elliptic curves.\r\nFurther, it is computationally infeasible to find an input to either encoding function whose\r\ncorresponding output is the identity element.\r\n(Both of these properties hold when the encoding functions are instantiated with a\r\nhash\\_to\\_field function that follows all guidelines in {{hashtofield}}.)\r\n```\r\n\r\nThoughts?",
              "createdAt": "2021-04-12T16:55:27Z",
              "updatedAt": "2021-04-12T17:46:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNzk3NDc4",
          "commit": {
            "abbreviatedOid": "b0ed346"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-12T17:30:12Z",
          "updatedAt": "2021-04-12T17:30:12Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Much better! :-)",
              "createdAt": "2021-04-12T17:30:12Z",
              "updatedAt": "2021-04-12T17:46:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzODExOTI3",
          "commit": {
            "abbreviatedOid": "63a4205"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-12T17:47:24Z",
          "updatedAt": "2021-04-12T17:47:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "OK, pushed that change now. Marking this resolved (but happy to discuss more!)",
              "createdAt": "2021-04-12T17:47:24Z",
              "updatedAt": "2021-04-12T17:47:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzODI2NTQx",
          "commit": {
            "abbreviatedOid": "63a4205"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "```\r\nProtocols that use these encoding functions SHOULD NOT add a special case \r\nto detect and \"fix\" the identity element.\r\n```\r\n\r\nWe might give a hint about why this check is not needed, or in which situations it is. ",
          "createdAt": "2021-04-12T18:04:47Z",
          "updatedAt": "2021-04-12T18:04:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 307,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5Mzc2NzQz",
      "title": "Address feedback from Stanislav.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/307",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-20T14:29:13Z",
      "updatedAt": "2022-02-18T16:42:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a62e564748d51f62292e4eaa749bde365911326f",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/stanislav-review",
      "headRefOid": "8ce317e9b23f53c61f8312e2dfa8ac5d18564685",
      "closedAt": "2021-04-23T17:42:04Z",
      "mergedAt": "2021-04-23T17:42:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c15d09230dc934887d4b60acb39f62510e663c5c"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for making these changes! I will make some time in the next day or two to look over them. Sorry for the delay...",
          "createdAt": "2021-04-22T17:44:14Z",
          "updatedAt": "2021-04-22T17:44:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNzc3MTc4",
          "commit": {
            "abbreviatedOid": "52d530b"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-21T08:39:37Z",
          "updatedAt": "2021-04-21T08:39:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNDQ2MDY2",
          "commit": {
            "abbreviatedOid": "402e74e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T15:56:42Z",
          "updatedAt": "2021-04-23T15:56:43Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n\r\nNote that the constant c3 below MUST be chosen such that sgn0(c3) = 0.\r\nIn other words, if the square-root computation returns a value cx such that\r\nsgn0(cx) = 1, set c3 = -cx; otherwise, set c3 = cx.\r\n```",
              "createdAt": "2021-04-23T15:56:42Z",
              "updatedAt": "2021-04-23T17:41:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNDQ3MDAw",
          "commit": {
            "abbreviatedOid": "402e74e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T15:57:46Z",
          "updatedAt": "2021-04-23T15:57:46Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Is this slightly clearer?\r\n\r\nAlso, nowadays sgn0 returns only 0 or 1, so I think there was a typo here.",
              "createdAt": "2021-04-23T15:57:46Z",
              "updatedAt": "2021-04-23T17:41:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNDQ3NTU0",
          "commit": {
            "abbreviatedOid": "402e74e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Other than the one comment above, lgtm!",
          "createdAt": "2021-04-23T15:58:20Z",
          "updatedAt": "2021-04-23T15:58:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNTI3NzUy",
          "commit": {
            "abbreviatedOid": "402e74e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T17:38:59Z",
          "updatedAt": "2021-04-23T17:39:00Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "it's clear",
              "createdAt": "2021-04-23T17:38:59Z",
              "updatedAt": "2021-04-23T17:41:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNTI5NzE1",
          "commit": {
            "abbreviatedOid": "402e74e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T17:41:49Z",
          "updatedAt": "2021-04-23T17:41:49Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Yeah, works for me!",
              "createdAt": "2021-04-23T17:41:49Z",
              "updatedAt": "2021-04-23T17:41:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIxNDQ1NjIz",
      "title": "armfazh/sgn0basis: definition of sgn0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/308",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This helps to emphasize that the sgn0 function **does** iterates over the input vector.",
      "createdAt": "2021-04-22T19:05:12Z",
      "updatedAt": "2021-04-22T20:52:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "caw/stanislav-review",
      "baseRefOid": "f5afcec0c409ad494c92bc4b94f7c97970ded090",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/sgn0basis",
      "headRefOid": "e531302a3ca939c8858e3e84565b6d0f186b8a54",
      "closedAt": "2021-04-22T20:52:23Z",
      "mergedAt": "2021-04-22T20:52:23Z",
      "mergedBy": "armfazh",
      "mergeCommit": {
        "oid": "402e74ec74382f31a4af94280640193d3efaa4f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNTg0MDIx",
          "commit": {
            "abbreviatedOid": "73d634f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-04-22T19:18:05Z",
          "updatedAt": "2021-04-22T19:18:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This change makes the rest of the paragraph sort of irrelevant. If we're going to take this, then we should drop lines 1572-1576, too.",
              "createdAt": "2021-04-22T19:18:05Z",
              "updatedAt": "2021-04-22T19:21:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNTg2NzQ4",
          "commit": {
            "abbreviatedOid": "e531302"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T19:21:32Z",
          "updatedAt": "2021-04-22T19:21:32Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Change was made and merged with previous line.",
              "createdAt": "2021-04-22T19:21:32Z",
              "updatedAt": "2021-04-22T19:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNTg3MzMz",
          "commit": {
            "abbreviatedOid": "e531302"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2021-04-22T19:22:18Z",
          "updatedAt": "2021-04-22T19:22:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIxNTI5OTU3",
      "title": "Removes spaces",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/309",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Removes spaces so it does not overflow the text column.\r\nAlso, no warnings during compilation.",
      "createdAt": "2021-04-22T20:51:27Z",
      "updatedAt": "2021-04-23T15:33:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "a62e564748d51f62292e4eaa749bde365911326f",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/spaces",
      "headRefOid": "f00193abf31f7cf949adf81a2b10b8e21a79dc67",
      "closedAt": "2021-04-22T21:22:18Z",
      "mergedAt": "2021-04-22T21:22:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "de96dfe28c6563e30f8c8f12b114d3930225c3fd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNjc4MjE4",
          "commit": {
            "abbreviatedOid": "f00193a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-22T21:22:14Z",
          "updatedAt": "2021-04-22T21:22:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNDI0NDA5",
          "commit": {
            "abbreviatedOid": "f00193a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T15:32:54Z",
          "updatedAt": "2021-04-23T15:32:54Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "is_square(g(Z_cand)) is inconsistent with h(Z_cand).is_square() a few lines above. Can we make these agree?",
              "createdAt": "2021-04-23T15:32:54Z",
              "updatedAt": "2021-04-23T15:32:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNDI0Nzg4",
          "commit": {
            "abbreviatedOid": "f00193a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T15:33:18Z",
          "updatedAt": "2021-04-23T15:33:19Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "I'll open a new PR for this.",
              "createdAt": "2021-04-23T15:33:19Z",
              "updatedAt": "2021-04-23T15:33:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 310,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIyMTY0OTIw",
      "title": "tiny tweaks for consistency in Z finding code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/310",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This does a tiny bit of cleanup on #309",
      "createdAt": "2021-04-23T15:44:51Z",
      "updatedAt": "2021-04-23T17:41:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "de96dfe28c6563e30f8c8f12b114d3930225c3fd",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "z_code_consistency",
      "headRefOid": "1e60f173d4f3a95021a8bce4d7cbddaacc8e6883",
      "closedAt": "2021-04-23T17:41:09Z",
      "mergedAt": "2021-04-23T17:41:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ccc5a7216e7b7cf1c6969c31af27f0543abe8c13"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNTE3MzI0",
          "commit": {
            "abbreviatedOid": "1e60f17"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-23T17:25:06Z",
          "updatedAt": "2021-04-23T17:25:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNTI5MjU5",
          "commit": {
            "abbreviatedOid": "1e60f17"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-23T17:41:05Z",
          "updatedAt": "2021-04-23T17:41:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2MTg5Njk3",
      "title": "Clarify polynomial basis dependency and expand_message_xmd hash function requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/311",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should address the two remaining shepherd comments.\r\n\r\ncc @kwantam, @armfazh",
      "createdAt": "2021-05-17T21:15:18Z",
      "updatedAt": "2022-02-18T16:42:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "c15d09230dc934887d4b60acb39f62510e663c5c",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/more-clarification",
      "headRefOid": "df615f9ef67877b31d19c76f529a1597fa48e678",
      "closedAt": "2021-07-14T15:01:17Z",
      "mergedAt": "2021-07-14T15:01:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f7dd37616830cb52a73d100e1e6e0f3f9b0f4201"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Paging @kwantam for a quick look before merging.",
          "createdAt": "2021-07-06T17:49:54Z",
          "updatedAt": "2021-07-06T17:49:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam merging away -- please shout if you want to make changes!",
          "createdAt": "2021-07-14T15:01:40Z",
          "updatedAt": "2021-07-14T15:01:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxNDYwNTk5",
          "commit": {
            "abbreviatedOid": "89a17ee"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "it looks good",
          "createdAt": "2021-05-17T22:02:01Z",
          "updatedAt": "2021-05-17T22:02:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxNDY1ODc5",
          "commit": {
            "abbreviatedOid": "89a17ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-17T22:12:04Z",
          "updatedAt": "2021-05-17T22:12:05Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nsize (s). As examples, s = 1024 for SHA-512 {{FIPS180-4}} and s = 576 for\r\n```",
              "createdAt": "2021-05-17T22:12:04Z",
              "updatedAt": "2021-05-17T22:12:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 312,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5NTI5NDUw",
      "title": "Refactor SSWU to use div_sqrt per Daira's suggestion.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/312",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This does not include an efficient, constant time implementation of div_sqrt (yet!), so I'm starting this as a draft for us to work through that. It's not clear to me how we can adapt Tonelli-Shanks here. Help is appreciated! =)\r\n\r\ncc @kwantam, @armfazh",
      "createdAt": "2021-05-20T22:55:28Z",
      "updatedAt": "2022-02-18T16:42:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "c15d09230dc934887d4b60acb39f62510e663c5c",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/refactor-sswu",
      "headRefOid": "0c22155bcd2e5316e570ed813b7f3fcbe05a187f",
      "closedAt": "2021-09-06T19:54:51Z",
      "mergedAt": "2021-09-06T19:54:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "be531b2dfc81d06c26b60fc02ccf6483e6a62caa"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I will have time either later this week or next week to (finally!) look at this. Sorry for the delay!",
          "createdAt": "2021-07-12T17:31:12Z",
          "updatedAt": "2021-07-12T17:31:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I _finally_ got around to updating this PR. I promoted the generalized SSWU variant from @daira to the appendix, removed curve-specific optimizations, and updated the reference code. This could really use a review, so please let me know if there's anything else I could do to help!",
          "createdAt": "2021-08-13T22:10:16Z",
          "updatedAt": "2021-08-13T22:10:16Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note the constant-time Tonelli Shanks that returns invsqrt at https://github.com/miracl/core/issues/24\r\n\r\nSage implementation: https://github.com/mratsim/constantine/blob/499f9605/sage/square_root_bls12_377.sage#L222-L248\r\n\r\n",
          "createdAt": "2021-08-14T16:36:16Z",
          "updatedAt": "2021-08-14T16:36:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> This could really use a review, so please let me know if there's anything else I could do to help!\r\n\r\nSorry for the long long delay on this. I'm buried in dissertation work for the next couple weeks, but after that things will be better. (Feels like I've said that before! but this is top of my priority list post-dissertation...)",
          "createdAt": "2021-08-16T14:55:03Z",
          "updatedAt": "2021-08-16T14:55:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mratsim thanks! I'll take a look.",
          "createdAt": "2021-08-16T15:22:57Z",
          "updatedAt": "2021-08-16T15:22:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm getting back up to speed on this and reviewing today (and probably tomorrow)! Phew... sorry for the long delay.",
          "createdAt": "2021-09-04T22:15:16Z",
          "updatedAt": "2021-09-04T22:15:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood would it make sense for us to add field-specific implementations of `sqrt_ratio`? That's implicitly what we had before, and given that in most cases folks will be working with primes congruent to 3 mod 4 or to 5 mod 8, it seems reasonable to include at least those two optimizations (to me, 9 mod 16 probably also makes sense).",
          "createdAt": "2021-09-05T21:35:27Z",
          "updatedAt": "2021-09-05T21:35:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe? What would be the concrete improvement? Can we do that in a separate PR if necessary?",
          "createdAt": "2021-09-05T21:51:08Z",
          "updatedAt": "2021-09-05T21:51:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The field-specific implementations are *a lot* simpler than the generic one.",
          "createdAt": "2021-09-05T21:59:40Z",
          "updatedAt": "2021-09-05T21:59:40Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We could do in a separate PR, or I could make a PR against this PR. What do you prefer?",
          "createdAt": "2021-09-05T22:00:24Z",
          "updatedAt": "2021-09-05T22:00:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's do a separate PR. Is this one good to go?",
          "createdAt": "2021-09-05T22:18:42Z",
          "updatedAt": "2021-09-05T22:18:42Z"
        },
        {
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can do a more thorough review of this tomorrow. (If I don't get round to it, don't block on me.)",
          "createdAt": "2021-09-05T22:29:27Z",
          "updatedAt": "2021-09-05T22:29:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @daira! @kwantam, please let me know if changes are needed or not. I'll prioritize adding them.",
          "createdAt": "2021-09-05T22:35:58Z",
          "updatedAt": "2021-09-05T22:35:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam regarding mechanical changes -- the pseudocode here is copied directly from the reference implementation underneath. Were you thinking of a different sort of mechanical conversion? (I don't recall us doing anything else here, but it has been a while...)",
          "createdAt": "2021-09-05T23:44:45Z",
          "updatedAt": "2021-09-05T23:44:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam pseudocode and tests updated. Please have another look!",
          "createdAt": "2021-09-06T04:43:19Z",
          "updatedAt": "2021-09-06T04:43:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam resolved -- awaiting your green light. ",
          "createdAt": "2021-09-06T15:39:45Z",
          "updatedAt": "2021-09-06T15:39:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I pushed a tiny change in `test.sage` that removes an extraneous call to an undefined `straight_line2` method. Re-running tests now.",
          "createdAt": "2021-09-06T17:05:09Z",
          "updatedAt": "2021-09-06T17:05:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "sqrt tests were too slow because they had to recompute primitive_element each time. I memoized that computation and reduced the bit width of random moduli for the test. Re-launching now.\r\n\r\nPlease double check my last two commits! I will post again when tests converge.",
          "createdAt": "2021-09-06T18:13:42Z",
          "updatedAt": "2021-09-06T18:13:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam last two commits LGTM!",
          "createdAt": "2021-09-06T19:19:41Z",
          "updatedAt": "2021-09-06T19:19:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam feel free to put up the field-specific sqrt_ratio PRs now. Let's keep the momentum going!",
          "createdAt": "2021-09-06T19:55:15Z",
          "updatedAt": "2021-09-06T19:55:15Z"
        },
        {
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I know this is already merged, but I reviewed it again anyway.",
          "createdAt": "2021-09-07T12:47:54Z",
          "updatedAt": "2021-09-07T12:47:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @daira :) I'll review the comments above and try to address them in subsequent PRs, assuming @kwantam doesn't beat me to it.",
          "createdAt": "2021-09-07T13:26:48Z",
          "updatedAt": "2021-09-07T13:26:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks @daira :) I'll review the comments above and try to address them in subsequent PRs, assuming @kwantam doesn't beat me to it.\r\n\r\n@chris-wood I will plan to roll these changes into my PR.",
          "createdAt": "2021-09-07T15:25:41Z",
          "updatedAt": "2021-09-07T15:25:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NjkxOTU4",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:23:44Z",
          "updatedAt": "2021-05-21T17:23:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "In my implementation I choose a generator of the order-2<sup>c</sup> multiplicative subgroup, where p-1 = m * 2<sup>c</sup> with m odd.\r\n\r\nhttps://github.com/zcash/pasta/blob/master/squareroottab.sage#L60-L65\r\nhttps://github.com/zcash/pasta/blob/master/hashtocurve.sage#L211\r\n\r\nThis is because that value is the one for which it is easy to find sqrt algorithms that naturally return either sqrt(u/v) or sqrt(h*u/v). (You can use other values, but it would be unnecessarily more complicated.)",
              "createdAt": "2021-05-21T17:23:45Z",
              "updatedAt": "2021-05-21T18:02:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzAwOTMx",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:35:53Z",
          "updatedAt": "2021-05-21T17:35:53Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ah, cool, thanks! I'll take a look at that code. ",
              "createdAt": "2021-05-21T17:35:53Z",
              "updatedAt": "2021-05-21T17:35:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzAxNDI4",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:36:35Z",
          "updatedAt": "2021-05-21T17:36:35Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "@daira in addition to `h` selection above, do you have thoughts on how we might implement this in constant time?",
              "createdAt": "2021-05-21T17:36:35Z",
              "updatedAt": "2021-05-21T17:36:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzA2ODA1",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:43:42Z",
          "updatedAt": "2021-05-21T17:43:42Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Either use unique variable names or reuse them; this is a bit of a mixture. I prefer unique names (reusing registers is a low-level optimization that is easy for implementors, or compilers, to do on their own).",
              "createdAt": "2021-05-21T17:43:42Z",
              "updatedAt": "2021-05-21T18:04:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzA3NTMy",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:44:37Z",
          "updatedAt": "2021-05-21T17:44:37Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Yeah, I plan on refactoring this to make better use of variables. (See the comment at the top of the block of code.) ",
              "createdAt": "2021-05-21T17:44:37Z",
              "updatedAt": "2021-05-21T17:44:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzEwNTE4",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:48:38Z",
          "updatedAt": "2021-05-21T17:48:38Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "I checked that this exactly corresponds to the code in https://zips.z.cash/protocol/nu5.pdf#concretegrouphashpallasandvesta or https://github.com/zcash/pasta/blob/master/hashtocurve.sage#L207 .\r\n\r\nI also checked that this should still work if -1/Z is square (which hadn't been checked previously since it is not the case for Pallas or Vesta).\r\n\r\nThe algebraic manipulations used to come up with this algorithm should also be valid for extension fields, but I have not tested it on extension fields.",
              "createdAt": "2021-05-21T17:48:38Z",
              "updatedAt": "2021-05-21T18:05:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzEyODE5",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T17:51:47Z",
          "updatedAt": "2021-05-21T17:51:48Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n        # constants for straight-line impl\r\n```",
              "createdAt": "2021-05-21T17:51:48Z",
              "updatedAt": "2021-05-21T17:51:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzE5NTE4",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T18:00:48Z",
          "updatedAt": "2021-05-21T18:00:49Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This should also be tested at the `undefs` elements (preferably for curves where -1/Z is and is not square).",
              "createdAt": "2021-05-21T18:00:48Z",
              "updatedAt": "2021-05-21T18:00:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NzIxMjE2",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "ACK with comments.",
          "createdAt": "2021-05-21T18:03:14Z",
          "updatedAt": "2021-05-21T18:03:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1ODMzOTgz",
          "commit": {
            "abbreviatedOid": "1929370"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T19:47:04Z",
          "updatedAt": "2021-05-21T19:47:05Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "The change to return either sqrt(x) or sqrt(h*x), and the change to operate on a ratio, are independent.\r\n\r\nStart by implementing a function that implements the former. I haven't checked, but I believe that the constant-time Tonelli\u2013Shanks in https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-10.html#name-constant-time-tonelli-shanks just works for h = c5 (or maybe 1/c5, or something like that). Ideally this would be proven.\r\n\r\nThen apply the optimization described at https://github.com/zcash/pasta/blob/master/squareroottab.sage#L150-L170 . It will also work for Tonelli\u2013Shanks. (z corresponds to v, and u to x.)",
              "createdAt": "2021-05-21T19:47:04Z",
              "updatedAt": "2021-05-21T19:57:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzU2ODgz",
          "commit": {
            "abbreviatedOid": "c96dfd8"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look good. ",
          "createdAt": "2021-07-12T17:14:54Z",
          "updatedAt": "2021-07-12T17:14:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NTk4OTQw",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-04T22:32:59Z",
          "updatedAt": "2021-09-04T22:33:00Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "@daira is `h` required to be a primitive element, or just a non-square? If the latter, could we just use the (non-square) constant `Z` that is already defined?\r\n\r\nOtherwise, we should somewhere document how to identify the smallest primitive element, or give a pointer to an existing procedure. (Sage could work, as in the sample code, but it's not obvious to me that `F.primitive_element()` is defined to return the smallest such element, so I worry a little about things breaking in the future...)",
              "createdAt": "2021-09-04T22:33:00Z",
              "updatedAt": "2021-09-04T22:33:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NjYyNDM5",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-05T15:33:03Z",
          "updatedAt": "2021-09-05T15:33:04Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "[Edit: renamed variables to avoid a clash.]\r\n\r\nsqrt_ratio algorithms that give a square root of either s or h*s \"for free\" in a prime field F<sub>p</sub>, will generally require h to generate the order-2<sup>\u03b1</sup> subgroup where p-1 = 2<sup>\u03b1</sup> * \u03b2 for odd \u03b2.\r\n\r\nYou could use Z = h (and I suggest that as a possibility [here](https://github.com/zcash/pasta/blob/f0f7068552a3565786cb338448cb58bc36a8314a/hashtocurve.sage#L269-L272)), but the I-D RECOMMENDS a specific Z that in general will not generate the order-2<sup>\u03b1</sup> subgroup (and changing the procedure for finding the recommended Z now would not be compatible).\r\n\r\nTo be clear, the only requirement on h *for this algorithm* is that it be non-square. But the motivation for doing it this way is that we can choose h to be the same h as in an efficient implementation of sqrt_ratio.",
              "createdAt": "2021-09-05T15:33:03Z",
              "updatedAt": "2021-09-08T11:24:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NjgzODU0",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-05T21:09:32Z",
          "updatedAt": "2021-09-05T21:09:33Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Thanks for the explanation.\r\n\r\nOne more question, just to be sure that I am understanding correctly: looks like as long as the `h` value used here and in `sqrt_ratio` are the same, there's no need for different implementations to use the same `h`. Is that right? If so, is the reason to recommend the smallest such value just efficiency?",
              "createdAt": "2021-09-05T21:09:33Z",
              "updatedAt": "2021-09-05T21:09:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2Njg4NjI2",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-05T22:26:53Z",
          "updatedAt": "2021-09-05T22:26:53Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "That's correct; different implementations need not use the same h. I'm not sure why the smallest value is recommended; that's not what my code used.",
              "createdAt": "2021-09-05T22:26:53Z",
              "updatedAt": "2021-09-05T22:27:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2Njg5MTg0",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-05T22:35:09Z",
          "updatedAt": "2021-09-05T22:35:09Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "> I'm not sure why the smallest value is recommended\r\n\r\nSimply to remove choices for implementers. No other reason.",
              "createdAt": "2021-09-05T22:35:09Z",
              "updatedAt": "2021-09-05T22:35:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2Njg5MjU1",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The high-level changes are OK, but there are some details that aren't quite right.\r\n\r\nOnce we resolve these comments I'd like to double-check that the pseudocode actually executes correctly. We probably also want to add the tests that @daira sugested. And I will put together another PR (should be easy) that reintroduces optimized sqrt_ratio procedures for common field characteristics.",
          "createdAt": "2021-09-05T22:36:17Z",
          "updatedAt": "2021-09-05T23:37:19Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nThis optimized, straight-line procedure applies to any base field.\r\nThe constant c1 depends on a value S, which\r\n```\r\n\r\nThe letter `h` should not be used for this value, because `h` is defined everywhere else in this document to be the cofactor of the target curve.\r\n\r\nI'm not sure if [this table](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189#issuecomment-549991161) is still up-to-date, but I checked the document and it looks like `S` is unused and might make sense (S for sqrt).",
              "createdAt": "2021-09-05T22:36:17Z",
              "updatedAt": "2021-09-05T23:38:07Z"
            },
            {
              "originalPosition": 87,
              "body": "Thanks again for the info!\r\n\r\n@chris-wood I think this should be re-worded to indicate that the value of `h` (eventually, `S`) depends on the `sqrt_ratio` subroutine used, and clarify that this value MUST be the same as the one used there.",
              "createdAt": "2021-09-05T22:36:47Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nis a parameter of the sqrt_ratio subroutine defined below.\r\n```",
              "createdAt": "2021-09-05T23:00:27Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\n1.  c1 = Z / S\r\n```",
              "createdAt": "2021-09-05T23:02:20Z",
              "updatedAt": "2021-09-05T23:37:19Z"
            },
            {
              "originalPosition": 153,
              "body": "```suggestion\r\nThe sqrt_ratio subroutine used by the above procedure is defined immediately below.\r\nIt depends on a constant S, which MUST be chosen to be a primitive element of the field F.\r\nSee below for more information on identifying an appropriate value for S.\r\n```\r\n\r\nI left out \"non-square\" here because a primitive element of GF(p^m) for odd p will always be non-square: p^m is odd, so 2 divides p^m - 1, so there's a subgroup of order 2; and a square cannot generate a subgroup of order 2.",
              "createdAt": "2021-09-05T23:13:31Z",
              "updatedAt": "2021-09-05T23:37:19Z"
            },
            {
              "originalPosition": 159,
              "body": "```suggestion\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- S, a primitive element of F.\r\n```",
              "createdAt": "2021-09-05T23:15:46Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nOutput: (b, y), where b = True and y = sqrt(u / v) if (u / v) is square in F,\r\n  and b = False and y = sqrt(S * (u / v)) otherwise.\r\n```",
              "createdAt": "2021-09-05T23:16:18Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 171,
              "body": "```suggestion\r\n6. tv0 = S^r\r\n```",
              "createdAt": "2021-09-05T23:16:53Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\r\n9. tv1 = S^tv1\r\n```",
              "createdAt": "2021-09-05T23:17:48Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\n12. tv2 = v^tv2\r\n```\r\n\r\nThe arguments are defined to be u,v not N,D.\r\n\r\nAll of the other pseudocode in the document was carefully checked by mechanically transforming the text from the document into the example code and then running the test suite. This new code should be checked likewise.",
              "createdAt": "2021-09-05T23:21:04Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\n14. tv3 = tv3 * v\r\n```",
              "createdAt": "2021-09-05T23:21:13Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 185,
              "body": "```suggestion\r\n20. tv2 = tv5 * v # y\r\n```",
              "createdAt": "2021-09-05T23:21:25Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\n17. tv5 = u * tv3\r\n```",
              "createdAt": "2021-09-05T23:21:57Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 186,
              "body": "```suggestion\r\n21. tv3 = tv5 * u # z\r\n```",
              "createdAt": "2021-09-05T23:22:25Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 194,
              "body": "```suggestion\r\n29. for i in (m, m - 1, ..., 2):\r\n```\r\n\r\nWe do not use `range` in pseudocode elsewhere in the document.",
              "createdAt": "2021-09-05T23:24:37Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 191,
              "body": "`isQR` is use-before-def here. Need an initial `isQR = True` somewhere, I think.",
              "createdAt": "2021-09-05T23:27:39Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 202,
              "body": "Below this point, need to add some very simple (probably Sage) pseudocode to show how to select a value for S. Maybe something like this:\r\n\r\n```\r\nThe following Sage {{SAGE}} pseudocode outputs an appropriate S value for sqrt_ratio:\r\n\r\n    # Arguments:\r\n    # - F, a field object, e.g., F = GF(2^255 - 19)\r\n    def find_S(F):\r\n        return F.primitive_element()\r\n```\r\n\r\n(this is basically just aping the find_z_xxxx definitions later in the appendices).",
              "createdAt": "2021-09-05T23:29:53Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            },
            {
              "originalPosition": 73,
              "body": "As I said in a different comment, I'd recommend changing this def to use u and v instead of N and D (and likewise S instead of h), and then mechanically transforming the pseudocode from the document and running the tests to make sure that the document's code isn't broken.\r\n\r\nYou will probably have to make small allowances, e.g., lines like `v = F(v)` and `order = F.order()` and `S = F.primitive_element()`.\r\n\r\nOnce we fix the pseudocode in the document I'm happy to do this, by the way!",
              "createdAt": "2021-09-05T23:32:37Z",
              "updatedAt": "2021-09-05T23:37:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2Njk0NTMy",
          "commit": {
            "abbreviatedOid": "5f59281"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-05T23:38:49Z",
          "updatedAt": "2021-09-05T23:38:50Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "By the way, I have not checked this code carefully for correctness. I'll do that once the sqrt_ratio code is fixed.",
              "createdAt": "2021-09-05T23:38:50Z",
              "updatedAt": "2021-09-05T23:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NzUzMzc2",
          "commit": {
            "abbreviatedOid": "72ec37f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-06T03:53:41Z",
          "updatedAt": "2021-09-06T03:53:41Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I'd be fine with that change as it still allows `S` to be computed deterministically.",
              "createdAt": "2021-09-06T03:53:41Z",
              "updatedAt": "2021-09-06T03:53:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NzU1NjEz",
          "commit": {
            "abbreviatedOid": "6d8017d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-06T04:01:31Z",
          "updatedAt": "2021-09-06T04:01:31Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I went the other way around -- I generated pseudocode from the code, which seems mostly the same? More eyes verifying this would definitely be helpful though.",
              "createdAt": "2021-09-06T04:01:31Z",
              "updatedAt": "2021-09-06T04:01:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ2NzU3MTQw",
          "commit": {
            "abbreviatedOid": "6d8017d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-06T04:06:41Z",
          "updatedAt": "2021-09-06T04:06:42Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Oops. Good catch! ",
              "createdAt": "2021-09-06T04:06:41Z",
              "updatedAt": "2021-09-06T04:06:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3Mjc1Njc0",
          "commit": {
            "abbreviatedOid": "bb3856f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "A few small nits. I tested the pseudocode by mechanically porting it back into the Sage files and running the tests. I'm going to run the full test suite now, and I'll post again if/when it completes successfully.",
          "createdAt": "2021-09-06T14:31:30Z",
          "updatedAt": "2021-09-06T15:27:39Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "Probably need to fix this cross-link:\r\n\r\n```suggestion\r\nSee {{sswu-z-code}} for more information on identifying an appropriate value for S.\r\n```\r\n\r\nBut do we really want to put `find_s` so far away? I think no, and instead that the `find_s` code should be defined immediately after `sqrt_ratio`. The reason is that `S` is not really a part of the SSWU map, it's just a detail of this particular implementation and this particular definition of `sqrt_ratio`. As further evidence that `S` is a \"local\" thing, the field-specific `sqrt_ratio` implementations that are coming in the next PR will use `S` = `Z`.\r\n\r\n(But of course I can do this rearrangement in the field-specific `sqrt_ratio` PR if you'd like.)",
              "createdAt": "2021-09-06T14:31:30Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 186,
              "body": "```suggestion\r\n19. tv5 = tv5^tv4\r\n```\r\n\r\nspacing consistency (`^` does not have spaces around it elsewhere in the document)",
              "createdAt": "2021-09-06T14:55:47Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n24. tv5 = m - 1\r\n```\r\n\r\nspacing consistency (`-` has spaces around it elsewhere in the document)",
              "createdAt": "2021-09-06T14:56:15Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 197,
              "body": "```suggestion\r\n30. for i in (m, m - 1, ..., 2):\r\n```\r\n\r\njust removing extra spaces",
              "createdAt": "2021-09-06T14:56:56Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 105,
              "body": "```suggestion\r\n        y = c1 * tv1 \r\n```\r\n\r\n`c3` was undef here, and disagrees with the pseudocode in the document. I've tested this fix.",
              "createdAt": "2021-09-06T15:02:09Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\n24.  e1 = sgn0(u) == sgn0(y)\r\n25.   y = CMOV(-y, y, e1)\r\n26.   x = x / tv4\r\n27. return (x, y)\r\n```\r\n\r\nShould use the sgn0 abstraction: `{u,y} mod 2` isn't correct for extension fields.",
              "createdAt": "2021-09-06T15:10:02Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n# vim: syntax=python\r\n```\r\n\r\nhuh, wonder how that happened",
              "createdAt": "2021-09-06T15:11:07Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\n        e1 = self.sgn0(u) == self.sgn0(y)\r\n        y = CMOV(-y, y, e1)\r\n```\r\n\r\nPorting fix from pcode",
              "createdAt": "2021-09-06T15:24:51Z",
              "updatedAt": "2021-09-06T15:27:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3MzIzNjQ0",
          "commit": {
            "abbreviatedOid": "06a0a8b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-06T15:36:10Z",
          "updatedAt": "2021-09-06T15:36:10Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Proof that this was copied from the code! :-)",
              "createdAt": "2021-09-06T15:36:10Z",
              "updatedAt": "2021-09-06T15:36:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3MzI1NTE3",
          "commit": {
            "abbreviatedOid": "40bf9de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-06T15:39:17Z",
          "updatedAt": "2021-09-06T15:39:17Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I don't feel strongly. Keeping it where it is now has the advantage of not sprinkling Sage everywhere. ",
              "createdAt": "2021-09-06T15:39:17Z",
              "updatedAt": "2021-09-06T15:39:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NDA2ODk2",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Tests all passing now!",
          "createdAt": "2021-09-06T19:51:53Z",
          "updatedAt": "2021-09-06T19:51:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3ODkxNDg1",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:02:40Z",
          "updatedAt": "2021-09-07T12:02:40Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "The RHS here is x1<sub>div</sub><sup>3</sup> in the notation used in the Zcash protocol spec (https://zips.z.cash/protocol/protocol.pdf#concretegrouphashpallasandvesta). We previously computed x1<sub>div</sub><sup>2</sup> as tv5 in step 10, and so there is no need to do a cubing here; a multiplication of (tv5 in step 10) * tv4 would be sufficient.\r\n\r\nIn general, I think that reusing temporary variables is unhelpful: it's more error-prone and harder for humans to understand, while the first thing a compiler is going to do anyway (regardless of platform, and platforms with few registers are not an exception) is to convert it to static single-assignment form.",
              "createdAt": "2021-09-07T12:02:40Z",
              "updatedAt": "2021-09-07T12:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3ODkzNjAw",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:05:13Z",
          "updatedAt": "2021-09-07T12:05:14Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "```suggestion\r\n11. tv6 = tv5 * tv4\r\n12. tv5 = A * tv5\r\n13. tv2 = tv2 + tv5\r\n14. tv2 = tv2 * tv3\r\n```",
              "createdAt": "2021-09-07T12:05:13Z",
              "updatedAt": "2021-09-07T12:05:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3OTIyNzA3",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:37:36Z",
          "updatedAt": "2021-09-07T12:37:37Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "I have checked this against https://zips.z.cash/protocol/protocol.pdf#concretegrouphashpallasandvesta and it appears to be equivalent (assuming that `sqrt_ratio` meets its specification).",
              "createdAt": "2021-09-07T12:37:37Z",
              "updatedAt": "2021-09-07T12:41:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3OTI0NTQ1",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:39:34Z",
          "updatedAt": "2021-09-07T12:39:34Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "where v is nonzero (otherwise u / v is ill-defined). It may be useful to note that `map_to_curve_simple_swu` only calls it with v nonzero.",
              "createdAt": "2021-09-07T12:39:34Z",
              "updatedAt": "2021-09-07T12:39:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3OTI2MjE3",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:41:16Z",
          "updatedAt": "2021-09-07T12:41:16Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "I have not checked this.",
              "createdAt": "2021-09-07T12:41:16Z",
              "updatedAt": "2021-09-07T12:41:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3OTI4MDg5",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:43:12Z",
          "updatedAt": "2021-09-07T12:43:12Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Technically the test could fail if v = 0. I know that happens with negligible probability for a good RNG.",
              "createdAt": "2021-09-07T12:43:12Z",
              "updatedAt": "2021-09-07T12:43:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3OTMwMjQ0",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:45:26Z",
          "updatedAt": "2021-09-07T12:45:26Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This comment is still applicable.",
              "createdAt": "2021-09-07T12:45:26Z",
              "updatedAt": "2021-09-07T12:45:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3OTMxNDMz",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T12:46:38Z",
          "updatedAt": "2021-09-07T12:46:39Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "If you take my suggested change in the spec to avoid this cubing, also change it here.",
              "createdAt": "2021-09-07T12:46:39Z",
              "updatedAt": "2021-09-07T12:46:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MTk1ODcx",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T16:44:36Z",
          "updatedAt": "2021-09-07T16:44:37Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Got the fix in the new PR.\r\n\r\nI agree regarding temporary variables, but I'm going to focus on local fixes in my PR.",
              "createdAt": "2021-09-07T16:44:36Z",
              "updatedAt": "2021-09-07T16:44:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4MjkyNjAw",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T18:44:25Z",
          "updatedAt": "2021-09-07T18:44:25Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Temporaries here are just the same as we do elsewhere in the doc. If we make a change here (which would be fine), we should at least be consistent. ",
              "createdAt": "2021-09-07T18:44:25Z",
              "updatedAt": "2021-09-07T18:44:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4OTgzMjU1",
          "commit": {
            "abbreviatedOid": "0c22155"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T10:43:24Z",
          "updatedAt": "2021-09-08T10:43:25Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I said above that the Z output by `find_z_sswu` wouldn't necessarily generate the order 2<sup>\u03b1</sup> subgroup, but actually it necessarily does, as pointed out in #317.",
              "createdAt": "2021-09-08T10:43:25Z",
              "updatedAt": "2021-09-08T11:25:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUyODI1NDk0",
      "title": "Use modified square root routine",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/313",
      "state": "MERGED",
      "author": "wbl",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This routine returns either sqrt(x) or sqrt(h*x), where h is a known\r\nconstant. The additional cost is an extra iteration of the loop in\r\nTonelli-Shanks.",
      "createdAt": "2021-05-25T20:57:29Z",
      "updatedAt": "2021-05-26T15:19:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "caw/refactor-sswu",
      "baseRefOid": "4522a106d114c0d09d315c0a7a4947fd3803bf3b",
      "headRepository": "wbl/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "watson/sqrt-for-qnrs",
      "headRefOid": "bf8f78a17dc74e3e9ab7034d98100f15a8c8b7cb",
      "closedAt": "2021-05-26T15:19:45Z",
      "mergedAt": "2021-05-26T15:19:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c96dfd814159ba7200bd7e37df51bc83bb0eb639"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MTYyMTEx",
          "commit": {
            "abbreviatedOid": "bf8f78a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T15:19:41Z",
          "updatedAt": "2021-05-26T15:19:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI5MDA5NzA1",
      "title": "revisiting sqrt_ratio: optimized routines, code/testing fixes, and small remaining comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/317",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(cc @chris-wood @daira @armfazh)\r\n\r\nThis PR does the following:\r\n\r\n- it adds optimized sqrt_ratio routines for q = 3 mod 4 and q = 5 mod 8. These are a bit simpler than the generic version.\r\n- it removes the constant `S`, which does not appear necessary (discussion below)\r\n- it rolls in @daira's comments from #312\r\n- it does a little code/testing cleanup\r\n\r\nThe generic `sqrt_ratio` routine has a constant `S` that was previously defined as a primitive element of the field. This certainly works, but there are two issues with it:\r\n\r\n1. (minor) `S != Z` needs an extra \"cleanup\" multiplication and a corresponding constant in the sswu routine\r\n2. (major) identifying a primitive element of a field is computationally expensive: Sage does it by factoring `q - 1`, and I'm not aware of another method. This is infeasible for BLS12-381 G2, for example.\r\n\r\nFortunately, we don't actually need `S` to be a primitive element of F. Defining `q - 1 = 2^l * o` with `o` odd, what we actually need is that `S^o` generates the multiplicative subgroup of order `2^l`. This is satisfied by any non-square in F: if `S` is non-square, then `S^o` is also non-square (because `o` is odd), and is also an element of the order-`2^l` subgroup by construction. Moreover, any element of this subgroup that is a non-square in F must generate the subgroup, and likewise any generator must be non-square in F. Since we require the constant `Z` to be non-square already, and since the generic `sqrt_ratio` routine already computes `S^o`, setting `S = Z` appears to suffice.\r\n\r\nBut @daira I'd appreciate if you'd double check me on the above!",
      "createdAt": "2021-09-07T23:07:27Z",
      "updatedAt": "2021-09-13T15:51:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "be531b2dfc81d06c26b60fc02ccf6483e6a62caa",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "sqrt_ratio_opt",
      "headRefOid": "ed3787973e37305f6c38f3ba0fd4d07faf8051ba",
      "closedAt": "2021-09-13T14:30:21Z",
      "mergedAt": "2021-09-13T14:30:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0ccc1cc8d7320116f2cd024585b93cda533c9216"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I did a bit more pseudocode cleanup, both for `sqrt_ratio` and for the constant-time Tonelli-Shanks impl in a different appendix (and I back-ported the changed code to the codebase, and tested it).\r\n\r\nThe goal was to remove expressions from CMOVs, just to emphasize that every expression needs to be evaluated in a straight-line impl.",
          "createdAt": "2021-09-08T00:25:12Z",
          "updatedAt": "2021-09-08T00:25:12Z"
        },
        {
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The argument for why it's sufficient to choose S = Z looks correct.",
          "createdAt": "2021-09-08T11:15:56Z",
          "updatedAt": "2021-09-08T11:15:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5MDIyNTgy",
          "commit": {
            "abbreviatedOid": "d203039"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T11:29:14Z",
          "updatedAt": "2021-09-08T11:29:15Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nThe routines given in this section depend on the constant Z from the simplified SWU map.\r\n(The correctness of `map_to_curve_simple_swu` relies on using the same Z in\r\n`sqrt_ratio` or its specialized variants.)\r\n```",
              "createdAt": "2021-09-08T11:29:14Z",
              "updatedAt": "2021-09-08T11:30:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5MDI5NDg4",
          "commit": {
            "abbreviatedOid": "d203039"
          },
          "author": "daira",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I checked the changes for the SSWU mapping itself, but not the details of the sqrt_ratio implementations.",
          "createdAt": "2021-09-08T11:37:16Z",
          "updatedAt": "2021-09-08T11:37:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NDIxNjk0",
          "commit": {
            "abbreviatedOid": "74e438b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T17:23:17Z",
          "updatedAt": "2021-09-08T17:23:18Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Good catch. (I tried to hew to IETF-ish wording.)",
              "createdAt": "2021-09-08T17:23:18Z",
              "updatedAt": "2021-09-08T17:23:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTk1NDc4",
          "commit": {
            "abbreviatedOid": "74e438b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@kwantam I reviewed the changes (with the exception of the the 5mod8 variant). Maybe @armfazh will have some spare cycles to look at that?",
          "createdAt": "2021-09-08T20:41:43Z",
          "updatedAt": "2021-09-10T00:03:38Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\ndef find_Z(F):\r\n```\r\n\r\n(here and elsewhere)",
              "createdAt": "2021-09-08T20:41:43Z",
              "updatedAt": "2021-09-10T00:03:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyMTgyMDMz",
          "commit": {
            "abbreviatedOid": "ed37879"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-12T17:44:59Z",
          "updatedAt": "2021-09-12T17:45:00Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Pushed a fix. Thank you!",
              "createdAt": "2021-09-12T17:44:59Z",
              "updatedAt": "2021-09-12T17:45:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyODI4NDIx",
          "commit": {
            "abbreviatedOid": "ed37879"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-13T14:29:15Z",
          "updatedAt": "2021-09-13T14:29:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMyODU3MDMy",
      "title": "Update P-384 suite to use SHA384 instead of SHA512",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/318",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See [this related issue](https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/266).\r\n\r\ncc @fredericjacobs, @jedisct1 ",
      "createdAt": "2021-09-13T15:20:35Z",
      "updatedAt": "2021-09-13T16:17:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "0ccc1cc8d7320116f2cd024585b93cda533c9216",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/sha512-to-sha384",
      "headRefOid": "802fd29d56069d02cf660f9b2874ef41d5df07c0",
      "closedAt": "2021-09-13T16:17:15Z",
      "mergedAt": "2021-09-13T16:17:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7e402c595637e83db984835370818b3be4c0db32"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool! I'll review later this afternoon.",
          "createdAt": "2021-09-13T15:32:01Z",
          "updatedAt": "2021-09-13T15:32:01Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The title doesn't look quite right :)",
          "createdAt": "2021-09-13T15:32:20Z",
          "updatedAt": "2021-09-13T15:32:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The title doesn't look quite right :)\r\n\r\nHeh, oops. :) ",
          "createdAt": "2021-09-13T15:40:57Z",
          "updatedAt": "2021-09-13T15:40:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood would it be OK if I added a very minor typographical fix to the suites section?",
          "createdAt": "2021-09-13T15:54:45Z",
          "updatedAt": "2021-09-13T15:54:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood would it be OK if I added a very minor typographical fix to the suites section?\r\n\r\nGo for it!",
          "createdAt": "2021-09-13T15:56:19Z",
          "updatedAt": "2021-09-13T15:56:19Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Done! PR looks good to me.",
          "createdAt": "2021-09-13T16:02:34Z",
          "updatedAt": "2021-09-13T16:02:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyOTQzNDcx",
          "commit": {
            "abbreviatedOid": "802fd29"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2021-09-13T16:02:47Z",
          "updatedAt": "2021-09-13T16:02:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 319,
      "id": "PR_kwDOBtBsGM4rvQ6G",
      "title": "Clarify hash-to-curve properties at a high level.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/319",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #300. ",
      "createdAt": "2021-09-14T15:49:15Z",
      "updatedAt": "2022-02-18T16:41:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7e402c595637e83db984835370818b3be4c0db32",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/clarify-hash-properties",
      "headRefOid": "eac4f1e3bf277b5635903114b1dbd093842626e7",
      "closedAt": "2021-09-16T21:25:13Z",
      "mergedAt": "2021-09-16T21:25:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "69f92fc397ef244443c63af89cebc551114c285b"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam, can you please take a look?",
          "createdAt": "2021-09-16T12:57:11Z",
          "updatedAt": "2021-09-16T12:57:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kwantam! OK to merge?",
          "createdAt": "2021-09-16T19:38:54Z",
          "updatedAt": "2021-09-16T19:38:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4s9Jle",
          "commit": {
            "abbreviatedOid": "32b63e1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T17:19:04Z",
          "updatedAt": "2021-09-14T17:19:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "`producing a point for which the DL is difficult to find` is not a property of the hash-to-curve function, it is a property of the ccurve itself (or the (sub)group of points).\r\n\r\nBetter to say that one application of this hash function is for generating points on the curve such that _the caller_ cannot know its discrete log.\r\n\r\n",
              "createdAt": "2021-09-14T17:19:04Z",
              "updatedAt": "2021-09-14T17:19:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s9OQH",
          "commit": {
            "abbreviatedOid": "32b63e1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T17:39:45Z",
          "updatedAt": "2021-09-14T17:39:46Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Your proposed text seems to match what's written here?",
              "createdAt": "2021-09-14T17:39:46Z",
              "updatedAt": "2021-09-14T17:39:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-Cp5",
          "commit": {
            "abbreviatedOid": "32b63e1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T21:28:27Z",
          "updatedAt": "2021-09-14T21:28:27Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ndiscrete log is unknown. Prominent examples of cryptosystems that hash to elliptic curves include\r\n```",
              "createdAt": "2021-09-14T21:28:27Z",
              "updatedAt": "2021-09-14T21:28:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-Cuh",
          "commit": {
            "abbreviatedOid": "32b63e1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T21:28:40Z",
          "updatedAt": "2021-09-14T21:28:40Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "(Chatted offline and applied a change)",
              "createdAt": "2021-09-14T21:28:40Z",
              "updatedAt": "2021-09-14T21:28:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-DKj",
          "commit": {
            "abbreviatedOid": "56cd797"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-14T21:29:44Z",
          "updatedAt": "2021-09-14T21:29:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBtBsGM4tFel6",
          "commit": {
            "abbreviatedOid": "56cd797"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the clarifications, but I think the wording needs to be tuned.",
          "createdAt": "2021-09-16T14:52:59Z",
          "updatedAt": "2021-09-16T14:53:27Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nresistance and does not reveal the discrete log relationship between the\r\noutput point and any distinguished point on the curve (e.g., a generator point).\r\nProminent examples of cryptosystems that hash to elliptic curves include\r\n```\r\n\r\nI don't 100% love the wording I'm proposing here, but the rationale for the suggested edit:\r\n\r\n- this sentence formerly referred to a set of inputs; but the first sentence says the inputs are arbitrary, which isn't quite in harmony\r\n- discrete log is a relation between two points, so it doesn't really make sense to say the discrete log of a point is unknown without specifying the base. Being super persnickety: the discrete log of a point to itself is always known!\r\n\r\nSuggestions for improvement? I'll keep thinking about this, too.",
              "createdAt": "2021-09-16T14:52:59Z",
              "updatedAt": "2021-09-16T14:53:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4tFntN",
          "commit": {
            "abbreviatedOid": "56cd797"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T15:22:33Z",
          "updatedAt": "2021-09-16T15:22:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I imagine we can bike shed on this endlessly. Honestly, I don't think we need to be super precise here, as this is in the intro and isn't (IMO) wrong. I'd accept this change as-is and move on.",
              "createdAt": "2021-09-16T15:22:33Z",
              "updatedAt": "2021-09-16T15:22:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4tFp2s",
          "commit": {
            "abbreviatedOid": "56cd797"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T15:29:47Z",
          "updatedAt": "2021-09-16T15:29:47Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I like the first part;\r\nfor the second part, it's true that talking about the discrete log one must specify a base point, however I think this does not need to be emphasized here. \r\n\r\n`resistance and does not reveal the discrete logarithm of the output point. Prominent examples of algorithms that hash to elliptic curves include`\r\n",
              "createdAt": "2021-09-16T15:29:47Z",
              "updatedAt": "2021-09-16T15:29:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4tGTLh",
          "commit": {
            "abbreviatedOid": "56cd797"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T18:13:31Z",
          "updatedAt": "2021-09-16T18:13:31Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "OK, you've both convinced me that it's OK to be slightly imprecise here :+1:",
              "createdAt": "2021-09-16T18:13:31Z",
              "updatedAt": "2021-09-16T18:13:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4tGTWK",
          "commit": {
            "abbreviatedOid": "56cd797"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T18:14:16Z",
          "updatedAt": "2021-09-16T18:14:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Making this concrete:\r\n\r\n```suggestion\r\nresistance and does not reveal the discrete log of the output point.\r\nProminent examples of cryptosystems that hash to elliptic curves include\r\n```",
              "createdAt": "2021-09-16T18:14:16Z",
              "updatedAt": "2021-09-16T18:14:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4tG70g",
          "commit": {
            "abbreviatedOid": "764d760"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T20:54:44Z",
          "updatedAt": "2021-09-16T20:54:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nresistance and does not reveal the discrete logarithm of the output point.\r\n```",
              "createdAt": "2021-09-16T20:54:44Z",
              "updatedAt": "2021-09-16T20:54:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "PR_kwDOBtBsGM4rvsgW",
      "title": "Add long DST test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/320",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #314.",
      "createdAt": "2021-09-14T18:25:27Z",
      "updatedAt": "2022-02-18T16:42:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "7e402c595637e83db984835370818b3be4c0db32",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/long-dst-vectors",
      "headRefOid": "898996409831469e3b2ed31642f961b0f84556e0",
      "closedAt": "2021-09-16T12:56:51Z",
      "mergedAt": "2021-09-16T12:56:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d925acd7844b794afd3ccc81f8c5e1aebff12937"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4s-Ob4",
          "commit": {
            "abbreviatedOid": "6fccfb1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "a couple of comments ",
          "createdAt": "2021-09-14T22:27:59Z",
          "updatedAt": "2021-09-14T23:14:13Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "It avoids to replace the previous test vectors\r\n\r\n```suggestion\r\n    dst = \"-\".join(filter(None, [\"QUUX-V01-CS02-with\", suite_name, \"1\" * max(0, L - length)]))\r\n```",
              "createdAt": "2021-09-14T22:27:59Z",
              "updatedAt": "2021-09-14T23:14:13Z"
            },
            {
              "originalPosition": 70,
              "body": "Here the expander needs to know `k` the security parameter of the suite. It seems to be fixed to 256\r\n\r\n(Related #315 )",
              "createdAt": "2021-09-14T23:07:14Z",
              "updatedAt": "2021-09-14T23:14:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-UED",
          "commit": {
            "abbreviatedOid": "6fccfb1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T23:15:45Z",
          "updatedAt": "2021-09-14T23:15:45Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "We fix it here, so no need to pass it in. (In other words, if we want to pass in `k`, we should do it in a separate PR.)",
              "createdAt": "2021-09-14T23:15:45Z",
              "updatedAt": "2021-09-14T23:15:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-Uq-",
          "commit": {
            "abbreviatedOid": "7230bb9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T23:21:31Z",
          "updatedAt": "2021-09-14T23:21:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-09-14T23:21:32Z",
              "updatedAt": "2021-09-14T23:21:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-VCk",
          "commit": {
            "abbreviatedOid": "8989964"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-14T23:25:05Z",
          "updatedAt": "2021-09-14T23:25:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBtBsGM4s-VW8",
          "commit": {
            "abbreviatedOid": "8989964"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T23:28:04Z",
          "updatedAt": "2021-09-14T23:28:04Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "If this is fixed, then the test vector must indicate which value for k was used.\r\nI want to prevent implementors think `k` is fixed for any suite, although the doc explicitly says k is a parameter.",
              "createdAt": "2021-09-14T23:28:04Z",
              "updatedAt": "2021-09-14T23:28:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4s-Vh_",
          "commit": {
            "abbreviatedOid": "8989964"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T23:29:35Z",
          "updatedAt": "2021-09-14T23:29:35Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Feel free to file an issue and send a PR to pass it in as a parameter!",
              "createdAt": "2021-09-14T23:29:35Z",
              "updatedAt": "2021-09-14T23:29:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4tGl7w",
          "commit": {
            "abbreviatedOid": "8989964"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T19:40:46Z",
          "updatedAt": "2021-09-16T19:40:46Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Fixed this in #321 ",
              "createdAt": "2021-09-16T19:40:46Z",
              "updatedAt": "2021-09-16T19:40:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 321,
      "id": "PR_kwDOBtBsGM4r2tNk",
      "title": "Using security parameter in Expanders",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/321",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #314",
      "createdAt": "2021-09-16T19:40:19Z",
      "updatedAt": "2021-09-16T20:55:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d925acd7844b794afd3ccc81f8c5e1aebff12937",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/fixKparam",
      "headRefOid": "a0c57f6d805f883c304a060fbc6135d3bbd823e5",
      "closedAt": "2021-09-16T19:53:59Z",
      "mergedAt": "2021-09-16T19:53:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "20eb30dccf610a227f5c1f91cdd4fa6c0ac1f532"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4tGoe9",
          "commit": {
            "abbreviatedOid": "099c3b4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-16T19:53:17Z",
          "updatedAt": "2021-09-16T19:53:46Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n            dst_prime = hash_fn(_as_bytes(\"H2C-OVERSIZE-DST-\") + _as_bytes(dst)).digest(math.ceil(2 * security_param / 8))\r\n```",
              "createdAt": "2021-09-16T19:53:18Z",
              "updatedAt": "2021-09-16T19:53:46Z"
            },
            {
              "originalPosition": 21,
              "body": "Good catch!",
              "createdAt": "2021-09-16T19:53:27Z",
              "updatedAt": "2021-09-16T19:53:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 322,
      "id": "PR_kwDOBtBsGM4r31Co",
      "title": "Update pointers to reference implementations.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/322",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Both Go and Rust implementations are now compatible with v12",
      "createdAt": "2021-09-17T04:45:32Z",
      "updatedAt": "2022-02-18T16:42:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "69f92fc397ef244443c63af89cebc551114c285b",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/impl_v12",
      "headRefOid": "d4bed20e6263687d817127f8e8b8a0ce12dd06e2",
      "closedAt": "2021-09-17T13:21:04Z",
      "mergedAt": "2021-09-17T13:21:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6d40f9890a5eb63ebfa0da9e49678e140e11f755"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4tJdoS",
          "commit": {
            "abbreviatedOid": "d4bed20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-17T13:20:59Z",
          "updatedAt": "2021-09-17T13:20:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "PR_kwDOBtBsGM4seqQ_",
      "title": "Address Stanislav nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/325",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-30T00:39:24Z",
      "updatedAt": "2022-02-18T16:41:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6d40f9890a5eb63ebfa0da9e49678e140e11f755",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/irsg-nits",
      "headRefOid": "1a0fb0ce6021311df8dc6147a302c83d43d01263",
      "closedAt": "2021-10-27T18:45:13Z",
      "mergedAt": "2021-10-27T18:45:13Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "d58a30aa856d8d7a67c1799702d24fde13e23feb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4tvNhj",
          "commit": {
            "abbreviatedOid": "3e8107e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "One copypaste issue from Stanislav's email, otherwise :+1:",
          "createdAt": "2021-09-30T02:57:27Z",
          "updatedAt": "2021-09-30T02:58:25Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThis document represents the consensus of the Crypto Forum Research Group (CFRG).\r\n```\r\n\r\nI think Stanislav's email requested the above line at the end of the intro.",
              "createdAt": "2021-09-30T02:57:28Z",
              "updatedAt": "2021-09-30T02:58:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4txTgj",
          "commit": {
            "abbreviatedOid": "1a0fb0c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-30T13:56:56Z",
          "updatedAt": "2021-09-30T13:56:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 326,
      "id": "PR_kwDOBtBsGM4taROw",
      "title": "Adds CIRCL library to list of implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/326",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-19T23:36:31Z",
      "updatedAt": "2021-10-27T18:44:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6d40f9890a5eb63ebfa0da9e49678e140e11f755",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "addCIRCL",
      "headRefOid": "97a6a6095aed456d8aa035ee44d06d595260ccc3",
      "closedAt": "2021-10-27T18:44:14Z",
      "mergedAt": "2021-10-27T18:44:14Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "4eedf85c9de2d4c87c80a6818695b91599038d5c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 327,
      "id": "PR_kwDOBtBsGM4tkals",
      "title": "Updating Cloudflare affiliation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/327",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-22T21:29:29Z",
      "updatedAt": "2021-10-27T18:43:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "6d40f9890a5eb63ebfa0da9e49678e140e11f755",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "cf",
      "headRefOid": "57041f57996a05b9208c6d6217aa9b113a1aca9b",
      "closedAt": "2021-10-27T18:43:35Z",
      "mergedAt": "2021-10-27T18:43:35Z",
      "mergedBy": "kwantam",
      "mergeCommit": {
        "oid": "ea9b4deede60ba42804f6c66a72895fdbae95798"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 330,
      "id": "PR_kwDOBtBsGM4uP73C",
      "title": "clarify sgn0 in Elligator 2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/330",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #329",
      "createdAt": "2021-11-08T20:22:58Z",
      "updatedAt": "2021-11-08T20:29:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "d58a30aa856d8d7a67c1799702d24fde13e23feb",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "clarify_elligator_2",
      "headRefOid": "c17c97854fbdb357a4b3ec5db2ae47addf905ce5",
      "closedAt": "2021-11-08T20:29:47Z",
      "mergedAt": "2021-11-08T20:29:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9663067e45ab4afa95aa4fce450736806b6de4d7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4vt9HI",
          "commit": {
            "abbreviatedOid": "c17c978"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-08T20:29:43Z",
          "updatedAt": "2021-11-08T20:29:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "PR_kwDOBtBsGM4wONdL",
      "title": "Update README.md",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/332",
      "state": "MERGED",
      "author": "spitters",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood, as promised addition of hacspec to the README.",
      "createdAt": "2021-12-23T10:05:52Z",
      "updatedAt": "2021-12-23T21:21:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "9663067e45ab4afa95aa4fce450736806b6de4d7",
      "headRepository": "spitters/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "hacspec",
      "headRefOid": "d1967f2e667c946f7cea58e40b503ac55233e85f",
      "closedAt": "2021-12-23T19:38:33Z",
      "mergedAt": "2021-12-23T19:38:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3f72630334a6c7edcb5a618d72ca1da536882ea9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4yCxqu",
          "commit": {
            "abbreviatedOid": "9471546"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-23T19:37:23Z",
          "updatedAt": "2021-12-23T19:38:15Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-12-23T19:37:24Z",
              "updatedAt": "2021-12-23T19:38:15Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n- [hacspec/Rust](https://github.com/hacspec/hacspec/tree/master/examples/bls12-381-hash) BLS12-381 (tested against all the rust implementations below).\r\n```",
              "createdAt": "2021-12-23T19:38:10Z",
              "updatedAt": "2021-12-23T19:38:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 333,
      "id": "PR_kwDOBtBsGM4wT-LJ",
      "title": "SHA-512 to SHAKE256 for 448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/333",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #323",
      "createdAt": "2021-12-27T18:23:31Z",
      "updatedAt": "2022-02-18T16:41:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "9939a07fd40c0367b1ebe8e7f095f01908e18a76",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/shake-and-448",
      "headRefOid": "6ce20a1ff9397b9e1d4361a9a1bb79d6e63c9e98",
      "closedAt": "2021-12-28T16:16:37Z",
      "mergedAt": "2021-12-28T16:16:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e6517ee791d5485ad7dcaa6c74d434833a16bd30"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh fixed.",
          "createdAt": "2021-12-27T21:31:21Z",
          "updatedAt": "2021-12-27T21:31:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I'll squash and fix the commit message, then merge. Thanks for flagging!",
          "createdAt": "2021-12-28T16:15:25Z",
          "updatedAt": "2021-12-28T16:15:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4yGf7V",
          "commit": {
            "abbreviatedOid": "d694a1b"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-12-27T21:18:42Z",
          "updatedAt": "2021-12-27T21:21:11Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n| curve448     | curve448\\_XOF:SHAKE256\\_ELL2\\_RO\\_ curve448\\_XOF:SHAKE256\\_ELL2\\_NU\\_ | {{suites-448}} |\r\n| edwards448   | edwards448\\_XOF:SHAKE256\\_ELL2\\_RO\\_ edwards448\\_XOF:SHAKE256\\_ELL2\\_NU\\_ | {{suites-448}} |\r\n```",
              "createdAt": "2021-12-27T21:18:42Z",
              "updatedAt": "2021-12-27T21:21:11Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ncurve448\\_XOF:SHAKE256\\_ELL2\\_RO\\_ is defined as follows:\r\n```\r\nand everywhere else.",
              "createdAt": "2021-12-27T21:19:37Z",
              "updatedAt": "2021-12-27T21:21:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4yGgIl",
          "commit": {
            "abbreviatedOid": "d694a1b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-27T21:22:03Z",
          "updatedAt": "2021-12-27T21:22:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Ugh, oops. Thanks.",
              "createdAt": "2021-12-27T21:22:03Z",
              "updatedAt": "2021-12-27T21:22:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4yGhSl",
          "commit": {
            "abbreviatedOid": "d002765"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-27T21:42:35Z",
          "updatedAt": "2021-12-27T21:42:35Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  \"expand\": \"XOF\",\r\n```",
              "createdAt": "2021-12-27T21:42:35Z",
              "updatedAt": "2021-12-27T21:42:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4yGhfd",
          "commit": {
            "abbreviatedOid": "d002765"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-27T21:46:20Z",
          "updatedAt": "2021-12-27T21:46:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Bug in the suite generation code. Will fix. ",
              "createdAt": "2021-12-27T21:46:20Z",
              "updatedAt": "2021-12-27T21:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4yGiGb",
          "commit": {
            "abbreviatedOid": "4fd355c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-27T21:58:06Z",
          "updatedAt": "2021-12-27T21:58:06Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "@armfazh done.",
              "createdAt": "2021-12-27T21:58:06Z",
              "updatedAt": "2021-12-27T21:58:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4yGkWp",
          "commit": {
            "abbreviatedOid": "4fd355c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-27T22:47:09Z",
          "updatedAt": "2021-12-27T22:47:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBtBsGM4yGw2C",
          "commit": {
            "abbreviatedOid": "4fd355c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good! The only tiny comment: the commit messages say \"SHA256\" where they mean to say \"SHAKE-256\", I think. Probably not a huge deal, but if it's not a pain to fix it might be better to fix it than to leave it wrong...",
          "createdAt": "2021-12-28T03:48:42Z",
          "updatedAt": "2021-12-28T03:48:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 334,
      "id": "PR_kwDOBtBsGM4wWAqA",
      "title": "Address some RGLC nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/334",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #328, based on comments in that issue",
      "createdAt": "2021-12-28T17:42:35Z",
      "updatedAt": "2022-02-18T16:41:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "e6517ee791d5485ad7dcaa6c74d434833a16bd30",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/rglc-nits",
      "headRefOid": "27550cf29613eac901d7e7df584cc6e50884d5a2",
      "closedAt": "2021-12-28T18:11:43Z",
      "mergedAt": "2021-12-28T18:11:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "22620573aae2395ce6f335d4b217a83d2f3511b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4yISMp",
          "commit": {
            "abbreviatedOid": "40d4242"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good! One tiny thing that's maybe nothing.",
          "createdAt": "2021-12-28T18:10:29Z",
          "updatedAt": "2021-12-28T18:10:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n2.  ABORT if ell > 255 or len_in_bytes > 65535 or len(DST) > 255\r\n```\r\n\r\nTiny nit: \"65535\" is actually 1 character shorter than 2^16-1!\r\n\r\n(But I don't feel strongly either way...)",
              "createdAt": "2021-12-28T18:10:29Z",
              "updatedAt": "2021-12-28T18:10:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4yISTS",
          "commit": {
            "abbreviatedOid": "27550cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-28T18:11:37Z",
          "updatedAt": "2021-12-28T18:11:37Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "That's better =) ",
              "createdAt": "2021-12-28T18:11:37Z",
              "updatedAt": "2021-12-28T18:11:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 337,
      "id": "PR_kwDOBtBsGM4y1C8M",
      "title": "Address Colin Perkins review",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/337",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-15T03:14:43Z",
      "updatedAt": "2022-02-18T16:41:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "22620573aae2395ce6f335d4b217a83d2f3511b1",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "caw/colin-review",
      "headRefOid": "db32e0fdb63f864eb49ce1ebee71dade4a71da9b",
      "closedAt": "2022-02-17T23:27:51Z",
      "mergedAt": "2022-02-17T23:27:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "32a344bbcd217b431e3ad54c0bcfeb64891ff3ff"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam suggestions applied -- thanks for the review!",
          "createdAt": "2022-02-17T01:54:56Z",
          "updatedAt": "2022-02-17T01:54:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Just checked, if you search the document for \"(see discussion above)\" you will find a lot of those indirections. I guess we should sweep for them...\r\n\r\n(In fact, most of the code blocks seem to have one! D'oh...)",
          "createdAt": "2022-02-17T01:59:29Z",
          "updatedAt": "2022-02-17T02:00:19Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Hrm, now I'm getting worried. Are we sure we don't want to just keep \"(see discussion above)\" or maybe \"(see discussion immediately above)\" and indirect from there? Seems safer, even if it's slightly awkward.",
          "createdAt": "2022-02-17T02:01:26Z",
          "updatedAt": "2022-02-17T02:01:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I wouldn't worry too much about this :) The document is sufficient stable at this point that section references won't change without us noticing. I'll do a sweep and fix the others where \"immediately above\" isn't the same section/paragraph.",
          "createdAt": "2022-02-17T02:03:31Z",
          "updatedAt": "2022-02-17T02:03:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM40xErc",
          "commit": {
            "abbreviatedOid": "b018d08"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Just a few small nits, otherwise looks good!\r\n\r\nI'm going to check right now on my last comment (about hyperlinks inside verbatim blocks). I suspect it does not work, but I'll report either way.",
          "createdAt": "2022-02-16T23:55:52Z",
          "updatedAt": "2022-02-17T00:05:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n-   The function hash\\_to\\_field hashes arbitrary-length byte strings to a list\r\n```",
              "createdAt": "2022-02-16T23:55:52Z",
              "updatedAt": "2022-02-17T00:05:56Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n-   The function map\\_to\\_curve calculates a point on the elliptic curve E\r\n```",
              "createdAt": "2022-02-16T23:56:28Z",
              "updatedAt": "2022-02-17T00:05:56Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n-   The function clear\\_cofactor sends any point on the curve E to\r\n```",
              "createdAt": "2022-02-16T23:56:42Z",
              "updatedAt": "2022-02-17T00:05:56Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nInputs:\r\n- msg, a byte string containing the message to hash.\r\n- count, the number of elements of F to output.\r\n\r\nOutputs:\r\n- (u_0, ..., u_(count - 1)), a list of field elements.\r\n\r\nSteps: defined in Section 5.\r\n```\r\n\r\nSince \"Inputs\" and \"Outputs\" span multiple lines, it might be clearer to add vertical space. What do you think?",
              "createdAt": "2022-02-16T23:59:58Z",
              "updatedAt": "2022-02-17T00:05:56Z"
            },
            {
              "originalPosition": 89,
              "body": "I don't think `{{section-name}}` works inside code blocks, does it? Maybe I'm remembering an old version of the toolchain...",
              "createdAt": "2022-02-17T00:02:31Z",
              "updatedAt": "2022-02-17T01:41:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xTcA",
          "commit": {
            "abbreviatedOid": "b018d08"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T01:50:44Z",
          "updatedAt": "2022-02-17T01:50:44Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Yeah, checked, at least with my toolchain the links don't get resolved. I'm pretty sure that's why we had previously said \"see discussion above\" and in that discussion linked to the appropriate section.\r\n\r\nAlso: don't we have simliar things going on in other code blocks in the document? I thought so...\r\n\r\nI guess we could manually link things together if we're sure the document is in its final form, but I'm a little nervous about that. I wonder if the markdown processor supports a way of unquoting...",
              "createdAt": "2022-02-17T01:50:44Z",
              "updatedAt": "2022-02-17T01:50:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xTpa",
          "commit": {
            "abbreviatedOid": "04ca21c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T01:52:30Z",
          "updatedAt": "2022-02-17T01:52:30Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Yeah, this is better!",
              "createdAt": "2022-02-17T01:52:30Z",
              "updatedAt": "2022-02-17T01:52:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xTs_",
          "commit": {
            "abbreviatedOid": "2f96bb9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T01:52:59Z",
          "updatedAt": "2022-02-17T01:53:00Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "We can just manually wire things up for now. The RFC editor will deal with this for us anyway.",
              "createdAt": "2022-02-17T01:52:59Z",
              "updatedAt": "2022-02-17T01:53:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xT7J",
          "commit": {
            "abbreviatedOid": "96a542f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T01:54:45Z",
          "updatedAt": "2022-02-17T01:54:45Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "(Fixed)",
              "createdAt": "2022-02-17T01:54:45Z",
              "updatedAt": "2022-02-17T01:54:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xT8s",
          "commit": {
            "abbreviatedOid": "96a542f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T01:54:55Z",
          "updatedAt": "2022-02-17T01:54:55Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "They'll double check that the section pointers seem sensible? Or you're saying, we give them the markdown and they fix it? (In that case, do we leave a note in the document for the editor?)",
              "createdAt": "2022-02-17T01:54:55Z",
              "updatedAt": "2022-02-17T01:54:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xUI9",
          "commit": {
            "abbreviatedOid": "96a542f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T01:56:27Z",
          "updatedAt": "2022-02-17T01:56:27Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Yeah, they double check that the pointers are correct. They are very thorough...",
              "createdAt": "2022-02-17T01:56:27Z",
              "updatedAt": "2022-02-17T01:56:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40xUEk",
          "commit": {
            "abbreviatedOid": "96a542f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Noticed a couple more tiny things. Looks great!",
          "createdAt": "2022-02-17T01:55:54Z",
          "updatedAt": "2022-02-17T01:56:39Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nBoth are implemented as a composition of the three basic functions above.\r\n```",
              "createdAt": "2022-02-17T01:55:54Z",
              "updatedAt": "2022-02-17T01:56:39Z"
            },
            {
              "originalPosition": 82,
              "body": "One more of these.",
              "createdAt": "2022-02-17T01:56:21Z",
              "updatedAt": "2022-02-17T01:56:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM401XWe",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T18:48:33Z",
          "updatedAt": "2022-02-17T21:32:30Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nInput: u, an element in field F.\r\n```\r\n\r\n`in the field` not sure about adding `the`.",
              "createdAt": "2022-02-17T18:48:33Z",
              "updatedAt": "2022-02-17T21:32:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM402Iul",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T21:59:43Z",
          "updatedAt": "2022-02-17T21:59:44Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I would probably go with `an element of field F`.",
              "createdAt": "2022-02-17T21:59:43Z",
              "updatedAt": "2022-02-17T21:59:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM402Y_Y",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:25:05Z",
          "updatedAt": "2022-02-17T23:25:05Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "not sure if `CAN` is a word listed in RFC2119",
              "createdAt": "2022-02-17T23:25:05Z",
              "updatedAt": "2022-02-17T23:25:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM402ZNO",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:26:32Z",
          "updatedAt": "2022-02-17T23:26:33Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nInput: u, an element of field F.\r\n```",
              "createdAt": "2022-02-17T23:26:32Z",
              "updatedAt": "2022-02-17T23:26:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM402ZPR",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:26:45Z",
          "updatedAt": "2022-02-17T23:26:46Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Good catch @armfazh  -- fixed!",
              "createdAt": "2022-02-17T23:26:45Z",
              "updatedAt": "2022-02-17T23:26:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM402ZRR",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:26:57Z",
          "updatedAt": "2022-02-17T23:26:58Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "```suggestion\r\ncan be used, but in all cases the encoding as a sequence of bytes MUST be\r\n```",
              "createdAt": "2022-02-17T23:26:57Z",
              "updatedAt": "2022-02-17T23:26:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM402ZTD",
          "commit": {
            "abbreviatedOid": "736547f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:27:07Z",
          "updatedAt": "2022-02-17T23:27:07Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Hah, I think that's right. I made it non-normative.",
              "createdAt": "2022-02-17T23:27:07Z",
              "updatedAt": "2022-02-17T23:27:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 338,
      "id": "PR_kwDOBtBsGM4zCm83",
      "title": "Give name to some sections and fix xof functions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/338",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "changes:\r\n - give names to some subsections.\r\n - be precise in elligator 2 for Montgomery curves\r\n - according to FIPS-202, XOF stands for extendable-output function",
      "createdAt": "2022-02-18T03:34:48Z",
      "updatedAt": "2022-02-18T16:33:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "32a344bbcd217b431e3ad54c0bcfeb64891ff3ff",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/sections",
      "headRefOid": "9d73c87008db2fd8ae3994c933878d9d35b62b00",
      "closedAt": "2022-02-18T16:33:12Z",
      "mergedAt": "2022-02-18T16:33:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4c5a3100481764c51d27e2fd32d7e0413d4c7292"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4023DI",
          "commit": {
            "abbreviatedOid": "664131f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks great! I only request one small revert. Otherwise this is a nice improvement. ",
          "createdAt": "2022-02-18T03:35:33Z",
          "updatedAt": "2022-02-18T03:40:30Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n{: #table-1 title=\"Summary of symbols and their definitions.\"}\r\n```",
              "createdAt": "2022-02-18T03:35:33Z",
              "updatedAt": "2022-02-18T03:40:30Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n- H(m, d), an extendable-output function that hashes input\r\n           message m and returns d bytes.\r\n```",
              "createdAt": "2022-02-18T03:36:32Z",
              "updatedAt": "2022-02-18T03:40:30Z"
            },
            {
              "originalPosition": 85,
              "body": "I think we should revert this (and the change below) as it's redundant with the definition in 6.7.",
              "createdAt": "2022-02-18T03:37:52Z",
              "updatedAt": "2022-02-18T03:40:30Z"
            },
            {
              "originalPosition": 131,
              "body": "Good catch!",
              "createdAt": "2022-02-18T03:39:57Z",
              "updatedAt": "2022-02-18T03:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4024Kq",
          "commit": {
            "abbreviatedOid": "bf319c3"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T03:47:29Z",
          "updatedAt": "2022-02-18T03:47:30Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "well, a XOF is not a hash, so it cannot `hashes`",
              "createdAt": "2022-02-18T03:47:30Z",
              "updatedAt": "2022-02-18T03:47:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4024mJ",
          "commit": {
            "abbreviatedOid": "bf319c3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T03:52:16Z",
          "updatedAt": "2022-02-18T03:52:16Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Well, feel free to replace \"hash\" with \"process,\" even though I think hash is sufficient clear.",
              "createdAt": "2022-02-18T03:52:16Z",
              "updatedAt": "2022-02-18T03:52:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4024pR",
          "commit": {
            "abbreviatedOid": "d775bc9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T03:52:45Z",
          "updatedAt": "2022-02-18T03:52:45Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "reverted\r\n",
              "createdAt": "2022-02-18T03:52:45Z",
              "updatedAt": "2022-02-18T03:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM40240V",
          "commit": {
            "abbreviatedOid": "9d73c87"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T03:54:24Z",
          "updatedAt": "2022-02-18T03:54:24Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "done\r\n",
              "createdAt": "2022-02-18T03:54:24Z",
              "updatedAt": "2022-02-18T03:54:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBtBsGM4027KA",
          "commit": {
            "abbreviatedOid": "9d73c87"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me! Nice fixes :)",
          "createdAt": "2022-02-18T04:19:05Z",
          "updatedAt": "2022-02-18T04:19:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBtBsGM405j5l",
          "commit": {
            "abbreviatedOid": "9d73c87"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T16:33:06Z",
          "updatedAt": "2022-02-18T16:33:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "PR_kwDOBtBsGM4zCnC4",
      "title": "Mark blocks of code as pseudocode.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/339",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does not modify anything visually but it allows kramdown to include metadata of code blocks.\r\n\r\nAlso fix some indentation when code is nested in a list of items.",
      "createdAt": "2022-02-18T03:35:19Z",
      "updatedAt": "2022-02-18T16:36:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "32a344bbcd217b431e3ad54c0bcfeb64891ff3ff",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/pseudocode",
      "headRefOid": "26eb55181c5c9a60383cc0a0ff72003b5b53b36c",
      "closedAt": "2022-02-18T16:36:37Z",
      "mergedAt": "2022-02-18T16:36:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d95c3f916e8acf703f6c5316efa0cab1fe591e64"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Have you tried compiling this with the toolchain? I vaguely recall removing indentation because it broke compilation, but maybe that's an old verison of the tools.",
          "createdAt": "2022-02-18T04:20:30Z",
          "updatedAt": "2022-02-18T04:20:30Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Have you tried compiling this with the toolchain? \r\n\r\nYes, no issues with indentation with current version.\r\n",
          "createdAt": "2022-02-18T04:25:36Z",
          "updatedAt": "2022-02-18T04:25:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I checked the compilation as well, and the output looks good. Merging.",
          "createdAt": "2022-02-18T16:36:33Z",
          "updatedAt": "2022-02-18T16:36:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM4023qY",
          "commit": {
            "abbreviatedOid": "26eb551"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The RFC editor will take care of stuff like this for us, but I suppose we can also do the work. =)",
          "createdAt": "2022-02-18T03:41:58Z",
          "updatedAt": "2022-02-18T03:41:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 340,
      "id": "PR_kwDOBtBsGM4zCnVA",
      "title": "Moves the template repo to main branch.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/340",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the warning message\r\n```\r\nlib/id.mk:10: **************************************************************\r\nlib/id.mk:11: ***                                                        ***\r\nlib/id.mk:12: ***   You are on the 'master' branch of i-d-template.      ***\r\nlib/id.mk:13: ***   This branch is not supported.                        ***\r\nlib/id.mk:14: ***   Please update to use 'main'.                         ***\r\nlib/id.mk:15: ***                                                        ***\r\nlib/id.mk:20: ***   sed -i~ s/master/main/ Makefile                      ***\r\nlib/id.mk:21: ***   rm -rf lib                                           ***\r\nlib/id.mk:23: ***                                                        ***\r\nlib/id.mk:24: **************************************************************\r\n```",
      "createdAt": "2022-02-18T03:37:12Z",
      "updatedAt": "2022-02-19T15:20:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "main",
      "baseRefOid": "32a344bbcd217b431e3ad54c0bcfeb64891ff3ff",
      "headRepository": "armfazh/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/moveToMain",
      "headRefOid": "e30f689dbcbc2697be916f757be2e8080c210684",
      "closedAt": "2022-02-19T15:20:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's do this after all other PRs are merged.",
          "createdAt": "2022-02-18T03:40:57Z",
          "updatedAt": "2022-02-18T03:40:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed default branch to `main` directly.",
          "createdAt": "2022-02-19T15:20:12Z",
          "updatedAt": "2022-02-19T15:20:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 341,
      "id": "PR_kwDOBtBsGM4zDEki",
      "title": "two small items from pcode checking pass",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/341",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Both very tiny. I checked all pcode in `poc/` against what's in the document.",
      "createdAt": "2022-02-18T05:50:26Z",
      "updatedAt": "2022-02-18T16:32:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "master",
      "baseRefOid": "32a344bbcd217b431e3ad54c0bcfeb64891ff3ff",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "pcode_check_pass",
      "headRefOid": "a3e2a06f4e006402246780a03108fbae605acc12",
      "closedAt": "2022-02-18T16:32:40Z",
      "mergedAt": "2022-02-18T16:32:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d0329d227ecfdcefc0d1ca84716529edbeac8c86"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM405jwr",
          "commit": {
            "abbreviatedOid": "a3e2a06"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T16:32:35Z",
          "updatedAt": "2022-02-18T16:32:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 345,
      "id": "PR_kwDOBtBsGM424elP",
      "title": "edw_to_monty_generic should be monty_to_edw_generic",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/345",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes naming issue in Appendix D.1\r\n\r\ncloses #344",
      "createdAt": "2022-04-27T15:09:35Z",
      "updatedAt": "2022-04-27T15:29:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "main",
      "baseRefOid": "491767c2768fddde75d749996bc0169ced715252",
      "headRepository": "kwantam/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "main",
      "headRefOid": "4bb763829933e73c5998f7d571cae14d40433ffa",
      "closedAt": "2022-04-27T15:29:38Z",
      "mergedAt": "2022-04-27T15:29:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "05cb35034608c2b3e0121a76f236b6bfc5879e11"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for quickly replying to the issue and for the PR!",
          "createdAt": "2022-04-27T15:29:34Z",
          "updatedAt": "2022-04-27T15:29:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM447cbM",
          "commit": {
            "abbreviatedOid": "4bb7638"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-27T15:29:05Z",
          "updatedAt": "2022-04-27T15:29:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 346,
      "id": "PR_kwDOBtBsGM45SXFq",
      "title": "Rev sd",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/346",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR cover largely the comments and observations by Spencer D.\r\nIt's better to do review commit-by-commit so the diff changes get lets noisy.\r\n\r\n\r\n> I'm only vaguely aware of how this stuff works, so please keep that in mind, when reading my comments. I hope they are somewhat helpful. \r\n> \r\n> In this text from the Introduction, \r\n> \r\n> Unfortunately for implementors, the precise hash function that is suitable for a given protocol implemented using a given elliptic curve is often unclear from the protocol's description. Meanwhile, an incorrect choice of hash function can have disastrous consequences for security.\r\n> \r\n> I\u2019m not sure I understand (at this point in the document) what the problem is (\u201cwhy it\u2019s not OK to just pick a hash function\u201d), other than \u201cif you do that, bad things will happen\u201d). Is there a reference you could include here, or even a forward pointer if there's a good place to point to in the draft, so that us non-experts can follow along?\r\n\r\n1. Not sure how to resolve this one.\r\nTwo paragraphs below the cited text there is a pointer to Section 8 for those who want to quickly jump in. I consider this is enough as a forward pointer.\r\n\r\n\r\n> I learned a lot from googling \u201crejection sampling methods\u201d while reading this text\r\n> \r\n> This document does not cover rejection sampling methods, sometimes referred to as \"try-and-increment\" or \"hunt-and-peck,\"\r\n> \r\n> But the text didn\u2019t tell me enough to understand rejection sampling methods. Perhaps a half-sentence explanation, or a reference, would be helpful.\r\n\r\n2. See commit https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/commit/95b21a5b4a53fd2f185089c13a4aceca8bb17dca\r\n\r\n> This is nit-ish, but it confused me. \r\n> \r\n> 5.1.  Security considerations, is only for section 5, is that right? There\u2019s another Security Considerations - section 10 - which starts with these two sentences: \r\n> \r\n> Section 3.1 describes considerations related to domain separation. See Section 10.4 for further discussion.\r\n> \r\n> Section 5 describes considerations for uniformly hashing to field elements; see Section 10.2 and Section 10.3 for further discussion.\r\n> \r\n> I found myself wondering why some security considerations seem to be in Section 3.1 (which isn\u2019t called Security considerations), and others seem to be in Section 5 (shouldn\u2019t the second sentence refer to Section 5.1, which IS called Security considerations?), and these considerations outside Section 10 aren\u2019t complete. If I was looking for all the Security considerations, I\u2019d expect to find them together, and probably in Section 10. \r\n> \r\n> Do the right thing, of course. \r\n\r\n3. See commits https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/commit/86f9947c8f4b8cec0b24639a17cd8d110391f9dd and  https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/commit/11744a15e3b489c14ce002e1aa3180ee50fbd5ed\r\n\r\n\r\n> I\u2019m not picking on [BCP 14](https://datatracker.ietf.org/doc/bcp14/) language in most of the text, but in Section 7, \r\n> \r\n> Note that in this case scalar multiplication by the cofactor h does not generally give the same result as the fast method, and SHOULD NOT be used.\r\n> \r\n> I\u2019m not understanding why this is not a MUST - when is it OK to use scalar multiplication, if it usually gives a different result?\r\n\r\n4. See commits https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/commit/a78c19a49d7d1f9803d706e8a993b870eba46597\r\n\r\n\r\n> I have roughly the same question in Section 8.5,\r\n> \r\n> This section defines ciphersuites for curve25519 and edwards25519 [[RFC7748](https://datatracker.ietf.org/doc/rfc7748/)]. Note that these ciphersuites SHOULD NOT be used when hashing to ristretto255 [I-D.irtf-cfrg-ristretto255-decaf448]. See Appendix B for information on how to hash to that group.\r\n> \r\n> What if I DO use these ciphersuites inappropriately? \r\n> \r\n> Very similar text is in 8.6, so I have a very similar question. \r\n> \r\n> This section defines ciphersuites for curve448 and edwards448 [[RFC7748](https://datatracker.ietf.org/doc/rfc7748/)]. Note that these ciphersuites SHOULD NOT be used when hashing to decaf448 [I-D.irtf-cfrg-ristretto255-decaf448]. See Appendix C for information on how to hash to that group.\r\n> \r\n> Do the right thing, of course.\r\n\r\n5. See commits https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/commit/3825baa9ba60b4452e19e257da93b528369ab855\r\n\r\n> In section 8.9, \r\n> \r\n> The RECOMMENDED way to define a new hash-to-curve suite is:\r\n> \r\n> <snipped down to>\r\n> \r\n> When hashing to an elliptic curve not listed in this section, corresponding hash-to-curve suites SHOULD be fully specified as described above.\r\n> \r\n> As a nit, \u201cnot listed in this section\u201d might reasonably be read as \u201cnot listed in section 8.9\u201d. I think you might better say \u201cnot listed elsewhere in section 8\u201d. \r\n> \r\n> But beyond that, I don\u2019t think you mean \u201cRECOMMENDED\u201d in the [BCP 14](https://datatracker.ietf.org/doc/bcp14/) sense. If this text said \r\n> \r\n> For elliptic curves not listed elsewhere in section 8, a new hash-to-curve suite can be defined by \r\n<steps 1-8 as they appear in the draft>\r\n> \r\n> You wouldn\u2019t need any of the [BCP 14](https://datatracker.ietf.org/doc/bcp14/) language in this section, with the attendant \u201cwhy is this not a MUST\u201d, \u201cin what cases would you not do this\u201d, and \u201cif you don\u2019t do this, what happens?\u201d questions that reviewers can\u2019t help asking \u2026\r\n\r\n6. See commits https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/commit/11055a3c7441ec1fcc17782736a7dcf8365c472a\r\n\r\n",
      "createdAt": "2022-06-08T02:54:48Z",
      "updatedAt": "2022-06-15T12:33:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "main",
      "baseRefOid": "05cb35034608c2b3e0121a76f236b6bfc5879e11",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "revSD",
      "headRefOid": "00cbf7b30f792afd3e2d2674708ff4d971f0c3f4",
      "closedAt": "2022-06-15T12:33:11Z",
      "mergedAt": "2022-06-15T12:33:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "664b13592116cecc9e52fb192dcde0ade36f904e"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Applied requested changes.",
          "createdAt": "2022-06-14T18:49:04Z",
          "updatedAt": "2022-06-14T18:49:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM479Roc",
          "commit": {
            "abbreviatedOid": "3825baa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! This looks good to me, pending some suggestions.",
          "createdAt": "2022-06-14T13:58:29Z",
          "updatedAt": "2022-06-14T14:01:05Z",
          "comments": [
            {
              "originalPosition": 179,
              "body": "```suggestion\r\n## Hashing passwords {#security-considerations-passwords}\r\n```",
              "createdAt": "2022-06-14T13:58:29Z",
              "updatedAt": "2022-06-14T14:01:05Z"
            },
            {
              "originalPosition": 213,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-06-14T13:58:48Z",
              "updatedAt": "2022-06-14T14:01:05Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\nHowever, the running time of this method, which is generally referred\r\nto as a probabilistic try-and-increment algorithm, depends on the input string.\r\n```",
              "createdAt": "2022-06-14T13:59:26Z",
              "updatedAt": "2022-06-14T14:01:05Z"
            },
            {
              "originalPosition": 220,
              "body": "```suggestion\r\nAs such, it is not safe to use in protocols sensitive to timing\r\n```",
              "createdAt": "2022-06-14T14:00:12Z",
              "updatedAt": "2022-06-14T14:01:05Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n# Security considerations {#security-considerations}\r\n\r\nThis section contains additional security considerations about the hash-to-curve mechanisms\r\ndescribed in this document.\r\n```",
              "createdAt": "2022-06-14T14:00:44Z",
              "updatedAt": "2022-06-14T14:01:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 350,
      "id": "PR_kwDOBtBsGM5A2f7F",
      "title": "Removes a reference to pairing-friendly expired draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/350",
      "state": "OPEN",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Suggestion raised by Watson Ladd (@wbl) posted at \r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/LYZ09KNhZj6cRQ26Yc0IYHEuOYg/",
      "createdAt": "2022-10-15T02:02:03Z",
      "updatedAt": "2022-10-18T18:58:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "baseRefName": "main",
      "baseRefOid": "664b13592116cecc9e52fb192dcde0ade36f904e",
      "headRepository": "cfrg/draft-irtf-cfrg-hash-to-curve",
      "headRefName": "armfazh/delRefPairingDraft",
      "headRefOid": "fb6f105d910d3805a96c7dffa2fedf8c29270b2a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBtBsGM5EVBpm",
          "commit": {
            "abbreviatedOid": "fb6f105"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2022-10-18T18:58:18Z",
          "updatedAt": "2022-10-18T18:58:18Z",
          "comments": []
        }
      ]
    }
  ]
}